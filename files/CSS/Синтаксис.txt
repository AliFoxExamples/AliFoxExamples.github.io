--------------------------------------------------------------------------------------------------------------------------------------------

Синтаксис "CSS".

Виды синтаксиса "CSS":

	Встроенный ("Inline"). С помощью встроенного "CSS" можно стилизовать элементы "HTML", через атрибут "style" в самом "HTML" документе.
	
	Пример использования встроенного "CSS":
	
		style="свойство1:значение; свойство2:значение; свойствоN:значение;"
		
		или
		
		style="свойство1:значение1, значение2, значениеN; свойство2:значение1, значение2, значениеN; свойствоN:значениеN"
		
	Вложенный ("Embedded"). С помощью вложенного "CSS" можно стилизовать элементы "HTML", через тег "<style>" в самом "HTML" документе.
	Вложенный тег "<style>" обязательно должен находиться в контейнере тега "<head>". Вид синтаксиса вложенного "CSS" соответствует
	синтаксису файла внешнего "CSS".
	
	Пример использования вложенного "CSS":
	
		<head>	
			<style>
				p {
					color:white;
					background-color:gray;
				}
			</style>
		</head>
		
	Внешний ("External"). С помощью внешнего "CSS" можно стилизовать элементы "HTML", через внешний "CSS" документ с расширением ".css".
	Этот документ подключается в документу "HTML" через тег "<link>", который обязательно должен распологаться в контейнере тега "<head>".
	В теге "<link>" будут обязательные атрибуты: атрибут "rel" с аргументом "stylesheet"; атрибут "href" со ссылкой в качестве аргумента
	(относительный или абсолютный).
	
	Пример подключения внешнего "CSS":
	
		<head>
			<link rel="stylesheet" href="css-file.css" />
		</head>

--------------------------------------------------------------------------------------------------------------------------------------------

Внешний синтаксис "CSS". Во внешнем синтаксисе "CSS" используется селекторы (то, к чему будет применяться стилизация), свойства и его
значения.

Вид внешнего "CSS":
	
		селектор {
			свойство: значение;
			свойство2:значение1 значение 2, значениеN;
			своствоN:значениеN;
		}

Типы селекторов:

	Селектор "тег" - свойство и значение будет применяться ко всем тегам, которые равны указанному тегу в указанном контейнере. Чтобы
	придать стиль указанному (указанным) тегу (тегам) "HTML" через способ "тег", то сам тег выбирается в "CSS", и оформляется.
	Для оформления тега (тегов) через селектор тега, оно выбирается в "CSS" посредством выбора самого тега, после чего будед задан стиль
	всем тегам равные указанному тегу в указанной ветке (например если требутеся оформить тег в каком либо контейнере (например "<body>"),
	то будет задан стиль всем подобныйм тегам в указанном контейнере.
	
	Пример синтаксиса внешнего "CSS":
	
		h1 {
			color:red;
		}
	
	Селектор "класс" ("class") - чтобы придать стиль отдельному элементу "HTML" через способ "class", ему задается атрибут "class" с
	произвольным именем в качестве аргумента, который дальше будет выбран в "CSS" для его оформления. Для оформления элемента через
	"class", элементу задается его произвольное имя в "HTML", и дальше оно выбирается в "CSS" через символ ".", то есть сам класс будет
	указываться через символ ".". Различие метода выбора селектора через "class" с методом выбора селектора через "id" в том, что
	класс может быть присвоен нескольким элементам, а уникальный идентификатор только одному элементу. Имя класса нельзя начинать с
	числа.
	
	Пример оформления элемента "<p>" через атрибут "class":
	
		Фрагмент содержимого "HTML" документа:
		
			<p class="paragraph">
				Текст в параграфе
			</p>
		
		Франмент содержимого "CSS" файла:
		
			.paragraph {
				color:red;
			}
	
	Селектор "уникальный идентификатор" ("id") - чтобы придать стиль отдельному элементу "HTML" через способ "id", ему задается атрибут
	"id" с уникальным именем в качестве аргумента, который дальше будет выбран в "CSS" для его оформления. Для оформления элемента через
	"id", элементу задается его уникальный идентификатор в "HTML", и дальше он выбирается в "CSS" через символ "#", то есть сам
	уникальный идентификатор будет указываться через символ "#". Имя уникального идентификатора нельзя начинать с числа.
	
	Пример оформления элемента "<p>" через атрибут "id":
	
		Фрагмент содержимого "HTML" документа:
		
			<p id="some-paragraph">
				Текст в параграфе
			</p>
		
		Франмент содержимого "CSS" файла:
		
			#some-paragraph {
				color:red;
			}

Селекторы потомков. Эти селекторы используются для выбора элементов, которые являются потомками других элементов. При выборе уровней,
можно выбрать столько уровней в глубину, сколько необходимо выбрать. Типы у селекторов моуг быть разные. Сами селекторы указываются
по очереди.

Вид внешнего "CSS" с селекторами потомков:

		селектор селектор2 селекторN {
			свойство: значение;
			свойство2:значение1 значение 2, значениеN;
			своствоN:значениеN;
		}

		В этом примере настройка стиля будет применяться только к последнему селектору в списке потомков.
		
В значениях свойств моугт быть несколько групп значений, разделенных запятыми (исключением является свойство "transform", где множество
значений будут указываться через пробел). 

Например:

	box-shadow: 10px 10px 5px 5px #888888, -10px -10px 5px 5px blue;
	
	В данном примере в первой группе значений (до запятой) задается тень в 10 пикселей вправо, в 10 пикселей вниз, с размытием и сжатием
	в 5 пикселей и серым цветом. А во второй группе значений (после запятой), задается тень в 10 пикслей влево, в 10 пикслеей вверх, с
	размытием и сжатием в 5 пикселей и синим цветом.	

--------------------------------------------------------------------------------------------------------------------------------------------

Комплексные селекторы.

Селектор наличия атрибута:

	Селектор атрибута определяет элемент на основе того, включен ли этот атрибут или нет, независимо от его фактического значения.
	Чтобы выбрать элемент основываясь на том, присутствует атрибут или нет, просто включите имя атрибута в
	квадратных скобках "[]" в селекторе. Квадратные скобки могут идти после любого селектора типа или класса, в зависимости от
	желаемого уровня специфичности.

	Пример использования селектора наличия атрибута на основе тега "<a>":

		HTML:
		
			<a href="#" target="_blank">...</a>
			
		CSS:
		
			a[target] {...}
		
Селектор атрибута "=":

	Для идентификации элемента с определённым и точно заданным значением может быть использован тот же селектор что и раньше, однако на
	этот раз внутри квадратных скобок после имени атрибута включают желаемое значение. Внутри квадратных скобок должно быть имя атрибута
	идущее после знака равно "=", где внутри кавычек и пишется желаемое значение атрибута.
	
	Пример использования селектора атрибута "=" на основе тега "<a>":
	
		HTML:
		
			<a href="http://google.com/">...</a>
			
		CSS:
		
			a[href="http://google.com/"] {...}
			
Селектор атрибута "*=":

	Когда мы пытаемся найти элемент на основе части значения атрибута, но не точного совпадения, может быть использован символ
	звёздочки "*" в квадратных скобках селектора. Звёздочка должна идти сразу после имени атрибута, непосредственно перед знаком равенства.
	Это означает, что следующее за ним значение только должно появиться или содержаться в значении атрибута.
	
	Пример использования селектора атрибута "*=" на основе тега "<a>":
	
		HTML:
		
			<a href="/login.php">...</a>
			
		CSS:
		
			a[href*="login"] {...}
			
Селектор атрибута "^=":

	В дополнение к выбору элемента на основе того, что значение атрибута содержит указанный текст, можно также выбрать элемент, основанный
	на том, с чего начинается значение атрибута. Использование символа циркумфлекса "^" в квадратных скобках селектора между именем
	атрибута и знаком равенства означает, что значение атрибута должно начинаться с указанного текста.
	
	Пример использования селектора атрибута "^=" на основе тега "<a>":
	
		HTML:
		
			<a href="https://chase.com/">...</a>
			
		CSS:
		
			a[href^="https://"] {...}
			
Селектор атрибута "$=":

	Противоположностью предыдущего селектора является селектор атрибутов, где значение оканчивается определённым текстом.
	Вместо использования символа "^" применяется знак доллара "$" в квадратных скобках селектора между именем атрибута и знаком равенства.
	Использование знака доллара означает, что значение атрибута должно заканчиваться указанным текстом.
	
	Пример использования селектора атрибута "$=" на основе тега "<a>":
	
		HTML:
		
			<a href="/docs/menu.pdf">...</a>
			
		CSS:
		
			a[href$=".pdf"] {...}
			
Селектор атрибута "~=":

	Иногда значения атрибутов могут быть расположены через пробел друг от друга, в которых только одно из слов должно подходить для
	создания выборки. В этом случае использование символа тильды "~" в квадратных скобках селектора между именем атрибута и знаком
	равенства означает значение атрибута разделённое пробелами, из которых одно слово точно соответствует указанному значению.
	
	Пример использования селектора атрибута "~=" на основе тега "<a>":
	
		HTML:
		
			<a href="#" rel="tag nofollow">...</a>
			
		CSS:
		
			a[rel~="tag"] {...}
			
Селектор атрибута "|=":

	Когда значение атрибута разделено дефисом, а не пробелами, может быть использован символ вертикальной линии "|" в квадратных
	скобках селектора между именем атрибута и знаком равенства. Вертикальная линия означает, что значение атрибута может быть
	разделено дефисом, однако слова должны начинаться с указанного значения.
	
	Пример использования селектора атрибута "|=" на основе тега "<a>":
	
		HTML:
		
			<a href="#" lang="en-US">...</a>	
			
		CSS:
		
			a[lang|="en"] {...}
			
			
Селектор пользовательского атрибута "data-...":

	Пример:
	
		HTML:
		
			<div data-columns="2">Содержимое</div>
			<div data-columns="3">Содержимое</div>
			
		CSS:
		
			div[data-columns=2] { width: 480px; }
			div[data-columns=3] { width: 720px; }
				
				
				
Значение комплексного селектора по атрибуту чувствителен к регистру. Но если добавить "i" (или "I") до закрытия скобок, то это сделает
комплексный селектор не чувствительным к регистру. Например следующие селекторы одинаковы:

	element[class$=first] {color: red;}

	element[class$=FIRST i] {color: blue;}

И в результате будет применен стиль последнего, так как они имеют одинаковую специфичность, и будет применен стиль последнего упомянутого
селектора.

Подробнее в папке "Комплексные селекторы".
	
--------------------------------------------------------------------------------------------------------------------------------------------

Приоритет стилей (специфичность).

Существует порядок (приоритет) применения стилей к элементам (специфичность). При конфликте стилей селекторов, устанавливается стиль
селектора, у которого больше специфичность. Чем больше позиция специфичности, тем меньше сама специфичность. Из двух сравниваемых
специфичностей больше та, у которой числа в специфичности ближе к первым позициям (к левой стороне) (например специфичность "1,0,0,0" 
больше чем "0,0,0,1"). Если два сравниваемых специфичности имеют числа в одинаковых позициях, то специфичность будет большей у той
специфичности, у которой число больше (например специфичность "0,2,0,0" будет больше чем у "0,1,0,0"). Если два сравниваемых специфичности
имеют числа в одинаковых позициях и эти числа равны, (например специфичности "0,1,1,0" и "0,1,1,0") то будет применен стиль того
селектора, который был применен в последнюю очередь. 

Специфичность селекторов/стилей по позиции ("A,B,C,D"):

	A:

		Встроенные стили ("inline").

	B:

		Селекторы по идентификатору ("#id {}").

	C:

		Селекторы по классу (".element {}").

		Селекторы наличия атрибута (например "[attribute] {}").

		Селекторы по псевдо-классу.

	D:

		Селекторы по типу элемента (например "div {}").

		Селекторы по псевдо-элементу (например "::first-line {}").

	Не имееют эффекта (имеют специфичность "0,0,0,0"):

		Универсальный селектор "*".

		Cелектор по наследованию.

		Комбинаторы ("+", ">", "~").

		Псевдокласс ":not(<селектор>)". "<селектор>" внутри ":not" не относится к этому.
		Он имеет специфичность "0,0,1,0".

Примечания:

	1. Стили с непосредственным использованием ключевого слова "!important" (не унаследованным) будут иметь больший приоритет перед
	всеми специфичностями, и перепишет стили.

	2. Любой селектор, который будет применяться к элементу напрямую, всегда будет иметь больший приоритет перед стилем который был
	унаследован, даже если унаследованный стиль (родитель) будет иметь ключевой слово "!important".

	3. Если есть конфликт стилей универсального селектора "*" и унаследованных стилей, то будет применен стиль универсального селектора,
	так как он переписывает унаследованные стили.

	4. Псевдо-класс ":root" выбирает корневой элемент дерева. В "HTML" он является тегом "<html>". Стили которые будут применены к нему
	будут унаследованы его потомками, а значит для его потомков он не будет влиять на специфичность.

Примеры:

	1. Специфичность селекотора по типу равна "0,0,0,1". В примере "body div {}" специфичность будет равна "0,0,0,2", так как оба селектора
	по отдельности имеют специфичность "0,0,0,1", и они будут складываться. В примере "body, div {}" специфичность будет равна "0,0,0,1",
	так как оба селектора по отдельности имеют специфичность "0,0,0,1", и они будут считаться по отдельности, так как стоит запятая ",".
	
	2. "0,1,0,0" больше, чем "0,0,8,9".

Подобнее:

	http://css.yoksel.ru/specifity/

--------------------------------------------------------------------------------------------------------------------------------------------

Еденицы измерения в "CSS":

	px	-		размер в пикселях.
	
	%	-		размер в процентах.
	
	em	-		множитель размера шрифта основного, или родительского элемента. Например, если размер шрифта родительского элемента "30px",
	то значение "1em" будет вычисляться как "30px" (30 х 1) для всех дочерних элементов. Число не обязательно должно быть целым.
	Если в примере "1em" 1 заменить на "0,5", то значение будет "15px" (30 х 0,5).
	
	rem	-		то же что и "em", но ее значение всегда остается равным размеру шрифта корневого элемента.
	
	vw	-		ширина области просмотра. "1vw" равен "1/100" ширины окна просмотра. Немного похоже на проценты, за исключением того,
	что значение остается неизменным для всех элементов независимо от ширины их родительских элементов. Например, если ширина окна "1000px",
	то "1vw" будет равен "10px".
	
	vh	-		то же что и "vw", только высота области просмотра.
	
	vmin	-	"1vmin" равно "1/100" от минимального значения между высотой и шириной области просмотра. Другими словами, "1/100" стороны
	с наименьшей длиной. Например, если размеры окна "1200" на "800" пикселей, то значение "1vmin" будет равно "8px".
	
	vmax	-	то же что и "vmin", только максимальный размер стороны.
	
	ex	-		высота символа "x". Определяется как “высота символа 'x' текущего шрифта или половина '1 em'”. То есть высота строчной буквы
	"x" установленного шрифта. При изменении значения свойства "font-family" единица измерения "ex" изменяется
	
	ch	-		равна ширине символа "0". Эта единица измерения также меняется при изменении значения свойства "font-family".
	
	cm	-		сантиметры.
	
	mm	-		миллиметры.
	
	in	-		дюймы.
	
	pc	-		пики.
	
	pt	-		пункты.

Ключевые слова рамеры. Ключевые слова рамеры работают только с блочными элементами "display: block" или "display: inline-block" элемент,
это гарантирует то, что элементы будут отображены в виде прямоугольника (c шириной и высотой). Список ключевых слов размеров:

	min-content	-	в горизонтальном направлении, ключевое слово  "min-content" представляет минимальное значение ширины без горизонтального
	переполнения элемента. По вертикальному направлению, ключевое слово  "min-content" представляет минимальное значение высоты без
	вертикального переполнения элемента. 
	
	max-content	-	предпочитаемая внутренняя ширина элемента или предпочитаемая внутренняя высота элемента.
	
	fit-content	-	размер будет максимально доступным, но не больше "max-content".

Подробнее в папке "Еденицы измерения CSS".

--------------------------------------------------------------------------------------------------------------------------------------------

Свойства. Общее:

--------------------------------------------------------------------------------------------------------------------------------------------

/* Вставка комменария */

	Споособ, для вставки комментария.

width

height

	Установка ширины и высоты элементу. Принимает значения размеров: ("px" и "%").			

min-width

min-height

	Установка минимальной ширины и высоты элементу. Принимает значения размеров: ("px" и "%").

max-width

max-height

	Установка максимальной ширины и высоты элементу. Принимает значения размеров: ("px" и "%").

margin

	Устанавливает величину отступа от каждого края элемента. Отступом является пространство от границы текущего элемента до внутренней
	границы его родительского элемента. Если у элемента нет родителя, отступом будет расстояние от края элемента до края окна браузера
	с учетом того, что у самого окна по умолчанию тоже установлены отступы. Чтобы от них избавиться, следует устанавливать значение
	"margin" для селектора "<body>" равное нулю. Свойство "margin" позволяет задать величину отступа сразу для всех сторон элемента
	или определить ее только для указанных сторон. Разрешается использовать одно, два, три или четыре значения, разделяя их между
	собой пробелом. Значения измеряются в стандартных еденицах измерения "CSS". 
	
	Эффект зависит от количества значений в свойстве. Зависимость от количества значений приведено ниже. Количество:
	
		1 - отступы будут установлены одновременно от каждого края элемента.
		
		2 - первое значение устанавливает отступ от верхнего и нижнего края, второе — от левого и правого.

		3 - первое значение задает отступ от верхнего края, второе — одновременно от левого и правого края, а третье — от нижнего края.

		4 - поочередно устанавливается отступ от верхнего, правого, нижнего и левого края.
		
	Значения свойства "margin":
	
		auto - указывает, что размер отступов будет автоматически рассчитан браузером.
		
		inherit - наследовать значение от родителя.

margin-top

margin-left

margin-bottom

margin-right

	Отдлельно устанавливает величину отступа от соответствующего имени свойства стороны элемента. Значения такие же как и у
	свойства "margin".

padding

	Устанавливает величину внутреннего отступа элемента, от каждого края. Свойство "padding" позволяет задать величину внутреннего
	отступа элемента сразу для всех сторон или определить ее только для указанных сторон. Разрешается использовать одно, два, три
	или четыре значения, разделяя их между собой пробелом. Значения измеряются в стандартных еденицах измерения "CSS".
	Паддинги не могут быть отрицательными.
	
	Эффект зависит от количества значений в свойстве. Зависимость от количества значений приведено ниже. Количество:
	
		1 - отступы будут установлены одновременно от каждого края элемента.
		
		2 - первое значение устанавливает отступ от верхнего и нижнего края, второе — от левого и правого.

		3 - первое значение задает отступ от верхнего края, второе — одновременно от левого и правого края, а третье — от нижнего края.

		4 - поочередно устанавливается отступ от верхнего, правого, нижнего и левого края.
		
	Значения свойства "padding":
	
		inherit - наследовать значение от родителя.

padding-top

padding-left

padding-bottom

padding-right

	Отдлельно устанавливает величину внутреннего отступа от соответствующего имени свойства стороны элемента. Значения такие же как и
	у свойства "padding".

outline

	Универсальное свойство, одновременно устанавливающее цвет "outline-color", стиль "outline-style" и толщину "outline-width" внешней границы
	на всех четырёх сторонах элемента. В отличие от линии, задаваемой через "border", "outline" имеет отличия. "outline" не влияет на размеры и
	положение самого элемента. "outline" не занимает место, не влияет на окружающие элементы и отображается поверх них. Так же нельзя задать
	параметры линии на отдельных сторонах элемента, "outline" применяется сразу ко всем четырём сторонам.
	Свойство "border-radius" не действует для "outline".
	
	Чтобы полностью отключить внешнюю границу, значением свойства будет "none";
	
	Синтаксис:
	
		outline: <outline-color> || <outline-style> || <outline-width>

outline-color

	Указывает цвет внешней границы элемента, созданной с помощью свойства "outline". В отличие от линии, задаваемой через "border", линия через
	свойство "outline" отображается вокруг элемента, не влияя на ширину блока или его положение. Принимает стандартные значения цвета "CSS".

outline-style

	Устанавливает стиль внешней границы элемента, созданной с помощью свойства "outline". В отличие от линии, задаваемой через "border",
	линия через "outline" отображается вокруг элемента, не влияя на ширину блока или его положение. Значения:
	
		dotted	-	определяет пунктирную структуру.
		
		dashed	-	определяет пунктирную структуру.
		
		solid	-	определяет сплошной контур.
		
		double	-	определяет двойной контур.
		
		groove	-	определяет трехмерную контурную канавку.
		
		ridge	-	определение трехмерного ребристого контура.
		
		inset	-	определяет контур "3D"-вставки.
		
		outset	-	определение трехмерного контура начала.
		
		none	-	не определяет структуру.
		
		hidden	-	определяет скрытый контур.

outline-width

	Определяет толщину внешней границы элемента, созданной с помощью свойства "outline". В отличие от свойства "border-width", для
	"outline-width" нельзя задать границу для каждой стороны элемента индивидуально. Принимает стандартные значения размеров "CSS".

outline-offset

	Отдельное свойство настройки рамки, созданной с помощью свойства "outline". Устанавливает расстояние между рамкой, созданной с помощью
	свойства "outline", и краем или границей элемента добавленной через "border". Принимает стандартные значения размеров "CSS".
	
	Пример использования свойства "outline-offset":
	
		.wrap {
			background: url(images/leather.jpg); /* Фоновый рисунок */
			outline: 2px dashed rgba(255,255,255,0.8); /* Пунктирная рамка */
			outline-offset: 5px; /* Выставляем отступ от рамки и границы */
			padding: 10px; /* Поля */
			min-height: 100px; /* Минимальная высота */
		}

border

	Установка рамки элементу. Оно принимает значения: размер, стиль, и цвет. Значения могут идти в любом порядке, разделяясь
	пробелом, браузер сам определит, какое из них соответствует нужному свойству. 	Размер, стиль и цвет рамки могут быть заданы и
	с помощью отдельных свойств ("border-width", "border-height", "border-style", "border-color").
	
	Свойство "boder" имеет следующую форму:
	
		border: размер стиль цвет;
		
	Пример использования свойства "boder":
	
		border: 5px solid green;
		
	На месте первого значения будет ширина рамки. Подробнее в свойстве "border-width".
		
	На месте второго значения будет задан стиль рамки. Подробнее в свойстве "border-style".
	
	На месте третьего значения будет цвет рамки, в любом доступонм формате "CSS".
	
	На последнем месте может быть значение "inherit" - наследования значений от родителя.

border-top

border-rigt

border-bottom

border-left

	Установка рамки отдельной стороне элемента. Принимает такие же значения, как и значения свойства "border".

border-width

	Задает толщину границы одновременно на всех сторонах элемента или индивидуально для каждой стороны.
	Способ изменения толщины зависит от числа значений. Принимает стандартные значения размеров "CSS".
	
	Эффект зависит от количества значений в свойстве. Зависимость от количества значений приведено ниже. Количество:
	
		1 - толщина границы будет установлена для всех сторон элемента.

		2 - первое значение устанавливает толщину верхней и нижней границы, второе  — левой и правой.

		3 - первое значение задает толщину верхней границы, второе — одновременно левой и правой границы, а третье — нижней границы.

		4 - поочередно устанавливается толщину верхней, правой, нижней и левой границы.
		
	На последнем месте может быть значение "inherit" - наследования значений от родителя.

border-top-width

border-rigt-width

border-bottom-width

border-left-width

	Установка ширины отдельной стороне рамки элемента. Принимает такие же значения, как и значения свойства "border-width".

border-style

	Установка стиля рамке элемента.
	
	Значения совойства "border-style":
	
		none - нет рамки.
		
		dotted - точечная рамка.
		
		dashed - штриховая рамка.
		
		double - двайная рамка.
		
		groove - выкопанная рамка.
		
		ridge - огражденная рамка.
		
		inset - вопуклая рамка.
		
		outset - выпуклая рамка.
		
		hidden - невидимая рамка.

border-top-style

border-right-style

border-bottom-style

border-left-style

	Установка стиля отдельной стороне рамки элемента. Принимает такие же значения, как и значения свойства "border-style".

border-color

	Установка цвета рамке элемента. Принимает словестные значения, шестнадцатеричные значения, и значения "rgb".

border-top-color

border-rigt-color

border-bottom-color

border-left-color

	Установка цвета отдельной стороне рамки элемента. Принимает такие же значения, как и значения свойства "border-color".

border-radius

	Устанавливает радиус скругления уголков рамки. Если рамка не задана, то скругление также происходит и с фоном. Разрешается
	использовать одно, два, три или четыре значения, перечисляя их через пробел. Также допустимо писать два значения через слэш ("/").
	В качестве значений указываются числа в любом допустимом для "CSS" формате. В случае применения процентов, отсчет ведется
	относительно ширины блока.
	
	Эффект зависит от количества значений в свойстве. Зависимость от количества значений приведено ниже. Количество:
	
	1 - радиус указывается для всех четырех уголков.

	2 - первое значение задает радиус верхнего левого и нижнего правого уголка, второе значение — верхнего правого и нижнего левого
	уголка.

	3 - первое значение задает радиус для верхнего левого уголка, второе — одновременно для верхнего правого и нижнего левого,
	а третье — для нижнего правого уголка.

	4 - по очереди устанавливает радиус для верхнего левого, верхнего правого, нижнего правого и нижнего левого уголка.

border-bottom-left-radius

border-bottom-right-radius

border-top-left-radius

border-top-right-radius

	Отдлельно устанавливает величину радиуса скругления уголков соответствующего имени свойства стороны рамки элемента. Значения
	такие же как и у свойства "border-radius".

border-image-source

	С помощью этого свойство можно установить фоновое изображение в качестве рамки объекта. Значением выступает адрес на
	картинку "url(<url>)".
	
	Значения свойства "border-image-source":
	
		none - отменить действие свойства.
		
		url - ссылка (адрес) на искомый файл.
	
	Пример использования свойства "borde-image-source":
	
		border-image-source: url(image.jpg);
		
	Если задать только свойство "border-image-source" элементу, картинка заполнит собой уголки, не зная что ей делать дальше.
	Для корректрого отображения нужны следующие свойства.

border-image-slice

	После установки изображения через свойство "border-image-source", необходимо его применить к рамке при помощи свойства
	"border-image-slice". Важное свойство, которое определяет размер куска изображения, которое заполнит углы рамки.
	Остальные части будут использованы для заполнения пространства между углами по алгоритму, заданному в "border-image-repeat".
	
	Значения свойства "border-image-slice":
	
		<проценты> — рассчитываются относительно размера изображения. Горизонтальные относительно ширины, вертикальные —
		относительно высоты.
		
		<числа> — пиксели (для растрового изображения) или координаты (для векторного). Единицы измерения не указываются.
		
		fill — ключевое слово, дополняющее предыдущие значения. Если оно задано, изображение не обрезается внутренним
		краем рамки, а заполняет также область внутри рамки. Очень полезно для округлых рамок.

border-image-width

	Свойство управляет шириной видимой части рамки, масштабирует её. Если это значение больше ширины "border-width",
	картинка рамки заползет под содержимое, даже если не заданно свойство "fill".
	
	Значения свойства "border-image-width":
	
		<значение> — значения в стандартых еденицах измерения "CSS";
		
		<числа> — числовое значение, на которое умножается "border-width".
		
		auto — ключевое слово. Если оно задано, значение равно соответственному "border-image-slice". Если подходящего
		размера нет, используется значение "border-width", при этом картинка заполняет весь угол рамки, заползая под контент.

border-image-outset

	Свойство, позволяющие отодвинуть рамку за пределы элемента. Отрицательные значения не поддерживаются.
	Это свойство не влияет на размеры элемента, а рамка может перекрывать соседние элементы.
	
	Значения свойства "border-image-outset":
	
		<значение> — значения в стандартых еденицах измерения "CSS";

		<числа> — числовое значение, на которое умножается "border-width".

border-image-repeat

	Данное свойство предлагает несколько вариантов масштабирования и расположения изображения на гранях и центральной части рамки.
	
	Значения свойства "border-image-repeat":
	
		stretch - растягивает рисунок границы до размеров элемента. Это значение используется по умолчанию.

		repeat - повторяет рисунок границы.

		round - повторяет рисунок и масштабирует его так, чтобы на стороне элемента оказалось целое число изображений.
		
		space – то же самое, что repeat, но если суммарная ширина всех изображений не совпадает с шириной области, то
		между изображениями появятся пробелы.

border-image

	Универсальное свойство, для опрделения все свойств выше: "border-image-source", "border-image-slice", "border-image-width",
	"border-image-outset", "border-image-repeat".
	Используется для отображения рисованной рамки вокруг элемента. Толщина рамки задаётся свойством "border", при этом если указано
	"border: 0", то рамка не выводится. При других значениях "border" рисунок всегда имеет приоритет. Фон, если он задан через
	свойство "background", отображается под рамкой. Само изображение для создания рамки состоит из девяти областей: четырёх уголков,
	верхней, правой, нижней, левой стороны и центральной части, в которой выводится содержимое элемента.
	
	Форма синтаксиса свойства "border-image":
	
		border-image: none | [ <URL> [<число> | <проценты>]{1,4} [/ <толщина>{1,4}]? ] && [stretch | repeat | round]{0,2}
		
	Значения свойства "border-image":
	
		none - не отображает рисованную рамку, используется установленный стиль границы.

		URL - путь к графическому файлу. Обязательный параметр.

		<число> - одно, два, три или четыре значения, которые указывают размеры частей изображения в пикселах, задавая тем самым
		области деления. Сами единицы не пишутся, только число ("10", а не "10px"). Разрешается использовать одно, два, три или
		четыре значения, разделяя их между собой пробелом. Эффект зависит от количества значений в свойстве. Зависимость от
		количества значений приведено ниже. Количество:
	
			1 - устанавливает границы одинаковой толщины на каждой стороне рисунка.
		
			2 - первое значение устанавливает высоту верхней и нижней границы, второе — левой и правой.

			3 - первое значение определяет высоту верхней границы, второе — левой и правой, а третье — высоту нижней границы.

			4 - поочередно устанавливается размеры верхней, правой, нижней и левой границы.
			
		<проценты> - аналогично "<числу>", но значения задаются в процентах. Тот или другой параметр обязателен.

		<толщина> - через слэш пишется одно, два, три или четыре значения толщины границы на каждой стороне элемента.
		Является аналогом "border-width" и использует тот же синтаксис.

		stretch - растягивает рисунок границы до размеров элемента. Это значение используется по умолчанию.

		repeat - повторяет рисунок границы.

		round - повторяет рисунок и масштабирует его так, чтобы на стороне элемента оказалось целое число изображений.
		
		space – то же самое, что repeat, но если суммарная ширина всех изображений не совпадает с шириной области, то
		между изображениями появятся пробелы.	
	
	Пример использования свойства "border-image":
	
		border-image: url(image.png) 30 round round;

box-shadow

	Добавляет тень к элементу. Допускается использовать несколько теней, указывая их параметры через запятую, при наложении теней
	первая тень в списке будет выше, последняя ниже. Если для элемента задается радиус скругления через свойство "border-radius",
	то тень также получится с закругленными уголками. Добавление тени увеличивает ширину элемента, поэтому возможно появление
	горизонтальной полосы прокрутки в браузере.
	
	В списке значений на превом месте может быть значение "inset", которое задает, что тень выводится внутри элемента, или
	значение "none", которое отменяет применение тени к элементу. Первое значение было опциональным (необязательным), после него
	идут обязательные значения длины тени. Первая длина указывает значение горизонтального смещения тени (вправо от блока), а
	вторая длина указывает значение вертикального смещения (вниз от блока). Направления тени можно изменить придав их значениям
	отрицательные значения. После обязательых значений длины идут опциональные (необятельные) значения размытия и дальше значения
	растяжения тени. В значении размытия ("blur") отрицательное значение не допустимо, а в значении растяжения ("spread"),
	отрицательное значение вызовет сжатие тени. Эти два значения также принимают стандартные значения величины "CSS". После
	опциональных значений размытия и растяжения может идти опциональное значение цвета тени. Цвет тени может быть в любом доступном
	"CSS" формате, по умолчанию цвет тени черная.
	
	У свойства "box-shadow" может быть несколько групп значений (несколько теней), разделенных запятыми.
	
	Значения свойства "box-shadow":
	
		none - отменяет добавление тени.
		
		inset - тень выводится внутри элемента. Необязательный параметр.
		
		(значение сдвига по оси "x") - смещение тени по горизонтали относительно элемента. Положительное значение этого параметра
		задает сдвиг тени вправо, отрицательное — влево. Обязательный параметр.

		(значение сдвига по оси "y") - смещение тени по вертикали относительно элемента. Положительное значение задает сдвиг тени вниз,
		отрицательное — вверх. Обязательный параметр.

		(значение размытия) - задает радиус размытия тени. Чем больше это значение, тем сильнее тень сглаживается, становится шире и
		светлее. Если этот параметр не задан, по умолчанию устанавливается равным "0", тень при этом будет четкой, а не размытой.

		растяжение - положительное значение растягивает тень, отрицательное, наоборот, ее сжимает. Если этот параметр не задан, по
		умолчанию устанавливается "0", при этом тень будет того же размера, что и элемент.

		цвет - цвет тени в любом доступном "CSS" формате, по умолчанию тень черная. Необязательный параметр.
	
	Примеры использования свойства "box-shadow" со всеми (опциональными) значениями, для добавления двух теней внутри и снаружи:
	
		box-shadow: 10px 10px 5px 5px #888888, -10px -10px 5px 5px blue;
		
		box-shadow: inset 10px 10px 5px 5px #888888, inset -10px -10px 5px 5px blue;

background

	Универсальное свойство "background" позволяет установить одновременно до пяти характеристик фона. Значения могут идти в любом
	порядке, браузер сам определит, какое из них соответствует нужному свойству. В "CSS3" допустимо указывать параметры сразу 
	нескольких фонов, перечисляя их через запятую. Для подробного ознакомления смотрите информацию о каждом свойстве отдельно.
	
	Форма синтаксиса свойства "background":
	
		background: [background-attachment | background-color | background-image | background-position | background-repeat] | inherit
		
	Форма синтаксиса свойства "background" в "CSS3":
	
		background: [back <фон>, ]* <последний_фон>
		
		Где:
		
			<фон> = [background-attachment || background-image || background-position || background-repeat] | inherit

			<последний_фон> = [background-attachment || background-color || background-image || background-position || background-repeat] | inherit

			Если наряду с фоновыми изображениями требуется задать цвет фона элемента, он указывается в последнюю очередь после
			перечисления.
			
	Значения - любые комбинации пяти значений, разделяемых между собой пробелом, определяющих стиль фона, в произвольном порядке.
	Ни одно значение не является обязательным, поэтому неиспользуемые можно опустить.
	"inherit" наследует значение у родительского элемента.

background-color

	Установка фонового цвета элементу. Принимает стандартные цветовые значения.

background-image

	Установка фонового изображения элементу. По умолчанию изображение ставится в левый верхний угол, и повторяется вертикального
	и горизонтально, чтобы покрыть весь элемент.
	
	Значения свойства "background-image":
	
		url(...) - значение для указания ссылки на изображения, где "..." - сама ссылка на изображение.
		
	Пример использования свойства "background-image":
	
		background-image: url(image.jpg);
		
	После этого свойства могут быть указаны свойства "background-position" - чтобы задать позицию для фонового изображения, "background-repeat" - для
	определения способа повторения фонового изображения, и свойство "background-attachment", для определения способа прокручивания фонового изображения.
	
	Фоновых изображений можно установить множество, через запятую. Например:
	
		background-image: url(image.jpg), url(image2.jpg);
		
	Их положение на фоне можно задать с помощью свойства "background-position", задавая каждому положение по очереди, через запятую.

background-position

	Задает начальное положение фонового изображения, установленного с помощью свойства "background-image". В "CSS3" допустимо указывать несколько
	значений для каждого фона, перечисляя значения через запятую.
	
	У свойства "background-position" два значения, положение по горизонтали (может быть — "left", "center", "right") и вертикали (может быть — "top",
	"center", "bottom"). Кроме использования ключевых слов положение также можно задавать в процентах, пикселах или других единицах. Если применяются
	ключевые слова, то порядок их следования не имеет значения, при процентной записи вначале задается положение рисунка по горизонтали, а затем, через
	пробел, положение по вертикали. Отношение между используемыми ключевыми словами и процентной записью следующее:
	
		top left = left top = 0% 0% (в левом верхнем углу)

		top = top center = center top = 50% 0% (по центру вверху)

		right top = top right = 100% 0% (в правом верхнем углу)

		left = left center = center left = 0% 50% (по левому краю и по центру)

		center = center center = 50% 50% (по центру)

		right = right center = center right = 100% 50% (по правому краю и по центру)

		bottom left = left bottom = 0% 100% (в левом нижнем углу)

		bottom = bottom center = center bottom = 50% 100% (по центру внизу)

		bottom right = right bottom = 100% 100% (в правом нижнем углу)
		
	При "inherit" значение наследуется у родителя элемента.
	
	Пример использования свойства "background-position" для определения позиции для двух фоновых изображений:
	
		body {	
			background-image: url(image.jpg), url(image2.jpg);
			background-position: left top, right top;
			background-repeat: no-repeat;
		}

background-repeat

	Определение способа повторения фонового изображения.
	
	Значения свойства "background-repeat":
	
		repeat-x - повторение по горизонтали.
		
		repeat-y - повторение по вертикали.
		
		inherit - наследовать значение от родителя.
		
		no-repeat - не повторять.

background-attachment

	Определение способа прокручивания фонового изображения.
	
	Значения свойства "background-attachment":
	
		fixed - фиксироанное фоновое изображение.
		
		scroll - прокручивание фонового изображения вместе с содержимым.
		
		inherit - наследовать значение от родителя.

background-size

	Масштабирует фоновое изображение согласно заданным размерам.
	
	Форма значений свойства "background-size":
		
		background-size: [ <значение> | auto | cover | contain ]
	
	Значения свойства "background-size":
	
		"значение" - задает значение в стандартных еденицах измерения "CSS". На его месте могут быть два значения: первое - ширина,
		второе высота. Если установлено одно значение, оно задает ширину фона, второе значение принимается за "auto". Пропорции
		картинки при этом сохраняются

		auto - если задано одновременно для ширины и высоты (auto auto), размеры фона остаются исходными; если только для одной стороны
		картинки ("100px" "auto"), то размер вычисляется автоматически исходя из пропорций картинки.

		cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.

		contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь блока.

background-clip

	Определяет, как цвет фона или фоновая картинка должна выводиться под границами. Эффект заметен при прозрачных или пунктирных границах.
	
	Значения свойства "background-clip":
	
		padding-box - фон отображается внутри границ.

		border-box - фон выводится под границами.

		content-box - фон отображается только внутри контента.
	
	Форма синтаксиса свойства "background-clip":
	
		background-clip: [padding-box | border-box | content-box] [, [padding-box | border-box | content-box]]
		
	Значений может быть несколько (для каждого из множественных фоновых рисунков), при этом значения разделяются между собой запятой.
	
	Чтобы достичь эффекта прозрачности рамкам, нужно задать рамкак прозрачность через "rgba", затем задасть свойство "background-clip" со
	значением "padding-box".

opacity

	Определяет уровень прозрачности элемента веб-страницы. При частичной или полной прозрачности через элемент проступает фоновый рисунок или другие
	элементы, расположенные ниже полупрозрачного объекта. Нельзя задать прозрачность фоновому изображению тела "<body>".
	
	Значение свойства "opacity" равно числу между 0.0 и 1.0, где 0.0 - это полностью прозачный элемент, а 1.0 это полностью непрозрачный элемент.
	
	Пример использования свойства "opacity":
	
		img {
			opacity: 0.5;
		}

transform

	Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать виды трансформаций.
	
	Значения свойства "transform":
	
		none - отменяет действие трансформации.
		
		"функия" - определение функции трансформации. Список функций трансформации приведен ниже.
		
	Функции (методы) трансформации:
	
		matrix - задаёт "матрицу преобразований".

		rotate - поворот элемента на заданный угол относительно точки трансформации, задаваемой свойством "transform-origin".
		Угол поворота задается в градусах "deg". Использование отрицательных значений приведет к повороту против часовой стрелки.

			transform: rotate(<угол>)
			
		rotate3d - поворачивает элемент в трёхмерном пространстве без искажений. Вращающийся элемент имеет три степени
		свободы — оси "X", "Y" и "Z", относительно которых происходит поворот. Они задаются с помощью вектора "[x, y, z]" с учётом
		точки вращения.
		
			transform: rotate3d(x, y, z, α)
			
			Здесь: "x" — целое число описывающее координату "X" вектора оси вращения; "y" — целое число описывающее "Y"-координату
			вектора оси вращения; "z" — целое число описывающее координату "Z" вектора оси вращения; "α" — угол поворота. Положительное
			значение угла поворачивает элемент по часовой стрелке, отрицательное против.

		scale - масштаб элемента по горизонтали и вертикали. По умолчанию равен "1".

			transform: scale(sx[, sy]);

			Значение больше 1 увеличивает масштаб элемента, меньше 1 — уменьшает масштаб.

		scaleX - масштабирует элемент по горизонтали.

			transform: scaleX(sx);

		scaleY - масштабирует элемент по вертикали.

			transform: scaleY(sy);
			
		scale3d - масштабирует элемент в трёхмерном пространстве.

			transform: scale3d(sx, sy, sz)

		skew - наклоняет элемент на заданный угол по горизонтали и вертикали.

			transform: skew(Xdeg[, Ydeg])
		
		skewX - наклоняет элемент на заданный угол по вертикали.

			transform: skewX(<угол>)

		skewY - наклоняет элемент на заданный угол по горизонтали.

			transform: skewY(<угол>)

		translate - сдвигает элемент на заданное значение по горизонтали и вертикали. Сдвиг элемента похож на косвенное
		позиционирование - он не влияет на поток документа. Сдвинутый элемент оставит свое положение в потоке и
		появится только для перемещения.

			transform: translate(tx[, ty])

		translateX - сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо,
		отрицательное влево.

			transform: translateX(tx)

		translateY - сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное вверх.

			transform: translateY(ty)
			
		translate3d - сдвигает элемент на заданное значение в трёхмерном пространстве.

			transform: translate3d(tx, ty, tz)
			
	Положительные значения будут воздействовать вправо и вниз, а отрицательные соответственно наоборот.
	
	Чтобы добавить несколько функций для "transform", то они будут указываться через пробел, а не через запятую:
	
		transform: rotate(45deg) traslate(100px);

transform-origin

	Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.
	Свойство "transform-origin" должно использоваться вместе со своством "transform".
	
	Форма синтаксиса свойства "transform-origin":
	
		transform-origin: <x> <y> <z>
		
		где значениями будут значения положения по осям:
		
			<x> - координата по оси "X". Может принимать следующие значения:

				<длина> | <проценты> | left | center | right

				здесь <длина> — любая единица измерения "CSS".

			<y> - координата по оси "Y". Может принимать следующие значения:

				<длина> | <проценты> | top | center | bottom

			<z> - координата по оси "Z". Может задаваться только в любых корректных единицах для измерения
			длины (исключая проценты).

transition

	Универсальное свойство, которое позволяет задать параметры перехода (трансформации, анимации и тд.) элемента или элементов.
	Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдо-класса ":hover"
	или ":active", а также динамически через "JavaScript".
	
	Форма синтаксиса свойства "transition":
	
		transition: [ none | <transition-property> ] || <transition-duration> || <transition-timing-function> || <transition-delay>
		
	Значения свойтва "transition":
	
		none - отменить анимацию.
		
		"transition-property" - на месте которого будет "CSS"-свойство (имя), для которого будет применён эффект перехода.
		Значение по умолчанию "all".

		"transition-duration" - на месте которого будет продолжительность эффекта перехода в секундах("s") или миллисекундах("ms").
		Значение по	умолчанию "0s".

		"transition-timing-function" - на месте которого будет кривая скорости для эффекта перехода. Значение по умолчанию "ease".
		
		Значения подставляющиеся на место "transition-timing-function":
		
			ease - анимация начинается медленно, затем ускоряется и к концу движения опять замедляется.
			Аналогично "cubic-bezier(0.25,0.1,0.25,1)".

			ease-in - анимация медленно начинается, к концу ускоряется. Аналогично "cubic-bezier(0.42,0,1,1").

			ease-out - анимация начинается быстро, к концу замедляется. Аналогично "cubic-bezier(0,0,0.58,1)".

			ease-in-out - анимация начинается и заканчивается медленно. Аналогично "cubic-bezier(0.42,0,0.58,1").

			linear - одинаковая скорость от начала и до конца.

			step-start - как таковой анимации нет. Стилевые свойства сразу же принимают конечное значение.

			step-end - как таковой анимации нет. Стилевые свойства находятся в начальном значении заданное время, затем сразу
			же принимают конечное значение.

			steps - ступенчатая функция, имеющая заданное число шагов.

				transition-timing-function: steps(<число>, start | end)

				Здесь: "<число>" — целое число больше нуля; "start" — задаёт полунепрерывную снизу функцию; "end" — задаёт
				полунепрерывную сверху функцию.

			cubic-bezier - задаёт функцию движения в виде "кривой Безье". Подробности приведены в
			папке "Примеры функции CUBIC BÉZIER".

		"transition-delay" - на месте которого будет задержка по времени, когда начнётся эффект перехода.
		Значение по умолчанию "0s".

		inherit	- указывает, что значение наследуется от родительского элемента.
	
	Неуказанные значения принимаются по умолчанию.
	
	Первый пример использования свойства "transition":
	
		div:hover {
			width: 150px;
		}
		
		div {
			width: 100px;
			transition: 3s;
		}
		
	Второй пример использования свойства "transition":
	
		div:hover {
			width: 150px;
		}
		
		div {
			width: 100px;
			transition: width 5s ease 1s;
		}
		
	Свойство может изменять значения переходов нескольких свойств, перечисленных через запятую.
	
	Третий пример использования свойства "transition", с изменением переходов нескольких свойств, перечисленных через запятую:
		
		div:hover {
			width: 150px;
			height: 30xp;
		}
		
		div {
			height: 20px;
			width: 100px;
			transition: width 5s, height 3s;
		}
		
	Сами перечисленные значения могут также самостоятельно использоваться в качестве свойств к элементам Например:
	
		div {
			transition-duration: 0.2s;
		}
		
		или
		
		div {
			transition-timing-function: linear;
			}
			
		и тд.
	
	Подробные примеры приведены в папке "Примеры использования свойства transition".

transition-property

transition-duration

transition-timing-function

transition-delay

	Индивидуальные свойства для изменения переходов свойств. Подробнее в свойстве "transition".

perspective

	Определяет расстояние от плоскости экрана до точки сходимости линий и тем самым задаёт, насколько выражен эффект
	перспективы. Точка сходимости по умолчанию располагается в центре элемента и может быть изменена с помощью
	свойства "perspective-origin". При определении свойства "perspective" для элемента, перспективный вид получают
	именно дочерние элементы (в древе), а не сам элемент. Свойство "perspective" влияет только на трансформированные
	"3D" элементы (свойство "transform"). Значение по умолчанию "none".
	
	Значения свойства "perspective":
	
		none - указывает, что не применять перспективу к элементу.

		<размер> - расстояние от плоскости монитора до точки сходимости линий. Нулевое или отрицательное значение отменяет
		действие перспективы. Чем меньше значение, тем более выраженной выглядит перспектива и наоборот.
		
	Пример использования свойства "perspective":
	
		.child {
			background: #e4efc7;
			padding: 10px;
			transform: rotateY(15deg);	
		}
		.parent {
			perspective-origin: 0 50%;
			perspective: 500px;
		}

perspective-origin

	Задаёт координаты точки, куда смотрит наблюдатель. Это свойство работает совместно со свойством "perspective" и определяет
	точку сходимости линий при перспективе. Значение по умолчани: "50% 50%".
	
	Если указано только одно значение, то оно считается координатой "X", два значения определяют вначале координату "X", затем "Y",
	при этом ключевые слова могут идти в произвольном порядке. Проценты задаются относительно ширины элемента, отсчёт координат
	начинается с его левого верхнего угла. Проценты, пиксели и другие единицы "CSS" могут быть отрицательными. Ниже приведено, как
	связаны между собой процентная запись и ключевые слова:
	
		left = left center = 0 50% — центр левого края.

		center = center center = 50% 50% — центральная точка.

		right = right center = 100% 50% — центр правого края.

		top = center top = 50% 0 — центр верхнего края.

		bottom = center bottom 50% 100% — центр нижнего края

		left top = 0 0 — левый верхний угол.

		left bottom = 0 100% — левый нижний угол.

		right top = 100% 0 — правый верхний угол.

		right bottom = 100% 100% — правый нижний угол.
		
	Пример использования свойства "perspective-origin":
	
		div {
			perspective: 1000px;
			perspective-origin: center bottom;
		}

animation-name

	Устанавливает одну или несколько анимаций, которые применяются к элементу. Представляет собой имя, заданное правилом
	"@keyframes".

animation-duration

	Задаёт время в секундах или миллисекундах, сколько должен длиться один цикл анимации. По умолчанию значение равно "0s",
	это означает, что никакой анимации нет. Можно указать несколько значений, перечисляя их через запятую.
	Отрицательные значения и значения без указания единиц времени ("s" или "ms") недопустимы и будут игнорироваться.
	Если свойство "animation-duration" не было определено, то анимация не будет воспроизведена, потому что значением
	ллительности по умолчанию является "0".
	
	Форма синтаксиса свойства "animation-duration":
	
		animation-duration: <время> [,<время>]

animation-timing-function

	Устанавливает, согласно какой функции времени должна происходить анимация каждого цикла между ключевыми кадрами. Она
	представляет собой математическую функцию, показывающую, как быстро по времени меняется значение свойства. Начальная
	точка имеет координаты "0.0, 0.0", конечная — "1.0, 1.0", при этом функция по оси ординат может превышать эти
	значения в большую или меньшую сторону. Значение по умолчанию: "ease".
	
	Свойство "animation-timing-function" принимеет следующие значения:
	
		ease - анимация начинается медленно, затем ускоряется и к концу движения опять замедляется.
		Аналогично "cubic-bezier(0.25,0.1,0.25,1)".

		ease-in - анимация медленно начинается, к концу ускоряется. Аналогично "cubic-bezier(0.42,0,1,1)".

		ease-out - анимация начинается быстро, к концу замедляется. Аналогично "cubic-bezier(0,0,0.58,1)".

		ease-in-out - анимация начинается и заканчивается медленно. Аналогично "cubic-bezier(0.42,0,0.58,1").

		linear - одинаковая скорость от начала и до конца.

		step-start - как таковой анимации нет. Стилевые свойства сразу же принимают конечное значение.

		step-end - как таковой анимации нет. Стилевые свойства находятся в начальном значении заданное время, затем сразу
		же принимают конечное значение.

		steps - ступенчатая функция, имеющая заданное число шагов.

			animation-timing-function: steps(<число>, start | end)

			Здесь: "<число>" — целое число больше нуля; "start" — задаёт полунепрерывную снизу функцию; "end" — задаёт
			полунепрерывную сверху функцию.

		cubic-bezier - задаёт функцию движения в виде "кривой Безье". Подробности приведены в
		папке "Примеры функции CUBIC BÉZIER".

animation-iteration-count

	Свойство определяет, сколько раз проигрывать цикл анимации до её остановки. Значение по умолчанию: "1".
	
	Значения свойтва "animation-iteration-count":
	
		infinite - анимация повторяется бесконечно.
		
		<число> - сколько раз должна повторяться анимация. Отрицательные значения не допустимы. Можно использовать
		числа меньше единицы, для примера "0.5" будет означать половину цикла анимации.

animation-direction


	Устанавливает направление движения анимации. Значение по умолчанию "normal".
	
	Значения свойства "animation-direction":
	
		normal - анимация идёт с самого начала, после завершения цикла возвращается к исходному состоянию.

		alternate - анимация идёт с начала до конца, затем плавно возвращается в исходное положение.

		reverse - анимация идёт с конца цикла, после его завершения возвращается к исходному состоянию.

		alternate-reverse - анимация идёт с конца до начала, затем плавно возвращается в исходное положение.

animation-play-state

	Свойство определяет, проигрывать анимацию или поставить её на паузу. При продолжении установленной на паузе
	анимации она начинается с того момента где была остановлена. Значение по умолчанию: "running".
	
	Значения свойства "animation-play-state":
	
		running - проигрывать анимацию.

		paused - поставить анимацию на паузу.

animation-delay

	Устанавливает время ожидания перед запуском цикла анимации. Значение "0s" или "0ms" запускает анимацию сразу же.
	Отрицательное значение также включает анимацию без задержек, но может привести к изменению вида начала анимации.
	Допустимо указывать несколько значений, перечисляя их через запятую. Значение по умолчанию "0s".
	
	Форма синтаксиса свойства "animation-delay":
	
		animation-delay: <время> [,<время>]

animation-fill-mode

	Определяет, какие стили должны применяться к элементу, когда анимация не проигрывается. Например, после её
	завершения или при остановке. По умолчанию, в момент окончания анимации стиль элемента возвращается к исходному,
	свойство "animation-fill-mode" позволяет изменить это поведение и сделать так, чтобы стиль элемента оставался как
	у последнего ключевого кадра. К примеру, если вы делаете выезжающее из-за края окна браузера сообщение, то после
	окончания анимации сообщение вернётся обратно за край экрана. Значение "forwards" свойства "animation-fill-mode"
	изменяет это поведение и оставляет стили на момент завершения движения. Таким образом, сообщение плавно выдвинется
	из-за края окна и останется на месте. Значение по умолчанию	"none".
	
	Значения свойства "animation-fill-mode":
	
		none - к элементу не применяются какие-либо стили.

		forwards - к элементу по окончанию анимации применяется стиль последнего ключевого кадра. Каким будет этот кадр
		в последовательности анимации зависит от комбинации значений свойств "animation-direction" и
		"animation-iteration-count".
		
		backwards - к элементу применяется стиль первого ключевого кадра и он остаётся на протяжении периода заданного
		"animation-delay". Первый ключевой кадр определяется на основании значения "animation-direction".
		
		both - к элементу применяются оба правила, как для "forwards", так и для "backwards".
		
	Пример использования свойства "animation-fill-mode":
	
		HTML:
		
			<body>
				<img src="image/wheel.png" alt="" class="wheel">
			</body>
			
		CSS:
		
			.wheel {				
				animation: wheel 3s 1s;	
				animation-fill-mode: both;	
			}
			@keyframes wheel {
				from { transform: translateX(0) rotate(0);}				
				to { transform: translateX(450px) rotate(2turn); }
			}
			@-webkit-keyframes wheel {
				from { transform: translateX(0) rotate(0);}				
				to { transform: translateX(450px) rotate(2turn); }
			}
			
		В данном примере показано изображение ожидает одну секунду, затем начинает вращаться и двигаться вправо. По окончанию
		анимации колесо остаётся в крайнем правом положении.

animation

	Универсальное свойство, которое задаёт сразу несколько параметров анимации. Включает в себя значения свойств: "animation-name",
	"animation-duration", "animation-timing-function", "animation-iteration-count", "animation-direction","animation-play-state",
	"animation-delay", "animation-fill-mode".
	
	Форма синтаксиса свойства "animation":
	
		animation: [none | animation-name] || animation-duration || animation-timing-function || animation-delay || animation-iteration-count || animation-direction || animation-fill-mode || animation-play-state

content

	Свойство "content" позволяет вставлять генерируемое содержание в текст веб-страницы, которое первоначально в тексте отсутствует.
	Применяется совместно с псевдо-элементами "::after" и "::before", они соответственно указывают отображать новое содержимое после
	или до элемента, к которому добавляются.
	
	Значения свойства "content":
	
		"Строка" - текст, который добавляется на веб-страницу, строка при этом должна браться в двойные или одинарные кавычки.
		Допускается использовать юникод для вставки спецсимволов. Спецсимволы "HTML" которые начинаются с амперсанда ("&sect;"),
		будут отображаться как есть, т.е. простым текстом ("&sect;", а не "§").

		"attr(параметр)" - возвращает строку, которая является значением параметра тега указанного в скобках. Например,
		"a:after {content:attr(href);}" - добавит после ссылки её адрес, т.е. значение атрибута "href". Если указанного атрибута нет,
		вернется пустая строка.

		open-quote - вставляет открывающую кавычку, тип которой устанавливается с помощью стилевого свойства "quotes".

		close-quote - вставляет закрывающую кавычку.

		no-open-quotes - отменяет добавление открывающей кавычки.

		no-close-quote - отменяет добавление закрывающей кавычки.

		url - абсолютный или относительный адрес вставляемого объекта. Если указанный файл браузер не может отобразить, то значение
		игнорируется.

		counter - выводит значение счетчика, заданного свойством "counter-reset".

		none - не добавляет никакое содержание.

		normal - задается как none для псевдо-элементов "::before" и "::after".

		inherit - наследует значение родителя.

counter-reset

	Устанавливает один или несколько переменных, в которых будут храниться счётчики отображений определенного элемента,
	а также начальнын значения счётчиков. Такой счётчик может выводиться с помощью свойства "content" и псевдоэлементов
	"::after" и "::before".
	
	Значения свойства "counter-reset":
	
		none	-	запрещает инициацию счётчика для текущего селектора.

		<переменная> <число (опционально)>	-	задаёт одну или несколько переменных, в которых будут храниться значения
		счётчиков. Значения разделяются между собой пробелом. "<число (опционально)>" - начальное значение каждого идентификатора.
		По умолчанию равно "0". 
		
		inherit	-	наследует значение родителя.
	
	Пример использования свойства "counter-reset":
	
		.element {
			counter-reset: my-counter;	/* объявить переменную "my-counter" и присвоить ему "0" */
		}

		.element {
			counter-reset: my-counter -1;	/* объявить переменную "my-counter" и присвоить ему "-1" */
		}

		.element {
			counter-reset: counter1 1 counter2 4;	/* объявить переменные "counter1" и "counter2" и присвоить им "1" и "4" */
		}
		
		.element::after {
			content: counter1 "." counter2;	/* вставить значения счетчиков "counter1" и "counter2", разделив их точкой ".".
		}

		.element {
			counter-reset: none;	/* запрещает инициацию счётчика для текущего селектора */
		}
	
counter-increment

	Инкрементирует значения счетчиков по заданному числу, заданных через свойство "counter-reset".
	
	Значения свойства "counter-increment":
	
		none	-	запрещает увеличение счётчика для текущего селектора.

		<переменная> <число (опционально)>	-	инкрементирует одну или несколько переменных, в которых будут храниться значения
		счётчиков. Значения разделяются между собой пробелом. "<число (опционально)>" - определяет значение приращения счетчика.
		По умолчанию равно "1". Допускается использовать отрицательные и нулевые значения.
		
		inherit	-	наследует значение родителя.
	
	Пример использования свойства "counter-increment":
		
		.element {
			counter-increment: my-counter;	/* инкрементировать переменную "my-counter" на "1" */
		}

		.element {
			counter-increment: my-counter -1;	/* декрементировать переменную "my-counter" на "-1" */
		}

		.element {
			counter-increment: counter1 counter2 -4;	/* инкрементировать переменную "counter1" на "1", и декрементировать переменную "counter2" на "-4" */
		}

		.element {
			counter-increment: none;	/* запрещает инкрементацию счётчика для текущего селектора */
		}

cursor

	Свойство, для установки стиля (иконки) для курсора.
	
	Значения свойства "cursor:":
	
		<url>	-	позволяет установить свой собственный курсор, для этого нужно указать путь к файлу с курсором.
	
		default	-	установить иконку курсора по умолчанию, при наведении на элемент.
		
		help	-	установить вопросительную иконку курсора, при наведении на элемент.
		
		crosshair	-	установить иконку курсора в виде перекрестия, при наведении на элемент.
		
		pointer	-	установить иконку курсора в виде руки, при наведении на элемент.
		
	Остальные значения можно найти в справочных данных.
	
	Пример встроенного использования свойства "cursor:help" в "HTML" документ:
	
		<span style="cursor:help;">Do you need help?
		</span>

user-select

	Управляет поведением выделения текста и других элементов на странице, в частности, позволяет запретить выделение текста.
	Обычно применяется для интерактивных элементов, на которые можно щёлкать, например, вкладки,
	и для которых выделение текста нежелательно.
	
	Значения свойства "user-select":
	
		auto - Для редактируемых элементов значение принимается "contain". Если у родителя значение "user-select" установлено
		как "all", то для элемента оно тоже будет "all". Если у родителя значение "user-select" установлено как "none",
		то для элемента оно тоже будет "none". Во всех остальных случаях принимается значение "text".
		
		none - Пользователю запрещено выделять элемент.
		
		text - Пользователь может выделить текст в элементе.
		
		all - Позволяет выделить текст внутри элемента, включая дочерние элементы.
		
		contain - Позволяет выделять текст, но только внутри границ элемента.
		
	Примечание:
	
		Internet Explorer и Edge поддерживают свойство "-ms-user-select".

		Chrome до версии 54, Opera до версии 41, Safari и Android поддерживают свойство "-webkit-user-select".

		Firefox поддерживает свойство "-moz-user-select".

		Значение "contain" поддерживается только в IE.

pointer-events

		Свойство "pointer-events" позволяет управлять тем, как элементы будут реагировать на события мыши или прикосновения к сенсорному
		экрану. Часто применяется для того, чтобы в сложной компоновке можно было взаимодействовать с нижележащими элементами, игнорируя
		вышележащие.

		К примеру данное свойство может быть применено к элементу, который например перекрывает текст, и не позволяет его выделить.
		Тогда этому элементу (который перекрывает) добавляется свойство "pointer-events" со значением "none", чтобы он не реагировал
		на клики мыши, или прикосновения сенсора.

		Значения свойства "pointer-events":

			auto	-	элемент ведёт себя так же, как и если бы свойство "pointer-events" не было задано. В "SVG" это значение даёт
			такой же эффект, как и значение "visiblePainted".
			
			none	-	элемент не может быть целью ("target") cобытий мыши, тем не менее, целью событий мыши могут быть его потомки,
			если их "pointer-events" имеет какое-либо другое значение. В этом случае события мыши вызовут ожидаемое срабатывание
			обработчиков на этом родительском элементе на пути к/от потомк(у)/(а) во время фазы захвата/всплытия.
			
			visiblePainted	-	только "SVG". Элемент может быть целью события мыши только когда свойство "visibility" установлено в
			значение "visible" и когда курсор мыши находится над внутренней частью ('fill') элемента, при этом свойство "fill" установлено
			в значение отличное от none, или над периметром элемента ('stroke'), при этом свойство "stroke" установлено в значение отличное
			от "none".
			
			visibleFill	-	только "SVG". Элемент может быть целью события мыши только когда свойство "visibility" установлено в значение
			"visible" и когда курсор мыши находится над внутренней частью ('fill') элемента. Значение свойства "fill" не влияет на обработку
			события.
			
			visibleStroke 	-	только "SVG". Элемент может быть целью события мыши только когда свойство "visibility" установлено в
			значение "visible" и когда курсор мыши находится над периметром элемента ('stroke'). Значение свойства "stroke" не влияет
			на обработку события.
			
			visible 	-	только "SVG". Элемент может быть целью события мыши только когда свойство "visibility" установлено в значение
			"visible" и когда курсор мыши находится над внутренней частью ('fill') или над периметром ('stroke') элемента.
			Значение свойств "fill" и stroke не влияют на обработку события.
			
			painted 	-	только "SVG". Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью
			('fill') элемента, при этом свойство "fill" установлено в значение отличное от "none", или над периметром элемента ('stroke'),
			при этом свойство "stroke" установлено в значение отличное от none. Значение свойства "visibility" не влияет на обработку
			события.
			
			fill 	-	только "SVG". Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью
			('fill') элемента. Значение свойств "visibility" и "fill" не влияют на обработку события.
			
			stroke 	-	только "SVG". Элемент может быть целью события мыши только когда курсор мыши находится над периметром элемента
			('stroke'). Значение свойств "visibility" и "stroke" не влияют на обработку события.
			
			all 	-	только "SVG". Элемент может быть целью события мыши только когда курсор мыши находится над внутренней частью
			('fill') или над периметром ('stroke') элемента. Значение свойств "visibility", "fill" и stroke не влияют на обработку события.

will-change

	Предоставляет автору возможность уведомить браузер об ожидаемом изменении элемента,
	таким образом браузер может настроить соответсвующую оптимизацию до того как элемент
	действительно изменится. Такой тип оптимизации может повысить отзывчивость страницы,
	совершая, возможно дорогие операции до того как они действительно понадобятся.
	
	Значения свойтсва "will-change":
	
		auto - Это ключевое слово не выражает конкретной цели. Пользовательский агент
		должен применяться независимо эвристики и оптимизации как он это обычно делает.
		
		<Animateable-feature> может иметь одно из следующих значений:
		
			scroll-position - указывает, что автор ожидает анимацию или изменение
			положения скролла элемента в ближайшем будущем.
			
			contents - указывает, что автор ожидает анимацию или изменение чего
			то в контенте элемента в ближайшем будущем.
			
			<custom-ident> - указывает, что автор ожидает анимацию или измение
			свойства с заданным именем в элементе в ближайшем будущем .
			Если заданное свойство-это сокращенная запись,  тогда оно указывает на
			все полные записи свойств, на которые указывает сокращенная запись.
			Это не может быть одним из следующих значений: "unset", "initial",
			"inherit", "will-change", "auto", "scroll-position", или "contents". 
			
	Пример использования свойства "will-change":
	
		.elements {
			will-change: transform;
		}
	
	Примечание. Данное свойство экспериментальное, и может не работать на всех браузерах.
	Правильно использование этого свойства может быть немного сложнее:
	
		Не применяйте "will-change" к большому числу элементов. Браузер и так пытается
		изо всех сил всё оптимизировать. Некоторые тяжелые оптимизации ссылающиеся на
		"will-change" используют много аппаратных мощностей, и если злоупотреблять этим,
		это может привести к замедлению работы страницы и потреблению большого
		количества ресурсов.
		
		Используйте умеренно. Обычное поведение для оптимизаций которые выполняет браузер,
		удалить оптимизацию как можно скорее и вернуть нормальное состояние.
		Но добавление "will-change" прямо в файле стилей предполагает, что указанный
		элемент всегда находится в нескольких шагах от изменений и браузер будет
		сохранять для него оптимизацию гораздо больше времени.
		Так что, было бы хорошо включать и отключать "will-change" используя скрипт
		до и после того как произошли изменения.
		
		Не применяйте "will-change" к элементам для выполнения преждевременной оптимизации.
		Если ваша страница хорошо отрабатывается, не применяйте "will-change" свойство к
		элементу только чтобы выжать немного больше скорости. "will-change" предназначен
		для использования в крайнем случае, для того чтобы исправить существующие
		проблемы оптимизации. Его не следует использовать для предвидения
		проблем оптимизации. Черезмерное использование "will-change" приведет к
		излишнему потреблению памяти и вызовет более тяжелый рендеринг так как браузер
		будет пытаться подготовиться к возможным изменениям.
		Это приведет к ухудшению производительности.
		
		Дайте ему достаточно времени, чтобы работать. Это свойство дает автору способ
		указать пользовательскому агенту свойства, которые могут измениться в будущем.
		Затем браузер может применить любые предварительные оптимизации,
		необходимые для изменения свойств до того, когда эти свойства изменятся.
		Поэтому важно дать браузеру некоторое время, чтобы провести оптимизацию.
		Найдите способ предсказать изменение хотя бы немного заранее, что-то изменится,
		и затем установите изменение.

--------------------------------------------------------------------------------------------------------------------------------------------

Позиционирование и разметка:

--------------------------------------------------------------------------------------------------------------------------------------------

display

	Определение поведения блоков.
	
	Значения свойства "display":
	
		block	Элемент показывается как блочный. Применение этого значения для встроенных элементов, например тега <span>,
		заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого.											

		inline - элемент отображается как встроенный. Использование блочных тегов, таких как "<div>" и "<p>", автоматически создает
		перенос и показывает содержимое этих тегов с новой строки. Значение "inline" отменяет эту особенность, поэтому содержимое
		блочных элементов начинается с того места, где окончился предыдущий элемент.											

		inline-block - это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно
		встроенному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде тега "<img>").
		При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как встроенный.											

		inline-table - определяет, что элемент является таблицей как при использовании тега "<table>", но при этом таблица является
		встроенным элементом и происходит ее обтекание другими элементами, например, текстом.											

		list-item - элемент выводится как блочный и добавляется маркер списка.											

		none - временно удаляет элемент из документа. Занимаемое им место не резервируется и веб-страница формируется так,
		словно элемента и не было. Изменить значение и сделать вновь видимым элемент можно с помощью скриптов, обращаясь к свойствам
		через объектную модель. В этом случае происходит переформатирование данных на странице с учетом вновь добавленного элемента.
		В отличие от свойства-значения "visibility: hidden;", она полностью убирает элемент с экрана, не оставляя его места, тогда
		как свойство-значение "visibility: hidden;" убирает элемент, оставляя его место.

		run-in - устанавливает элемент как блочный или встроенный в зависимости от контекста.											

		table - определяет, что элемент является блочной таблицей подобно использованию тега "<table>".											

		table-caption - задает заголовок таблицы подобно применению тега "<caption>".	 	 	 	 	 	 	 	 	 	 	 

		table-cell - указывает, что элемент представляет собой ячейку таблицы (тег "<td>" или "<th>").	 	 	 	 	 	 	 	 	 	 	 

		table-column - назначает элемент колонкой таблицы, словно был добавлен тег "<col>".	 	 	 	 	 	 	 	 	 	 	 

		table-column-group - определяет, что элемент является группой одной или более колонок таблицы, как при использовании
		тега "<colgroup>".	 	 	 	 	 	 	 	 	 	 	 

		table-footer-group - используется для хранения одной или нескольких строк ячеек, которые отображаются в самом низу таблицы.
		По своему действию сходно с работой тега "<tfoot>".	 	 	 	 	 	 	 	 	 	 	 

		table-header-group - элемент предназначен для хранения одной или нескольких строк ячеек, которые представлены вверху таблицы.
		По своему действию сходно с работой тега "<thead>".	 	 	 	 	 	 	 	 	 	 	 

		table-row - элемент отображается как строка таблицы (тег "<tr>").	 	 	 	 	 	 	 	 	 	 	 

		table-row-group - создает структурный блок, состоящий из нескольких строк таблицы аналогично действию тега "<tbody>".
		
		flex - преобразует элемент в блочный "flex-контейнер". Все дочерние элементы данного контейнера автоматически становятся
		"flex-элементами". Подробнее в папке "Flex-Box".
		
		grid - представляет собой пересекающийся набор горизонтальных и вертикальных линий - один набор определяет столбцы, а другой строки.
		Элементы могут быть помещены в сетку, соответственно строкам и столбцам. Подробнее в папке "CSS Grid".
		
		inherit - наследовать значение родителя.

visibility

	Определяет, будет ли отображаться элемент на странице или нет. Схож со свойством "display", но отличается тем, что только
	скрывает (или показывает) объект, я не убирает его полностью вместе с его местом.
	
	Значение совойства "visibility":
	
		hidden - скрыть.
		
		visible - показать (по умолчанию).

position

	Определение позиционирования элемента.
	
	Значения свойства "position":
	
		static - выводит элемент в потоке как обычно (по умолчанию).
		
		fixed - выводит элемент фиксированным относительно окна браузера, и не будет двигаться даже при прокрутке окна браузера.
		Сама позиция может быть определена свойствами "top", "bottom", "left", "right". Элементы с фиксированной позицией выводятся
		из нормального потока данных, и могут перекрывать другие элементы. Документ и другие эелементы ведут себя так, будто элемент
		с фиксированной позицией не существует.
		
		relative - задать элементу позицию, относительно своего исходного места. Сама позиция может быть определена свойствами "top",
		"bottom", "left", "right". Содержимое относительно позиционироанных элементов могут перекрывать другие элементы, но
		зарезервированное место для элемента сохраняется в нормальном потоке. Это значение не может быть использовано для ячкеек таблиц,
		колонок, групп колонок, строк, групп строк или заголовков.
		
		absolute - указывает, что элемент абсолютно позиционирован, при этом другие элементы отображаются на веб-странице словно
		абсолютно позиционированного элемента и нет. Положение элемента задается свойствами "left", "top", "right" и "bottom",
		также на положение влияет значение свойства "position" родительского элемента. Так, если у родителя значение "position"
		установлено как "static" или родителя нет, то отсчет координат ведется от края окна браузера. Если у родителя значение
		"position" задано как "fixed", "relative" или "absolute", то отсчет координат ведется от края родительского элемента.
		Абсолютно позиционированные элементы могуть перекрывать другие элементы.

top

bottom

right

left

	Свойства, значения которых задают положение фиксированного элемента, или элемента с относительной или абслоютной позицией.
	Эти свойства игнорируются в нормальном позиционировании ("position: static;"). Значения принимаются стандартные.

z-index

	Когда элементы расположены вне нормального потока (значение "position" не равно "static"), они могут накладываться на другие
	элементы. Свойство "z-index" указывает в каком порядке они должны будут расположены (впереди или сзади по отношению к другим
	элементам). Данное свойство работает только с позиционированными элемментами (когда "position" равно "fixed" или "relative" или
	"absolute"). Элемент, значение свойству "z-index" которого присвоено высшее значение, будет выведен на первый слой (будет вверху).
	Значения принимаются численные (1, 2, 3 и тд.).

float

	Определение обтекания элементов другими элементами.
	
	Значения свойства "float":
	
		none - не обтекать элемент.
		
		left  - выровнить элемент горизонтально справа, чтобы остальные элементы обтекали его слева.
		
		right - выровнить элемент горизонтально слева, чтобы остальные элементы обтекали его справа.

clear

	Определение остановки действия свойства "float". Свойство "clear" устанавливает, с какой стороны элемента запрещено его
	обтекание другими элементами.
	
	Значения свойства "clear":
	
		none - оставить обтекание.
		
		right - отменить обтекание справа.
		
		left - отменить обтекание слева.
		
		both - отменить обтекание с обеих сторон.

overflow

	Определение поведения для элемента, которое возникает, когда содержимое элемента выходит за область элемента блока.
	
	Значения свойства "overflow":
	
		visible - показывать непомещающийся контент (по умолчанию).
		
		hidden - скрывать непомещающийся контент.
		
		scroll - в случает нехватки места, установить полосу прокрутки справа в блоке.
		
		auto - полосы прокрутки добавляются только при необходимости (если поток будет переполнен).

overflow-x
overflow-y

	Определение поведения для элемента, которое возникает, когда содержимое элемента выходит за область элемента блока
	только для конкретных осей ("X" и "Y"). Значения свойств те же что и у свойства "overflow".

overscroll-behavior

	Определение поведения прокрутки внутри элемента и его эффектов. Если страница является прокручеваемой, и на странице есть
	встроенный элемент, который так же содержит прокрутку, то если мы будем прокручивать этот встроенный элемент,
	и дойдем до конца, то начнется прокрутка соседнего (ниже лежащего) элемента (например сама страница).
	Так же при прокрутке элемента (на мобильных телефонах), если будет достингнута граница зоны прокрутки,
	то будет эффект "bouncing" (отскок), а при попытке прокрутки страницы вверх, когда была достигнута верхняя граница зоны
	прокрутки, то будет эффект "refreshing" (обновление страницы).
	Данное свойство предназначено для управления поведением прокрутки элемента и его эффектов.
	
	Значения свойства "overscroll-behavior":
	
		auto - значение по умолчанию.
		
		contain - при прокручивании, дойдя до края зоны прокрутки элемента, соседний (ниже лежащий) элемент не будет прокручиваться.
		При данном значении сохраняются эффекты "bouncing" (отскок) и "refreshing" (обновление страницы).
		
		none - действует так же как и свойство "contain", за исключением того что данное свойство отменяет эффекты "bouncing" и
		"refreshing".

overscroll-behavior-x
overscroll-behavior-y

	Определение поведения прокрутки внутри элемента и его эффектов для конкретных осей ("X" и "Y").
	Значения свойств те же что и у свойства "overscroll-behavior".

resize

	Указывает, можно ли пользователю изменять размеры текстового поля.
	
	Значения свойства "resize":
	
		none	-	размеры элемента не изменяются.
		
		both	-	можно изменять размеры элемента по горизонтали и вертикали.
		
		horizontal	-	можно изменять размеры элемента только по горизонтали.
		
		vertical	-	можно изменять размеры элемента только по вертикали.
		
		inherit	-	маследует значение родителя.

--------------------------------------------------------------------------------------------------------------------------------------------

Работа с текстом:

--------------------------------------------------------------------------------------------------------------------------------------------			

font-family

	Установка шрифта элементу. После двоеточия указывается шрифт или несколько шрифтов, на случай если браузер не поддерживает
	один, чтобы использовать следующий. Шрифты указываются через запятую. Если в имени шрифта имеется несколько слов (например
	"Times New Roman"), то имя берется в кавычки.

font-size

	Установка размера шрифта элементу. Допускаются словесные, пиксельные, и "em" (относительное значение) значения. По умолчанию
	размер шрифта в браузерах равен "16". Относительный размер "em" высчитывается по следующей формуле: "em=pixels/16".
	
	Текстовые значения свойства "font-size":
	
		small - маленький.
		
		medium - средний.
		
		large - большой.
		
		x-large - больше.

font-style

	Обычно применяется для установки курсивного начертания к тексту.
	
	Значения свойства "font-size":
	
		normal - обычный.
		
		italic - курсив. Делает то же самое что и тег "<i>" в "<HTML>".
		
		oblique - то же что и курсив, является менее поддерживаемым.

font-weight

	Установка толщины для шрифта. Допускаются текстовые и численные значения (от 100 до 900). По умолчанию толщина шрифта в
	браузерах равна "400".
	
	Текстовые значения свойства "font-weight":
	
		normal - обычный.
		
		lighter - тоньше.
		
		bold - жирный. Делает то же самое что и тег "<strong>" в "HTML".
		
		bolder - жирнее.

font-variant

	Позволяет конвертировать регистр шрифта.
	
	Значения свойства "font-variant":
	
		normal - обычный.
		
		small-caps - преобразовать шрифт текста в маленькие заглавные буквы (не все шрифты поддреживают данное значение).
		
		inherit - унаследовать значение родителя.

font-stretch

	Позволяет выбрать нормальное, сжатое или расширенное начертание символа из семейства шрифтов. Свойство не работает на любом шрифте,
	а только на шрифтах, для которых разработаны различными начертания, соответствующими определенным размерам.
	
	Значения свойства "font-stretch":
	
		ultra-condensed	-	указывает на наиболее сжатый шрифт.
		
		extra-condensed	-	указывает на второй по сжатости шрифт.
		
		condensed	-	указывает на сжатый шрифт.
		
		semi-condensed	-	указывает на немного сжатый шрифт.
		
		normal	-	значение по умолчанию.
		
		semi-expanded	-	слегка расширенный шрифт.
		
		expanded	-	расширенный шрифт.
		
		extra-expanded	-	второй по расширенности шрифт.
		
		ultra-expanded	-	максимально расширенный шрифт.
		
		initial	Устанавливает	-	значение свойства в значение по умолчанию.
		
		inherit	-	наследует значение свойства от родительского элемента.

font

	Установка сразу всех свойств "font-style", "font-family", "font-size", "font-variant", "font-weight", "font-stretch",
	"line-height". В качестве обязательных значений свойства "font" указывается размер шрифта "font-size" и его семейство
	"font-family". Порядок:
	
		font: [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> | inherit

		Символ "/" обязателен при добавлении "line-height", и озаначет что "line-height" будет равен "font-size",
		умноженное на число, следующее за ним. Пример:
		
			div {
				font: 30px/3 Arial;	/*	"line-height" = "90px" */
			}

text-transform

	Определяет регистр текста. С его помощью например можно сделать каждое слово в тексте с заглавной буквы.
	
	Значения свойства "text-transform":
	
		capitalize - преобразовать каждое слово в тексте с заглавной буквы.
		
		uppercase - преобразовать буквы всех слов в верхний регистр.
		
		lowercase - преобразовать буквы всех слов в нижний регистр.

color

	Установка цвета элементу. Допускаются значения: словестные (название цвета), шестнадцатеричного формата и формата "RGB".
	
	Пример использования свойства "color":
	
		P {
			color: red;
		}
		
		p {
			color: #0000FF;
		}
		
		p {
			color: rgb(255, 0, 0);
		}

text-align

	Установка горизонтального расположения текста в элементе.
	
	Значения свойства "text-align":
	
		left - выравнивание по правому краю.
		
		center - выравнивание по центру.
		
		right - выравнивание по правому краю.
		
		justify - растягивание текста.

vertical-align

	Установка вертикального положения элемента.
	
	Значения свойства "vertical-align":
	
		top - расположение вверху.
		
		middle - расположение по центру.
		
		bottom - расположение внизу.
		
		baseline - по базовой линии.
		
		sub - надстрочный текст.
		
		super - подстрочный текст.
		
		(px, pt, cm, %) - указание расположения в заданных значениях.
		
	Свойство расположения по вертикали не действует одинаково на все элементы. Например, дополнительные стилизация "CSS"
	необходима для элемента "<div>":
	
		HTML:
		
			<div class="main">
				<div class="paragraph">
				Текст параграфа
				</div>
			</div>
			
		CSS:
		
			.main {
				height: 150px;
				width: 400px;
				background-color: Blue;
				display: inline-table;
			}
			
			.paragraph {
				display: table-cell;
				vertical-align: middle;
			}
			
	Правила "display:inline-table"; и "display:table-cell;" применяется для работы совойства "vertical-align" с "<div>".

text-decoration

	Установка декорации для текста (надчеркнутый, зачеркнутый, подчеркнутый). Можно применить несколько значений на один
	текст.
	
	Значения свойства "text-decoration":
	
		none - никакой.
		
		inherit - наследовать свойство от родителя.
		
		overline - надчеркнутый текст.
		
		underline - подчеркнутый текст.
		
		line-through - зачеркнутый текст.
		
		blink - моргание (не рекомендуется использовать).

text-indent

	Установка отступов для текста.
	
	Значения свойства "text-indent".
	
		inherit - наследовать свойство родителя.
		
		(px, pt, cm, em, %).

text-shadow

	Установка тени для текста. Оно принимает пять значений: первое опциональное (необязательное) значение "none" - вовсе убирает тень
	с текста, второе значениие определяет длину тени по оси "x" (обязательное значение), третье значение определяет длину по оси "y"
	(обязательное значение), четвертое значение определяет степень размытия тени (опциональное значение), и пятое значение определяет
	цвет тени (опциональное значение). Для значений осей "x" и "y" могут применяться различные единицы измерений
	("px", "cm", "in", "pc", "pt" и тд.). Можно добавить несколько теней к объекту через запятую. Тени ложатся в порядке их появления
	(последняя тень будет сверху). Свойство "text-shadow" не поддерживается браузером "IE".
	
	Значения свойства "text-shadow":
	
		none - убрать тень.
	
	
	Первый пример использования свойства "text-shadow":
	
		text-shadow: 5px 3px 4px gray;
		
	Второй пример использования свойства "text-shadow":
	
		text-shadow: -1px -2px 0.5em rgba(0, 0, 255, 1);
		
	Так же в значении свойства "text-shadow" могут быть несколько групп значений (несколько теней):
	
		text-shadow: 5px 3px 4px gray, -5px -3px 4px red;

letter-spacing

	Определение расстояния между символами в тексте.
	
	Значения свойства "letter-spacing":
	
		normal - обычный.
		
		inherit - наследовать значение от родителя.
		
		(px, pt, cm, mm, и тд.).
		
	Пример использования свойства "letter-spacing":
	
		HTML:
		
			<p class="normal">Some text</p>
			<p class="positive">Some text</p>
			<p class="negative">Some text</p>
			
		CSS:
		
			p.normal {
				letter-spacing: normal;
			}
			p.positive {
				letter-spacing: 4px;
			}
			p.negative {
				letter-spacing: -1.5px;
			}

word-spacing

	Определение расстояния между словами в тексте.
	
	Значения свойства "word-spacing":
	
		normal - обычный.
		
		inherit - наследовать значение от родителя.
		
		(px, pt, cm, mm, и тд.).

white-space

	Определяет, как будут отображаться пробелы внутри элемента.
	
	Значения свойства "white-space":
	
		normal - обычный.
		
		inherit - наследовать значение от родителя.
		
		nowrap - продолжение текста на одной линии без переноса строки до следующего тега "<br>".
		
		pre - текст показывается с учетом всех пробелов и переносов.
		
		pre-line - текст будет перенесен на следующую строку, при соответствующей команде в коде. Пробелы игнорируются.
		
		pre-wrap - в тексте сохраняются все пробелы и переносы. В отличие от значения "pre", оно добавляет дополнительные
		переносы строк в случае, если строка по ширине не помещается в заданную область.

word-wrap

	Свойство "word-wrap" указывает, переносить или нет длинные слова, которые не помещаются по ширине в заданную область.
	Слова которые не помещаются в строку можно разбивать. Данное свойство носит черновой характер и при валидации документа на "CSS3"
	выдает ошибку.
	
	Значения свойства "word-wrap":
	
		normal - строки не переносятся или переносятся в тех местах, где явно задан перенос (например, с помощью тега "<br>").
		
		break-word - разбить слово, если оно не помещается по ширине в заданную область.
		
		inherit - наследует значение родителя.

line-height

	Устанавливает интерлиньяж (межстрочный интервал) текста, отсчет ведется от базовой линии шрифта. При обычных обстоятельствах
	расстояние между строками зависит от вида и размера шрифта и определяется браузером автоматически. Отрицательное значение
	межстрочного расстояния не допускается.
	
	Любое число больше нуля воспринимается как множитель от размера шрифта текущего текста.
	Например, значение "1.5" устанавливает полуторный межстрочный интервал. В качестве значений принимаются также
	любые единицы длины, принятые в "CSS" — пикселы "px", дюймы "in", пункты "pt" и др. Разрешается использовать процентную
	запись, в этом случае за 100% берется высота шрифта.
	
	Пример использования свойства "line-height":
	
		h1 {
			line-height: 60%;
		} 
		p {
			line-height: 1.5;
		}

--------------------------------------------------------------------------------------------------------------------------------------------

Многоколоночный текст:

--------------------------------------------------------------------------------------------------------------------------------------------

column-count

	Устанавливает оптимальное число колонок.

column-gap

	Расстояние между колонками.

column-width

	Оптимальная ширина колонок.

column-rule

	Разделительная линия между колонками.

--------------------------------------------------------------------------------------------------------------------------------------------

Стилизация списков:

--------------------------------------------------------------------------------------------------------------------------------------------

list-style-type

	Установка типа стиля для списков.
	
	Значения свойства "list-style-type" для маркированного списка:
	
		circle - маркер в виде кружка.

		disc - маркер в виде точки.

		square - маркер в виде квадрата.
	
	Значения свойства "list-style-type" для нумерованного списка:

		armenian - традиционная армянская нумерация.

		decimal - арабские числа ("1, 2, 3, 4, ...").

		decimal-leading-zero - арабские числа с нулем впереди для цифр меньше десяти (01, 02, 03,...).

		georgian -традиционная грузинская нумерация.

		lower-alpha -строчные латинские буквы ("a, b, c, d, ...").

		lower-greek -строчные греческие буквы ("α, β, γ, δ, ...").

		lower-latin - это значение аналогично "lower-alpha".

		lower-roman - римские числа в нижнем регистре ("i, ii, iii, iv, v, ...").

		upper-alpha -заглавные латинские буквы ("A, B, C, D, ...").

		upper-latin - это значение аналогично "upper-alpha".

		upper-roman - римские числа в верхнем регистре ("I, II, III, IV, V, ...").

		none - отменяет маркеры для списка.

		inherit - наследует значение родителя.

list-style-image

	Установка изображения в качестве маркера списка.
	
	Значения свойства "list-style-image":
	
		none - нет изображения.
	
		url("...") - значение для указания ссылки на изображения, где "..." - сама ссылка на изображение.
	
	Пример использования свойства "list-style-image":
	
		list-style-image: url(image.jpg);

list-style-position

	Определение размещения маркера списка (внутри или снаружи).
	
	Значения свойства "list-style-position":
	
		inside - внутри элемента (обтекая).
		
		outside - снаружи элемента.

list-style

	Универсальное свойство для установки типа, положения, и изображения для списка, который включает в себя значения
	свойств "list-style-type", "list-style-position", "list-style-image", и возможность наследования значения родителя.
	
	Форма свойства "list-style" выглядит следующим образом:
	
		list-style: list-style-type list-style-position list-style-image Inherit
		
	Где на месте указанных свойств в качестве значений будут значения указанных свойств.
	
	Пример использования свойства "list-style":
	
		list-style: square outside none;
		
	Если значение одного из свойств будет пропущено, то будет использовано значение по умолчанию.

--------------------------------------------------------------------------------------------------------------------------------------------

Стилизация таблиц:

--------------------------------------------------------------------------------------------------------------------------------------------

border-collapse

	Определяет, будет ли рамка таблицы объединена в одну линию или у каждой ячейки будет своя рамка.
	
	Значения свойства "border-collapse":
	
		collapse - объеденить линию рамки между ячейками, также игнорируется значение атрибута "cellspacing".
		
		separate - вокруг каждой ячейки отображается своя собственная рамка, в местах соприкосновения ячеек показываются сразу
		две линии.
		
		inherit - наследовать значение родителя.

border-spacing

	Установка расстояния между ячейками в таблице.
	
	Форма свойства "border-spacing":
	
		border-spacing: расстояние_по_ширине расстояние_по_высоте;
		
	Пример использования "border-spacing":
	
		border-spacing: 20px 40px;

caption-side

	Определение положения заголовка таблицы.
	
	Значения свойства "caption-side":
	
		top - вверху.
		
		bottom - внизу.

empty-cells

	Определяет, отображать рамку и фон пустых ячеек в таблице или нет.
	
	Значения свойства "empty-cells":
	
		show - отображать.
		
		hide - скрыть.

table-layout

	Определяет, каким образом подсчитываются ширина столбцов таблицы.
	
	Значения свойства "table-layout":
	
		auto - ширина зависит от содержимого ячейки (по умолчанию).
		
		fixed - в случае, если ширина столбца или ячейки не задана точно, то содержимое ячейки не будет влиять на ее ширину
		(фиксированный).

--------------------------------------------------------------------------------------------------------------------------------------------

Стилизация ссылок с помощью псевдо-классов:

--------------------------------------------------------------------------------------------------------------------------------------------

a:link

	Псевдо-класс, для определение стиля для непосещенных ссылок.
	
	Пример использования свойства к псевдо-классу "a:link":
	
		a:link {
			text-decoration: none;
		}

a:visited

	Псевдо-класс, для определение стиля для посещенных ссылок.

a:active

	Псевдо-класс, для определение стиля для активной ссылки, при нажатии на нее.
	
	Примечание: "a:active" должно последовать после "a:hover".

a:hover

	Псевдо-класс, для определение стиля для сслыки, когда курсор мыши находится над ней.
	
	Примечание: "a:hover" должно последовать после "a:link" и "a:visited".

Оставшиеся псевдо-классы можно найти в справочных данных.

--------------------------------------------------------------------------------------------------------------------------------------------

Дополнительная стилизация ссылок:

--------------------------------------------------------------------------------------------------------------------------------------------

border

	Чтобы убрать рамку изображений со ссылками, нужно поставить свойству "border" значение "none".

outline

	Чтобы убрать пунктирную рамку с нажатых ссылок в браузере "IE", нужно поставить свойству "outline" значение "none".

outline-offset

	Устанавливает расстояние между рамкой, созданной с помощью свойства "outline", и краем или границей элемента добавленной через "border".

--------------------------------------------------------------------------------------------------------------------------------------------

Функция/метод "attr()".

С помощью функции "attr()" можно извлекать значение атрибута выбранного элемента и использовать это значение в таблице стилей.
Функция работает и с псевдо-элементами. В этом случае возвращается значение атрибута элемента, для которого формируется псевдо-элемент.

Используется вместе со свойством "content".
Функцию "attr()" можно использовать с любым свойством "CSS", но поддержка иных свойств, кроме "content", является экспериментальной.

Форма синтаксиса:

	<селектор>:<псевдо-элемент> { content: attr(<атрибут тега>); }

Пример использования функции "attr()":

	a:after {
		content:attr(href);
	}

Подробнее в папке "attr()".

--------------------------------------------------------------------------------------------------------------------------------------------

Ключевое слово "!important".

--------------------------------------------------------------------------------------------------------------------------------------------

"!important" играет роль в том случае, когда пользователи подключают свою собственную таблицу стилей, также применяется для повышения
специфичности стилевого правила. Если возникает противоречие, когда стиль автора страницы и пользователя для одного и того же элемента
не совпадает, то "!important" позволяет повысить приоритет стиля.

При использовании пользовательской таблицы стилей или одновременном применении разного стиля автора и пользователя к одному и тому же
селектору, браузер руководствуется следующим алгоритмом:

	!important добавлен в авторский стиль — будет применяться стиль автора.

	!important добавлен в пользовательский стиль — будет применяться стиль пользователя.

	!important нет как в авторском стиле, так и в стиле пользователя — будет применяться стиль автора.

	!important содержится в авторском стиле, так и в стиле пользователя — будет применяться стиль пользователя.
	
Синтаксис:

	<свойство>: <значение> !important;
	
Пример использования значения "!important":

	<!DOCTYPE html>
	<html>
	 <head>
	  <meta charset="utf-8">
	  <title>important</title>
	  <style>
	   p {
		background: url(/example/image/tune1.png) no-repeat !important;
		min-height: 112px; /* Минимальная высота */
		padding-left: 65px; /* Поле слева от текста */
	   }
	   p {
		background: url(/example/image/tune2.png) no-repeat;
	   }
	  </style>
	 </head>
	 <body>
		<p>Минорная пентатоника с пониженной V ступенью также называется блюзовой 
		пентатоникой.</p>
	 </body>
	</html>
	
	В данном примере для одного селектора задается одно и то же свойство с разными значениями. Но поскольку к первому селектору
	добавляется "!important", то его стиль и будет применяться на странице.
	
Примечание:

	При добавлении "!important" к значению стилевого свойства его важность повышается. Если переопределить значение того же
	свойства без "!important", оно будет игнорироваться браузерами. Но только не в "Internet Explorer" версии 6 и ниже.

--------------------------------------------------------------------------------------------------------------------------------------------

Стилизация элементов с помощью псевдо-классов и псевдо-элементов.

Псевдо-класс в "CSS" это ключевое слово, добавляемое к селектору, позволяющее применить стили к элементам, которые определяют состояние уже
существующих элементов, которое может меняться при определенных условиях. Псевдо-классы начинаются с ":".
Псевдо-элемент в "CSS" это ключевое слово, добавляемое к селектору, позволяющее применить стили к элементам, которые ранее не существовали
(например "::after"), или к определенной части выбранного селектором элемента (например первая строка параграфа).
Псевдо-элементы начинаются с "::".
Чтобы изменить свойство одного селектора через другой, последством выбора последнего через псевдо-элемент (например ":hover"), нужно чтобы
изменяемый селектор был в одном древе с селекотором, изменяющим его.

--------------------------------------------------------------------------------------------------------------------------------------------

::before

	Псевдо-элемент ":before" применяется для отображения желаемого контента до содержимого элемента, к которому он добавляется.
	Работает совместно со свойством "content".

	Для ":before" характерны следующие особенности:

		При добавлении ":before" к блочному элементу, значение свойства "display" может быть только: "block", "inline", "none",
		"list-item". Все остальные значения будут трактоваться как "block".
		
		При добавлении ":before" к встроенному элементу, "display" ограничен значениями "inline" и "none". Все остальные будут
		восприниматься как "inline".

		":before" наследует стиль от элемента, к которому он добавляется.
		
	Пример использования псевдо-элемента ":before":
	
		li:before {
			content: "¶ "; /* Добавляем желаемый символ перед элементом списка */ 
		}
		li {
			list-style: none; /* Убираем исходные маркеры */ 
		}

::after

	Псевдо-элемент, который используется для вывода желаемого текста после содержимого элемента, к которому он добавляется.
	Псевдо-элемент ":after" работает совместно со свойством "content".

	Для ":after" характерны следующие особенности:

		При добавлении ":after" к блочному элементу, значение свойства "display" может быть только: "block", "inline", "none",
		"list-item". Все остальные значения будут трактоваться как "block".
		
		При добавлении ":after" к встроенному элементу, "display" ограничен значениями "inline" и "none". Все остальные будут
		восприниматься как "inline".

::first-letter

	Выбор и оформление первого символа в выбранном тексте.

::first-line

	Выбор и оформление первой стоки в выбранном параграфе.

::selection

	Применяет стиль к выделенному пользователем фрагменту текста.

:first-child

	Выбор и оформление первого элемента в своем роде из списка.
	
	Пример использовании псевдо-класса ":first-child":
	
		p:first-child {
			color: red;
			font-size: 23px;
		}

:last-child

	Выбор и оформление последнего элемента в своем роде из списка.

:root

	Определяет корневой элемент документа. В "HTML" этот селектор всегда соответствует элементу "<html>".
	
	Пример использования псевдо-класс ":root":
	
		<style>
			:root {
				--primary-color: #0275d8;
				--info-color: #5bc0de;
			}
		</style>

Оставшиеся псевдо-элементы и псевдо-классы можно найти в справочных данных, и в папке "Псевдо-классы и псевдо-элементы".

--------------------------------------------------------------------------------------------------------------------------------------------

Объявление пользовательских переменных "var()".

--------------------------------------------------------------------------------------------------------------------------------------------

Функция "var()" позволяет вставлять значения пользовательских переменных в значения стилевых свойств. "var()" нельзя использовать в
именах селекторов и в свойствах.

Сами пользовательские переменные и их значения описываются внутри произвольного селектора и должны начинаться с двух дефисов.
Через двоеточие переменной присваивается любое допустимое для "CSS" значение.

	aside {
	  --my-font: Helvetica, Arial, sans-serif;
	}
	
	В данном примере мы создали свою-пользовательскую переменную "--my-font", и дальнейшие примеры будем рассматривать на ее основе.
	
Для обращения к переменной "--my-font" используется запись "var(--my-font)", которую можно вставлять в качестве значения свойства.
При этом область видимости переменной ограничена указанным селектором ("aside" в данном случае) и применение "var(--my-font)"
в другом селекторе не даст результата. Для создания глобальных переменных их следует описать внутри псевдо-класс ":root".

Синтаксис функции "var()":

	var( <переменная> [, <значение> ]? )
	
Значения функции "var()":

	<переменная> - имя переменной, обозначается двумя дефисами впереди (например "--my-font").
	
	<значение> - резервное значение, которое подставляется вместо заданного, в том случае, если переменная не определена.
	Через запятую можно указать несколько значений.
	
Пример исаользования пользовательских переменных "var()":

	<!DOCTYPE html>
	<html>
	 <head>
	  <meta charset="utf-8">
	  <title>var()</title>
	  <style>
	   :root {
		--primary-color: #0275d8;
		--info-color: #5bc0de;
	   }
	   button {
		padding: .5rem 1rem;
		border: none;
	   }
	   .primary {
		color: var(--white, #fff);
		background-color: var(--primary-color);
	   }
	   .info {
		color: var(--white, #fff);
		background-color: var(--info-color);
	   }
	   p.info {
		--primary-color: #31708f;
		padding: 10px;
		background-color: #d9edf7;
		color: var(--primary-color);
	   }
	  </style>
	 </head>
	 <body>
	  <p class="info">Кнопки</p>
	  <button class="primary">Типовая кнопка</button>
	  <button class="info">Информация</button>
	 </body>
	</html>
	
	В данном примере вводятся две переменные: "--primary-color" и "--info-color". Переменная "--white" не определена,
	поэтому подставляется указанное значение по умолчанию. Для селектора "p.info" значение переменной "--primary-color" переопределяется.

--------------------------------------------------------------------------------------------------------------------------------------------

Значения через калькуляцию ("calc()"):

--------------------------------------------------------------------------------------------------------------------------------------------

Используется для указания вычисляемого значения свойств, которые в качестве значений используют размер. Это позволяет задавать значения
основанные на сложении или вычитании разных единиц измерений, например можно задать "100% - 20px". Если значение не может быть вычислено,
оно игнорируется.

Форма синтаксиса:

	<свойство>: calc(выражение);
	
Выражение представляет собой комбинацию значений размеров и следующих знаков математических действий.

	+ — сложение (width: calc(20px + 20px)).

	- — вычитание (padding: calc(10% - 10px);).

	* — умножение (height: calc(20%*2);).

	/ — деление. На ноль делить запрещено (width: calc(100%/3);).

	Знаки плюс и минус должны отбиваться пробелами с двух сторон.

--------------------------------------------------------------------------------------------------------------------------------------------

"@-Правила":

--------------------------------------------------------------------------------------------------------------------------------------------

@media

	Правило, для взаимодействия с устройством, в зависимости от параметров и т.д. Подробнее в папке "Медиа запросы". 

@font-face

	Правило "@font-face" позволяет определить настройки шрифтов, а также загрузить специфичный шрифт на компьютер пользователя.
	Внутри конструкции "@font-face" может находиться набор свойств для изменения параметров шрифта ("font-family", "font-size",
	"font-style" и др.), а также ссылка на шрифтовой файл. Ссылка записывается в виде "src: url(URI)", где "URI" — относительный или
	абсолютный путь к файлу. Браузер "Internet Explorer" имеет встроенный баг при определении множества правил "@font-face",
	использование "#iefix" исправляет данную проблему.
	
	Типы шрифтов поддреживаемые браузервами:
	
		Firefox: ".ttf", ".otf"
		
		Safari: ".ttf", ".otf"
		
		Chrome: ".ttf", ".otf"
		
		Opera: ".ttf", ".otf"
		
		Internet Explorer: ".eot"
		
	В правиле "@font-face" сначала указывается (задается) имя шрифта, а затем ссылка на файл шрифта.
	
	Первый пример использования правила "@font-face":
	
		@font-face {
			font-family: Pompadur; /* Имя шрифта */
			src: url('fonts/pompadur.ttf'); /* Путь к файлу со шрифтом */
		}
		p {
			font-family: Pompadur;
		}
		
	Второй пример использования правила "@font-face":
	
		@font-face {
			font-family: Delicious; /* Имя шрифта */
			src: url('Delicious.ttf'); /* Путь к файлу со шрифтом в формате ".ttf" */
			src: url('Delicious.eot? #iefix');
		}
		p {
			font-family: Delicious;
		}
		
		В этом примере было использовано "#iefix" для решения проблемы с багом с браузером "Internet Explorer". Знак "?" заставляет
		браузер "Internet Explorer" думать, что оставшаяся часть строки является строкой запроса, загружающаяся только файл ".eot".

@keyframes

	Правило "@keyframes" устанавливает ключевые кадры при анимации элемента, которые в дальнейшем будут использованы в свойстве
	"animation-name", либо в универсальном свойстве "animation". Ключевой кадр это свойства элемента (прозрачность,	цвет,
	положение и др.), которые должны применяться к элементу	в заданный момент времени. Таким образом, анимация представляет	
	собой плавный переход стилевых свойств от одного ключевого кадра к другому. Вычисление промежуточных значений между такими
	кадрами берёт на себя браузер.
	
	Форма синтаксиса правила "@keyframes":
	
		@keyframes <переменная> { [ from | to | <проценты> ] [, from | to | <проценты> ] }
	
	После правила "@keyframes" задается его имя (имя данного правила ключевых кадров):
	
		@keyframes animation-example {
		
		}
		
	Сами ключевые кадры создаются с помощью ключевых слов "from" и "to" (эквивалентны значениям "0%" и "100%") или с помощью
	процентных пунктов, которых можно задавать сколько угодно. Также можно комбинировать ключевые слова и процентные пункты.
	Сами значения ключевых кадров заключаются в фигурные скобки "{}", и если их больше одного в кадре, то перечисяются через
	";". Если кадры имеют одинаковые свойства и значения, их можно объединить в одно объявление:
	
		@keyframes move {
			from, 
			to {
			top: 0;
			left: 0;
			}
			25%, 
			75% {top: 100%;}
			50% {top: 50%;}
			}
			
	Если "0%" или "100%" кадры не указаны, то браузер пользователя создает их, используя вычисляемые (первоначально заданные)
	значения анимируемого свойства. Если у двух ключевых кадров будут одинаковые селекторы, то последующий отменит действие
	предыдущего.
	
	В таком случае "@keyframes" запишется в следующем виде:
	
		@keyframes box {
			from { left: 0; }
			to { left: 300px; }
		}
		
	В данном случае мы даём нашему набору имя "box", оно затем будет задействовано в свойстве "animation" и определяем,
	что элемент будет изменять значение свойства "left" от "0" до "300" пикселей. Вместо ключевых слов "from" и "to"
	можно использовать, соответственно, "0%" и "100%"
	
	Ключевые кадры не обязательно должны начинаться с "0%" и заканчиваться "100%". Анимация тогда будет происходить не сразу:

		@keyframes box {
			50% { left: 0; }
			90% { left: 300px; }
		}
		
	Не рекомендуется анимировать нечисловые значения (за редким исключением), так как результат в браузере может быть
	непредсказуемым. Также не следует создавать ключевые кадры для значений свойств, не имеющих средней точки, например,
	для значений свойства "color: pink" и "color: #ffffff", "width: auto" и "width: 100px" или "border-radius: 0" и
	"border-radius: 50%" (в этом случае правильно будет указать "border-radius: 0%").
	
	Первый пример использования правила "@keyframes":
	
		@keyframes some-text {
			0% {
				font-size: 10px;
			}
			30% {
				font-size: 15px;
			}
			100% {
				font-size: 12px;
			}
		}

		#div-text {
		animation: some-text 2s infinite;
		}

@charset

	Правило "@charset" определяет кодировку символов, используемую в таблице стилей. Правило должно быть указано самым
	первым в таблице стилей и ему не должен предшествовать какой-либо символ, даже пробел. Если задано несколько правил
	"@charset", то будет использоваться только первое. Правило может быть полезно при использовании не-"ASCII" символов
	в некоторых css-свойствах, например, "content". Не допускается одновременное задание кодировки в таблице стилей с
	помощью правила @charset и на "html"-странице внутри элемента "<style>", или как значение атрибута свойства "style".

@import

	Позволяет импортировать содержимое "CSS"-файла в текущую стилевую таблицу.
	
	Форма синтаксиса свойства "@import":
	
		@import url("<имя файла>") [типы носителей];

		@import "<имя файла>" [типы носителей];
		
	В качестве типа носителя выступают различные устройства, например, принтер, КПК, монитор и др.
	
	Типы устройств:
	
		all - все типы. Это значение используется по умолчанию.

		aural - речевые синтезаторы, а также программы для воспроизведения текста вслух. Сюда, например,
		можно отнести речевые браузеры.

		braille	- устройства, основанные на системе Брайля, которые предназначены для слепых людей.

		handheld - наладонные компьютеры и аналогичные им аппараты.

		print - печатающие устройства вроде принтера.

		projection - проектор.

		screen - экран монитора.

		tv - телевизор.
		
	В качестве значения используется путь к стилевому файлу, который указывается внутри необязательной
	конструкции "url()". Путь к файлу при этом можно писать как в кавычках (двойных или одинарных), так и без них.

@supports

	Правило "@supports" позволяет проверить, поддерживает браузер ту или иную возможность, и на основе этого создать набор стилевых правил.
	Допустимо создавать комплексные условия с помощью логических операторов "not", "and", "or". Синтаксис:
	
		@supports <условие> {
			<стилевые правила>
		}
	
	Примеры синтаксиса:
	
		@supports (transform: perspective(300px)) {
			/* Стили, если браузер поддерживает свойство "transform" с функцией "perspective()" */
		}
		
		@supports not (transform: perspective(300px)) {
			/* Стили, если браузер НЕ поддерживает свойство "transform" с функцией "perspective()" */
		}
	
	Примеры:
	
		@supports (display: flex) {
			.element1 { display: none; }
		}
	   
		@supports not (display: flex) {
			.element2 { display: none; }
		}

Оставшиеся "@правила" можно найти в справочных данных.

--------------------------------------------------------------------------------------------------------------------------------------------

Линейный градиент и повторяющийся линейный градиент

--------------------------------------------------------------------------------------------------------------------------------------------

Градиентом называют плавный переход от одного цвета к другому, причём самих цветов и переходов между ними может быть несколько.
С помощью градиентов создаются самые причудливые эффекты веб-дизайна, например, псевдо-трёхмерность, блики, фон и др. Также с
градиентом элементы смотрятся более симпатично, чем однотонные.

Отдельного свойства для добавления градиента нет, поскольку он считается фоновым изображением, поэтому добавляется через свойство
"background-image" или универсальное свойство "background".

Сам градиент добавляется через значение "linear-gradient".

Эффект свойства зависит от количества значений в свойстве. Порядок значений:

	background: linear-gradient( направление(опционально), transparent (опционально), переходы цвета через запятую и
	остановка (опционально) цвета);
	
		Направление не обязательно, и может быть указано словестно:
		
			to top - снизу вверх.	

			to left - справа налево.	

			to bottom - сверху вниз.	

			to right - слева направо.	

			to top left - от правого нижнего угла к левому верхнему.	

			to top right - от левого нижнего угла к правому верхнему.	

			to bottom left - от правого верхнего угла к левому нижнему.	

			to bottom right - от левого верхнего угла к правому нижнему.
			
		или в градусах (deg), например (180deg).
		
		До указания цветов, можно добавить значение "transparent", которое задаст пропорцию деления экрана, которое отобразит задний
		фон (если он задан) (градиент будет разделен).

		Пример использования значения "transparent":
		
			body {
				background-color: green;
				background-image: linear-gradient(45deg, transparent 50%, blue 50%, red);
			}
		
		Цвета могут быть указаны в любых стандартных форматах "CSS". Минимальное количество цветов (переходов) равно двум.
		
		Для неравномерного распределения цветов указывается начальная позиция каждого цвета через точки остановки градиента,
		так называемые "color stops". Каждому цвету задается позиция его конца относительно стороны, куда направлен градиент.
		Чем ближе находятся точки остановки соседних цветов, тем четче будет граница между ними.
		Остановка цвета не обязательна, и может быть указана в стандартных еденицах измерения "CSS".
		
	Примеры использования линейного градиента:
	
		background: linear-gradient(blue, yellow, green, pink);
		
		background: linear-gradient(blue 20%, yellow 30%, green 85%);
		
		background: linear-gradient(to left, blue, green);
		
		background: linear-gradient(to bottom right, red, green);
		
		background: linear-gradient(100deg, blue, green, white);
		
Так же можно использовать свойство "repeating-linear-gradient" для создания повторяющегося градиента:

	background: repeating-linear-gradient(blue, green 20px);

--------------------------------------------------------------------------------------------------------------------------------------------

Радиальный градиент и повторяющийся радиальный градиент.

--------------------------------------------------------------------------------------------------------------------------------------------

Радиальные градиенты по своему принципу похожи на линейные градиенты, но один цвет переходит в другой не вдоль прямой линии, а словно
круги по воде вокруг точки. Радиальный градиент создаётся с помощью свойства "background" или "background-image" с параметром
"radial-gradient". В простейшем случае для задания радиального градиента понадобится всего два параметра: начальный и конечный цвет.
По умолчанию, начальная точка располагается при этом в центре.

Эффект свойства зависит от количества значений в свойстве. Порядок значений:

	background: radial-gradient(форма градиента (опционально) размер градиента (опционально) позиция градиента(опционально), начальный цвет
	(остановка - опциональна), конечный цвет (остановка - опциональна));
	
	Возможны две формы радиального градиента — круг ("circle") и эллипс ("ellipse"), которые различаются своим видом. По умолчанию
	устанавливается эллиптический градиент.
	
	Наряду с типом градиента можно задавать и его размер, который зависит от применяемых ключевых слов. Размер пишется через
	пробел после типа градиента ("circle" или "ellipse").
	
	Возможные значения размера кругового радиента:
	
		closest-side - форма градиента совпадает с ближайшей к нему стороной блока:
		
			circle:
			
				background: radial-gradient(circle closest-side at 30px 20px, #fff, #000);
			
			ellipse:
			
				background: radial-gradient(ellipse closest-side at 30px 20px, #fff, #000);
		
		closest-corner - форма градиента вычисляется на основании информации о расстоянии до ближайшего угла блока:
		
		farthest-side - градиент распространяется до дальней стороны блока:
		
		farthest-corner - форма градиента вычисляется на основании информации о расстоянии до дальнего угла блока:
	
	Позиция точки пишется аналогично значениям свойства "background-position" с помощью ключевых слов или доступных единиц измерения
	вроде пикселей или процентов. Ниже приведены возможные сочетания:
	
		at top left = at left top = at 0% 0% (в левом верхнем углу);

		at top = at top center = at center top = at 50% 0% (по центру вверху);

		at right top = at top right = at 100% 0% (в правом верхнем углу);

		at left = at left center = at center left = at 0% 50% (по левому краю и по центру);

		at center = at center center = at 50% 50% (по центру) — это значение по умолчанию;

		at right = at right center = at center right = at 100% 50% (по правому краю и по центру);

		at bottom left = at left bottom = at 0% 100% (в левом нижнем углу);

		at bottom = at bottom center = at center bottom = at 50% 100% (по центру внизу);

		at bottom right = at right bottom = at 100% 100% (в правом нижнем углу).
		
	До указания позиции можно указать и форму градиента круг ("circle") или эллипс ("ellipse"):
	
		background: radial-gradient(circle, red, blue);
		
	или форму  вместе с позицией:
		
		background: radial-gradient(circle at 50% 65%, red, blue);
		
	Значения цветов указываются стандартные для "CSS".
	
	Подобно линейному градиенту можно указывать несколько цветов, устанавливать их позицию и делать резкие переходы между цветами.
	Для этого произвольное количество цветов перечисляется через запятую, а после значения цвета через пробел идёт его позиция, которая
	может быть задана в пикселах или процентах. Крайние значения "0%" и "100%" можно не писать, они подразумеваются автоматически.
	Резкие переходы получаются, когда позиция одного цвета совпадает с позицией другого.

--------------------------------------------------------------------------------------------------------------------------------------------

"CSS" фильтры.

--------------------------------------------------------------------------------------------------------------------------------------------

filter

	Свойство "filter" предназначено для применения художественных эффектов к элементам. Обычно используется для изображений,
	чтобы размыть их, увеличить контрастность, преобразовать в чёрно-белую картинку и др. Можно использовать несколько
	фильтров, используя их через пробел.
	
	Значения свойства "filter":
	
		blur - значение задается в единицах длины. Применяет размытие по "Гауссу" к исходному изображению. Чем больше значение
		радиуса, тем больше размытие. Если значение радиуса не задано, по умолчанию берется "0".

		Пример использования:

			filter: blur(3px);

		brightness - значение задается в "%" или в десятичных дробях. Изменяет яркость изображения. Чем больше значение, тем ярче
		изображение. Значение по умолчанию "1".

		Пример использования:

			filter: brightness(50%);

			filter: brightness(.5);

		contrast - значение задается в "%" или в десятичных дробях. Регулирует контрастность изображения, т.е. разницу между самыми
		темными и самыми светлыми участками изображения/фона. Значение по умолчанию "100%". Нулевое значение скроет исходное
		изображение под темно-серым фоном. Значения, увеличивающиеся от "0" до "100%" или от "0" до "1", будут постепенно открывать
		исходное изображение до оригинального отображения, а значения свыше будут увеличивать контраст между светлыми
		и темными участками.

		Пример использования:

			filter: contrast(20%);

			filter: contrast(.2);

		drop-shadow - фильтр действует подобно свойствам "box-shadow" и "text-shadow". Использует следующие значения: смещение по
		оси "Х" смещение по оси "Y" размытость растяжение цвет тени. Отличительная особенность фильтра заключается в том, что
		тень добавляется к элементам и его содержимому с учетом их прозрачности, т.е. если элемент содержит текст внутри,
		то фильтр добавит тень одновременно для текста и видимых границ блока. В отличие от других фильтров, для этого фильтра
		обязательно задание параметров (минимальное - величина смещения).

		Пример использования:

			filter: drop-shadow(2px 3px 5px black);

		grayscale - извлекает все цвета из картинки, делая на выходе черно-белое изображение. Значение задается в "%" или
		десятичных дробях. Чем больше значение, тем сильнее эффект.

		Пример использования:

			filter: grayscale(.5);

			filter: grayscale(50%);

		hue-rotate - меняет цвета изображения в зависимости от заданного угла поворота в цветовом круге. Значение задается в
		градусах от "0deg" до "360deg". "0deg" - значение по умолчанию, означает отсутствие эффекта.

		Пример использования:

			filter: hue-rotate(180deg);

		invert - фильтр делает негатив изображения. Значение задается в "%". "0%" не применяет фильтр, "100%" полностью
		преобразует цвета.

		Пример использования:

			filter: invert(100%);

		opacity - фильтр работает аналогично со свойством "opacity", добавляя прозрачность элементу. Отличительная
		особенность - браузеры обеспечивают аппаратное ускорение для фильтра, что позволяет повысить производительность.
		Дополнительный бонус - фильтр можно одновременно сочетать с другими фильтрами, создавая при этом интересные эффекты.
		Значение задается только в "%", "0%" делает элемент полностью прозрачным, а "100%" не оказывает никакого эффекта.

		Пример использования:

			filter: opacity(30%);

		saturate - управляет насыщенностью цветов, работая по принципу контрастного фильтра. Значение "0%" убирает цветность,
		а "100%" не оказывает никакого эффекта. Значения от "0%" до "100%" уменьшают насыщенность цвета, выше "100%" -
		увеличивают насыщенность цвета. Значение может задаваться как в "%", так и целым числом, "1" эквивалентно "100%".

		Пример использования:

			filter: saturate(300%);

		sepia - эффект, имитирующий старину и "ретро". Значение "0%" не изменяет внешний вид элемента, а "100%" полностью
		воспроизводит эффект сепии.

		Пример использования:

			filter: sepia(150%);

		url - функция принимает расположение внешнего "XML"-файла с "svg"-фильтром, или якорь к фильтру, находящемся
		в текущем документе.

		Пример использования:

			filter: url(#filterId); /* если фильтр находится в этом документе */

			filter: url(filter.svg#filterId); /* если фильтр с id="filterId" находится в файле filter.svg*/

		none - значение по умолчанию. Означает отсутствие эффекта.

		initial - устанавливает это свойство в значение по умолчанию.

		inherit - наследует значение свойства от родительского элемента.

--------------------------------------------------------------------------------------------------------------------------------------------