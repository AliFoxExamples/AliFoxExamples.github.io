-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Установка и настройка.

Для установки "Typescript" нужно ввести команду:

	npm i -D typescript

Далее будут доступны команды консоли через префикс "tsc":

	tsc -v
	
		Вывести версию "Typescript".
	
	tsc --init
	
		Проинициализировать конфигурационный файл "tsconfig.json".
		
	tsc --watch
	
		Компилировать при каждом изменении файлов в директории проекта.

• Настройка конфигурационного файла "tsconfig.json". Свойства:

	compilerOptions
	
		Поле, которое находится в конфигурационном файле по умолчанию. Значением является объект где настраивается компилятор "Typescript".
		
		Некторые свойства поля "compilerOptions":
	
			outDir
			
				Директория, куда будет складываться компиляция (обычно "./dist"). При использовании "Webpack" нет необходимости в данной настройке.
				
			rootDir
			
				Директория проетка (откуда будут браться файлы для компиляции (обычно "./src")). При использовании "Webpack" нет необходимости в данной настройке.
			
			target
			
				Версия "Javascript", в которую будет компилироваться "Typescript". По умолчанию "es6".
			
			sourceMap
			
				Включение соурсмэпов. Прии использовании "Webpack" не рекомендутеся пользоваться данной функцией, так как у "Webpack" имеестся свой функционал соурсмэпов.
				Значением является булево значение.
				
			noEmitOnError
			
				Опция для настройки компиляции в случае синтаксической ошибки (например не компилировать код при наличии ошибок в коде). Значением является булево значение.
				Данной опции по умолчанию нет в конфигурационном файле.
			
			noImplicitAny
			
				Запрещение неявного использования типа "any". По умолчанию включена. Значением является булево значение.
			
			noUnusedLocals
			
				Запрещение неиспользованных локальных переменных. Значением является булево значение.
				
			noUnusedParameters
			
				Запрещение неиспользованных параметров функций. Значением является булево значение.
	
	exclude
	
		Можно добавить дополнительное поле "exclude", значением которого будет массив в котором будут перечислены пути для исключения компиляции. По умолчанию
		в папка "node_modules" игнорирутеся.
	
	include
	
		Можно добавить дополнительное поле "include", значением которого будет массив в котором будут перечислены пути для включения в компиляцию.
		
	files
	
		Можно добавить дополнительное поле "files", значением которого будет массив в котором будут перечислены конкретные файлы для включения в компиляцию.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Базовые типы данных.

Базовые типы данных указываются через двоеточие после имени переменной. Типы данных:

	null
	
	undefined

	string
	
	boolean
	
	number
	
	any
	
		Данный тип данных определяет что типом может быть любой тип данных.
	
	void
	
		Данный тип указывается у функций, которые ничего не возвращают.
	
	never

		Данный тип указывается у функций, которые могут вернуть ошибку или постоянно назодятся в процессе.
		
	unknown
	
		Неизвестный тип данных, который мможет быть получен например от промисов.
		
	object
	
		Тип объект.
	
Примеры:

	const name: string = "Alex";
	
	const n: number = 123;
	
	const bool: boolean = false;

• Так же типом можно указать имя класса, который будет означать что сущность является типом этого класса.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Пользовательские типы данных.

• Можно создать пользовательские типы данных, через ключевое слово "type":

	type Login = string;
	
• Множественные типы данных (юнионы). Можно перечислить несколько типов данных через символ "|":

	type ID = string | number;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Операторы:

	keyof
	
		Данный оператор типизирует сущность на основе ключей его аргумента. То есть сущность типизированная с помошью данного оператора, может иметь только значения, которые равны
		именам ключей объекта (или интерфейса), указанного в качестве аргрумента. Приммер:
		
			interface Person {
				name: string;
				age: number;
			}
			
			type PersonKeys = keyof Person;		//	 Значениями типа могут быть только строки "name" и "age".
			
			const key1: PersonKeys = 'name';
			const key2: PersonKeys = 'age';
			const key3: PersonKeys = 'color';	// Ошибка, нет такого ключа в типе "PersonKeys".
			
	type
	
		Подробнее в глвае "Пользовательские типы данных".
	
	Exclude<Type, ExcludedUnion>
	
		Исключительное объявление типов. На месте "Type" будут типы которые будут включены, а на месте "ExcludedUnion" будут типы, которые будут исключены из "Type".
		Сами типы в обоих аргументах перечисляется через символ "|".
		Пример:
		
			type T0 = Exclude<"a" | "b" | "c", "a">;	//	Здесь 'T0' будет иметь типы "a", "b", "c", но из этих типо будет исключен тип "a", то есть в результате 'T0' будет иметь только типы "b", "c".
		
		Еще пример с использованием интерфейса и оператора "keyof":
		
			interface User {
				_id: string;
				name: string;
				age: number;
				createdAt: Date;
			}
			
			type T0 = Exclude<keyof User, "_id" | "createdAt">;	// Будет иметь только типы "name" и "age".
	
	Pick<Type, IncludedUnion>
	
		То же самое что и "Exclude<Type, ExcludedUnion>", но действует наоборот. То есть будут выбраны только те типы, указанные в аргументе "IncludedUnion".
	
	Partial<Type>
	
		Частичное использование типа (интерфейса). Подробнее в главе "Дженерики" в подглаве "Дженерики функций".
	
	Readonly<Type>
	
		Установка типа как типа только для чтения. Пример:
		
			const cars: Readonly<Array<string>> = ['Ford', 'Audi']
			cars.shift();	//	Вызовет ошибку, так как метод "shift" меняет исходный массив, а оператор "Readonly" запретил изменения этого типа.

			interface Car {
				model: string
				year: number
			}
			
			const ford: Readonly<Car> = {
				model: 'Ford',
				year: 2020
			}
			
			ford.model = 'Ferrari';		// Вызовет ошибку, так как меняется свойство объекта, а оператор "Readonly" запретил изменения этого типа.
		
	|
	
		Оператор перечисления типов (например в юнионах).
	
	&
	
		Оператор объединения дженериков. Подробнее в главе "Дженерики".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Таплы (Tuples).

Таплы типизируют массив. Типизация массива будет в таком порядке, в каком она указана в тапле.

Есть два вариаанта создания таплов:

	1. Указанием сразу после имени переменной:
	
		const arr1: [string, number, string] = ['a', 1, 's'];
	
	2. Через "type":
	
		type ARR = [string, number, string];

		const arr: ARR = ['a', 1, 's'];
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типизирование массивов.

Массивы можно типизировать следующими способами:

	1. Через явное указание типа у литерала массива:
	
		const arr1: string[] = ['a', 'b', 'c'];
		
		const arr2: number[] = [1, 2, 3];
		
		const arr3: boolean[] = [true, false];
		
	2. Через пользовательские типы данных:
	
		type Name = string;
		
		const names: Name[] = ['Alex', 'Nick', 'John'];

	3. Через дженерики (подробнее в главе "Дженерики"):
	
		const arr1: Array<string> = ['a', 'b', 'c'];
		
		const arr2: Array<number> = [1, 2, 3];
		
		const arr3: Array<boolean> = [true, false];

	4. Через Таплы (Tuple) (подробнее в главе "Таплы (Tuples)"):
	
		const person: [string, number] = ['Alex', 12345];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типизирование функций.

При типизировании функций, типизируются передаваемые аргументы, а так же то, что возвращает эта функция. Значение, которая возвращается функцией типизируется добавлением типа
после двоеточия после круглых скобок функции:

	function sum(arg1: number, arg2: number): number {
		return arg1+agr2;
	}

• Если функция ничего не возвращает, то указывается тип "void":

	function greet(name: string): void {
		console.log(name);
	}

• Если функция возвращает ошибку, или постоянно находится в процессе, то указывается тип "never":

	function fn(): never {
		throw new Error();
	}

• Можно указать пользовательский тип (как интерфейс), который будет возвращаеть функция (например объект):

	function sum(a: number, b: number): {a: number, b: number, sum: number} {
		return {a, b, sum: a+b}
	}

• Типизирование стрелочных функций. Синтаксис таков: после иммени фукнции стивится двоеточие, после него скобки. В этих скобках типиизируются входные аргументы, если они есть.
Затем ствится "=>" и после него указывается возаразщаемый функцией тип. Пример:

	const fn:(name: string) => string = (name) => {
		return 'hello' + name;
	}

• Один из способов типизации функций через интерфейсы:

	interface FN {
		(n: number): boolean;
	}
	
	const fn: FF = function (n) {
		console.log(n);
		return true;
	};

• Перегрузки функций. Функция может быть типизирована под разные вариаанты вызова.
Для этого функция пишется и типизируется для конкретного случая как обычная функция, но без тела функции (без фигурных скобок).
Вариантов типизации вызова одной функции может быть много (больше одного). В конце перечисления перегрузок, должна быть типизация вызова функции, но уже с телом функции.
Пример:

	function makeDate(timestamp: number): Date;
	function makeDate(m: number, d: number, y: number): Date;
	function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
	  if (d !== undefined && y !== undefined) {
		return new Date(y, mOrTimestamp, d);
	  } else {
		return new Date(mOrTimestamp);
	  }
	}
	const d1 = makeDate(12345678);
	const d2 = makeDate(5, 5, 5);
	const d3 = makeDate(1, 3);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Интерфейсы.

Интерфейсы нужны для типизации объектов и классов (и фукнций).

Интерфейсы объявляются через ключевое слово "interface", затем пишется имя интерфейса (принято с заглавной буквы), затем идет сам интерфейс в фигурных скобках (без присваивания "=").
В самом интерфейсе могут пыть перечислены поля объекта, и его типы. У этих полей могут быть модификаторы.
Сами поля перечисляются через точку с запятой ";", а не с запятой, как в объектах.

• Модификаторы полей интерфеса:

	readonly
	
		Поле только для чтения.

Пример:

	interface Rect {
		readonly id: string;
	}

Поля интерфейса так же могут быть объектами, которые так же типизируются:

	interface Rect {
		size: {
			width: number;
			height: number;
		}
	}

• Динамические поля. У объектов можно установить динамическую типизацию полей, если типы ключей и значений одинаковы. Для этого используется литерао массива, в которомм указывается
ключевое слово "key" для ключа, затем после него идет тип этого ключа через двоеточие. После литерала массива идет тип значения ключа через двоеточие:

	interface Obj {
		[key: string]: string;
	}

• Опциональные поля.

Чтобы добавить необязательное (опциональное) поле, после имени поля нужно поставить знак вопроса:

	interface Rect {
		color?: string;
	}

• Методы в интерфейсах.

Есть два пособа типизировать методы в интерфейсе:

	1. Простой, использующий синтаксис типизации обычных функций:

		interface A {
			greet(name: string): string;
		}
	
	2. С использованием синтаксиса типизации стрелочных функции:

		interface A {
			greet: (name: string) => string;
		}

• Наследование интерфейсов.

Можно создавать новые интерфейсы, которые будут наследовать старые. Делается это через ключевое слово "extends":

	interface Rect {
		id: string;
		size: {
			width: number;
			height: number;
		}
	}
	
	interface RectWithArea extends Rect {
		getArea: () => number;
	}
	

• Один из способов типизации функций через интерфейсы:

	interface FN {
		(n: number): boolean;
	}
	
	const fn: FF = function (n) {
		console.log(n);
		return true;
	};

• Имплементация интерфейсов у классов.

После создания интерфейса для класса, его дальше можно использовать через ключевое слово "implements":

	interface IClock {
		time: Date;
		setTime(date: Date): void;
	}
	
	class Clock implements IClock {
	
		time: Date = new Date();
		
		setTime(date: Date): void {
			
		};
	
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Енумы (Enums).

Енумы это структуры данных, для упрощения пользования именованных констант. Позволяет определить набор именнованных констант, которые описывают определенные состояния.

Объявляются енумы через ключевое слово "enum", затем идет имя енума (принято с заглавной буквы), после чего идет литерал объекта (без присваивания "=").
Свойства внутри енума перечисляются через запятую, а значения присваиваются через знак равно "=".

Есть два способа пользования енумами:

	1. Простой способ, по ключу и индексу. Если обратиться к ключу енума, то будет возвращен индекс ключа (индексы начинаются с 0). Если обратиться к индексу енума,
	то будет возвращен его ключ:
	
		enum Membership {
			Simple,
			Standard,
			Premium
		}
		
		const membership = Membership.Standard;	//	1
		const membershipReverse = Membership[0];	//	'Simple'.
	
	2. Способ с использованием ключа и значения. Если обратиться к ключу енума, то будет возвращено его значение. Если обратиться к значению енума,
	то будет возвращен его ключ:
	
		enum Seasons {
			Winter = 'Cold',
			Summer = 'Hot',
		}
		
		const winter = Seasons.Winter;	//	'Cold'.
		const cold = Seasons['Cold'];	//	'Winter'.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Классы.

• Типизация свойств инстанса класса.

• Модификаторы свойств класса:

	static	-	статическое свойство или метод, который доступен только самому классу, а не его потомкам. К этим свойствам/методоам может быть получен доступ изнутри самого класса,
	они наследуются другими классами.

	public	-	публичный (по умолчанию). Наследуются другими классами и инстансами.

	protected	-	видны только внутри класса, и наследуются другими классамми. Не доступен инстансам.

	private	-	видны только внутри данного класса, и не наследуются другими классами. Не доступен инстансам.

	readonly - только для чтения. Свойство с данным модификатором можно перезаписать только в самом конструкторе.

Типизация свойств инстанса класса а так же установка его модификатора происходит в начале литерала класса, когда как сами свойства создаются и присваиваются в конструкторе
(кроме свойств которые пишутся вне конструктора):

	class Cat {
		readonly type: string;
		readonly legs: number = 4;
		
		constructor(animalType: string) {
			this.type = animalType;
		}
	}

• Если входные параметры конструктора класса далее будут свойствами инстанса этого класса, то есть упрощенный способ типизации этих свойств - можно этии свойства типизировать сразу
в конструкторе. Для этого достаточно добавить свойству модификатор:

	Запись:

		class Animal {
			constructor(readonly type: string) {
			}
		}
	
	идентична записи:
	
		class Animal {
			type: string;
			constructor(type: string) {
				this.type = type;
			}
		}
	
• Типизация методов. Типизация методов в классах ничем не отличается от типизации методов обычных объектов, за исключением того, что можно добавить модификаторы, а так же
то что методы могут быть аксессорами (геттеры и сеттеры).

• Абстрактные классы.

...

Отличия от интерфейсов.

###Дополнить.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дженерики.

Дженерики, это подстраивающиеся типы данных. Тип данных, который будет указан в дженерике, будет означать что объект будет состоять из элементов указанного типа данных в дженерике.

Дженерики используются на основе уже существующих объектов, или можно создать свой. Сам тип указывается в треугольных скобках "<>", который идет после имени объекта (класса или
функции). Примеры использования дженерика на основе существующего класса:

	const arr1: Array<string> = ['a', 'b', 'c'];
	
	const arr2: Array<number> = ['a', 'b', 'c'];

Дженерик "Array<string>" означает что типизируется инстанс класса "Array", то есть массив, и он будет состоять из строк.

Пример дженерика на основе промиса:

	const promise = new Promise<string>(resolve => {
		setTimeOut(() => resolve("Promise Resolved"), 2000);
	});
	
	promise.then(response => console.log(response));	//	 "response" будет типа "string".
	
	В данном примере дженерик "<string>" будет подставлен в промис, и выполненный проммис будет типа "string". Если в данном примере не был бы указан дженерик, то
	тип выполненного промиса был бы "unknown".
	
	Есть альтернативный вид записи дженерика в примере выше, где дженерик указывается после имени переменной, а не после самого объекта "Promise":
	
		const promise: Promise<string> = new Promise (resolve => {
			setTimeOut(() => resolve("Promise Resolved"), 2000);
		});
		
		promise.then(response => console.log(response));	//	 "response" будет типа "string".

• Дженерики функций.

	Если необходимо динамически типизировать сущность возвращаемую функцией на основе типа принимаемых параметров, то можно воспользоваться дженерикамии функций.
	
	После имени функции указывается пользовательский дженерик внутри треугольных скобок "<>" (например "<Type>"), который будет означать что функция работает с этим типом.
	Этот тип в дальнейшем будет равен типу принимаемого аргрумента, который записан с виде дженерика. Другими словами эта запись служит как переменная, и примет значение типа,
	которая далее будет указана в типе входных параметров, и далее будет означать что функция работает с этим типом. Дженерик указанный после имени функции будет автоматически
	подстраиваться под тип передаваемых аргументов (к примеру функция принимает массив со строками (тип "sting[]")), и у этого аргумента будет дженерик "Type[]"
	("[]" - означает что это массив состоящий из таких типов) (который в данном примере будет равен типу массива со строками "string[]"),
	на основе чего подстроится дженерик самой функции, который был указан в треугольных скобках после имени фукнции ("<Type>"), и будет означать что (в данном примере)
	функция работает с типом "string[]". Далее таким же образом подстроится и тип возвращаемого значения на основе типа принимаемого значения.
	
	Не обязательно писать "Type", вместо него может быть любое имя дженерика (например короткая запись в виде символа "Т"), главное чтобы запись дженерика была одинакова везде
	(после имени функции, в типе принимаемых аргументов, в типе возращаемой сущности).
	
	Пример фукнции дженерика:
	
		const arrOfStrings: string[] = ['a', 'b', 'c'];
		
		const arrOfNumbers: number[] = [1, 2, 3];
	
		function reverse<T>(array: T[]): T[] {		// "array: T[]" в круглых скобках функции означает что тип принимаемого значения будет подставлен в дженерик "T[]", и чему дальше будет равен дженерик во всей функции.
													//	Дженерик "<T>" после имени функции примет значение дженерика "T" входного аргумента "array", этим же значением будет и значение "T[]" на выходе функции.
		
			return array.reverse();
		
		}
		
		reverse(arrOfStrings);	//	Возвращаемый тип будет "string[]", так как этот же тип был получен на входе функци, и на основе чего подстроилась вся функция.
		
		reverse(arrOfNumbers);	//	Возвращаемый тип будет "number[]", так как этот же тип был получен на входе функци, и на основе чего подстроилась вся функция.
	
	• Дженериков может быть несколько, они будут перечисляться в треугольных скобках через запятую. Это будет означать что функция работает с указаннымии типамии. На выходе функции
	дженерики можно объеденить с помощью оператора "&", что будет означать что тип возвращаемой сущности функцией будет комбинацией типов указанных дженериков.
	
	Пример:
	
		const a = {ff: 12};

		const b = {cc: 12};

		function fn<T, R>(c: T, d: R): T & R {			// Оператор "&" объединяет дженерики на выходе фукнции, после чего тип возвращаемой сущности функцией будет иметь тип объедииненный из двух дженериков "T" и "R".
		  return Object.assign({}, c, d);
		}
		
		const e = fn(a, b);		//	"Typescript" теперь будет подсказывать что объекту "e" доступны методы "ff" и "cc".
	
	• Ограничение типов дженериков. Можно ограничить типы дженериков, наследуя дженерик от определенного типа (или нескольких типов) оператором "extends":
	
		const a = {ff: 12};

		const b = {cc: 12};
		
		const a2: string = 'aaa';

		const b2: string = 'bbb';

		function fn<T extends object, R extends object>(c: T, d: R): T & R {		// Запись "T extends object" означает что тип дженерика "T" должен быть типом "object" (должен наследоваться от типа "object").
		  return Object.assign({}, c, d);
		}
		
		const e = fn(a, b);		//	"Typescript" теперь будет подсказывать что объекту "e" доступны методы "ff" и "cc".
		const f = fn(a2, b2)	//	Вызовет ошибку, так как типы передаваемых аргументов не являются типами "object" (типы не наследуются от типа "object").
	
	• Ограничение типов дженериков на основании ключей объекта. Можно ограничить тип дженерика, на основании ключей, которые будут каком либо объекте или же в другом дженерике.
	Сделать это можно с помошью комбинации операторов "extends" и "keyof":
	
		function fn<T extends object, R extends keyof T>(obj: T, key: R) {		// Дженерик "R" будет зависеть (наследоваться) от ключей типа дженерика "T".
		  return obj[key];
		}
		
		const person = {
			name: 'Alex',
			age: '24'
		}
		
		const result1 = fn(person, 'name');
		const result2 = fn(person, 'age');
		const result3 = fn(person, 'height');	// "Typescript" на этапе написания кода будет выдавать ошибку о том, что поля "height" нет в типе "preson".
	
	• Частичное использование типов (интерфейсов).
	
	Для частичного использования типов (интерфейсов), можно воспользоваться утилитой "Partial", после чего ставится тип (имя интерфеса), который и будет использоваться частично.
	
	Например типизация объекта от интерфейса, но объект временно будет пустым (не будут реализованы поля из интерфейса), и чтобы "Typescript" не выдал ошибку о том что объект
	не соответствует указанному интерфейсу, этот интерфейс стоит указать после утилиты "Partial":
	
		interface Car {
			model: string;
			yeat: number;
		}
		
		function createAndValidateCar(model: string, year: number): Car {
			const car: Partial<Car> = {}	//	Так как объект "car" изначально пустой, и чтобы "Typescript" не выдал ошибку, используется утилита "Partial", который указыват что типы следующего интерфейса ("Car") реализованы частично (или не реализованы).

			if (model.length > 3) {
				car.model = model;
			}

			if (year > 2000) {
				car.year = year;
			}

			return car as Car;	// Здесь необходимо приведение типа через "as". потому что функция "createAndValidateCar" возвращает тип "Car", а внутри она реализована частично.
		}

• Дженерики у классов.

	Дженерики у классов во многом схожи с дженерикамии функций. Дженерик класса указывается после имени класса, а использование как входного параметра, и использование как типа
	выходного параметра происходит в его методах или конструкторе:
	
		class Collection<T> {
		
			constructor(private _items: T[] = []) {}
			
			add(item: T) {
				this._items.push(item);
			}
			
			get items(): T[] {
				return this._items;
			}
			
			remove(item: T) {
				this._items = this._items.filter(el => el !== item);
			}
		}
		
		const collection = new Collection(['a', 'b', 'c']);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Приведение типов.

Можно привести какую либо сущность к определенному типу.

Делается это двумя способами:

	1. Через ключевое слово "as". Оно указывается после сущности, и после него идет приводимый тип:
	
		const obj = {} as Rect	// "Rect" - заранее имеющийся интерфейс.
	
	2. Через дженерик:
	
		const obj = <Rect>{}	// "Rect" - заранее имеющийся интерфейс.

• Приведенным типом можно вопользоваться двумя способамии:

	1. Через переменную:

		const elem = document.getElementById('foo');

		elem.addEventListener('test', function (e) {
			const target = e.target as Element;
			console.log(target.id); // 'foo'
		}, false);

		elem.dispatchEvent(new Event('test'));
		
	2. Сразу, указав приведение в круглых скобках:
	
		const elem = document.getElementById('foo');

		elem.addEventListener('test', function (e) {
			const id = (e.target as Element).id;
			console.log(id); // 'foo'
		}, false);

		elem.dispatchEvent(new Event('test'));

• Приведение типов может пригодиться в случаях когда "Typescript" выдает ошибку что какого либа свойства или метода нет у той или иной сущности.
Для этого можно привести этот тип к типу сущности, в котором имеются нужные свойства или методы.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Ошибки и их значения (перевод).

Подробнее "https://github.com/microsoft/TypeScript/blob/main/lib/ru/diagnosticMessages.generated.json".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Примеры типизаций.

• Типизации объектов:

	Пример 1:
	
		type Email = string | undefined;
		
		type OrderTouple = [string, number, boolean];
	
		interface Obj {

			color?: string;
			
			id: string;
			
			age: number;
			
			sayHi1(name: string): string;
			
			sayHi2: (name: string) => string;
			
			email: Email;
			
			order: OrderTouple;
		}

	Пример 2:
	
		interface Obj {
			[key: string]: string;
		}
	
	Пример 3:
	
		type Obj = {
			_id: number,
			name: string
		}

		const obj: Obj = {
			_id: 1,
			name: '1',
		}

• Типизация функций:

	Пример 1:
	
		function sum(n1: number, n2: number): number {
			return n1+n2;
		}
	
	Пример 2:
	
		interface FN {
			(n1: number, n2: number): number;
		}
		
		const fn: FN = function (n1, n2) {
			return n1+n2;
		}

	Пример 3:
	
		const fn:(name: string) => string = (name) => {
			return 'hello' + name;
		}























































	

