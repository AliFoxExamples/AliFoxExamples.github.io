• "isNaN".

• Лексическое окружение существует для любых блоков кода "{...}" ("if", "for", "function" и т.д.).

• Можно объединять/группировать блоки кода в фигурные скобки, для изоляции переменных в "локальной области видимости".

• Строки в "JavaScript" кодируются в формате "UTF-16".

• Метод "toFixed" у чисел возвращает строковое значение числа.

• Оператор "запятая" предоставляет возможность вычислять несколько выражений, разделяя их запятой ",". Каждое выражение выполняется, но возвращается результат только последнего.
Оператор "," имеет очень низкий приоритет, ниже чем у "=".

• Оператор "=" возвращает значение. Вызов "x = value" записывает "value" в "x" и возвращает его.

• Для нестрогого равенства "==" значений "undefined" и "null" действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.

• Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора.

• Несколько вариантов "case" оператора "switch", использующих один код, можно группировать.

• Точка с запятой после "while" в цикле "do{} while();" является обязательным.

• Метки конструкций ("label"). Вызов "break" или "continue" возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

• Функции, созданные, как "Function Declaration" могут быть вызваны раньше своих определений.

• В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.

• "Function Expression" создаётся, когда выполнение доходит до него, и затем уже может использоваться.

• В конце создания функции "Function Expression" (после "}") ставится ";", так как это все равно операция присваивания.

• Пустой "return" в функции аналогичен "return undefined".

• Обращение к имени функции без скобок вернет его исходный код.

• Если имя свойства состоит из числа, то доступ у нему нельзя будет осуществить через точку ".", а только через квадратные скобки "[]".

• В свойствах объекта можно указывать вычисляемые свойства с помощью квадрадных скобок "[]".

• Если название свойства объекта совпадает с именем переменной, то можно не указывать значение вычисляемого свойства объекта.

• Чтобы выяснить, содержит ли определенный объект определенное свойство, существует оператор "in", который возвращает булево значение.

• В объектах есть свойство "__proto__", и оно всегда указывает на объект. Если нужно его переопределить, то переопределяемое значение должно быть всегда объектом.

• Порядок вывода свойств зависит от того, из каких символов состоят свойства. Если они содержат целочисленные значения (даже если в кавычках), то они будут
выводится в порядка возрастания. Чтобы этого избежать, нужно добавить символ плюса "+" перед числом ("44" => "+44"). В таком случае они будут выводиться
в порядке их объявления.

• Свойства объекта, чьи имена созданы с помощью символов не итерируются с помощью циклов "for in", а так же с помощью метода "keys"
объекта "Object" - ("Object.keys(obj)"). Метод "assign" объекта "Object" напротив имеет доступ ко всем свойствам объекта, как к остальным примитивным типам данных,
так и символьным типам.

• Существует встроенный метод "getOwnPropertySymbols" объекта "Object" - "Object.getOwnPropertySymbols(obj)" – с его помощью можно получить все свойства объекта с
ключами-символами. Также существует метод "ownKeys" объекта "Reflect" - "Reflect.ownKeys(obj)" - который возвращает все ключи объекта, включая символьные.

• Варианты создания методов, сокращенное, в литерале объекта, и полное (через "function"), в литерале объекта, не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.

• "this" внутри функции (который (если) в свою очередь является методом объекта) является ссылкой на объект, который указан "перед точкой".

• В строгом режиме вызов "this" без объекта = "undefined". В строгом режиме ('"use strict"') в коде значением "this" будет являться "undefined".
В нестрогом режиме значением "this" в таком случае будет глобальный объект ("window").

• Потеря значения "this". Если создать функцию через "Function Expression", беря саму функцию как метод, из какого либо объекта, который внутри себя использут "this", то созданная
функция потеряет контекст вызова "this".

• У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).

• Команда "debugger" предназначена для того чтобы установить точку останова в коде, тем самым останавливая выполнение кода.

• Контекст вызова "this" не смотрит на объявление объекта, а лишь на момент вызова.

• В конце создания объекта (после литерала оъекта - после "}"), рекомендуетяся ставить ";".

• Рекомендуется ставить точку с запятой после выражения (на усмотрение), если после нее идет самовызываемая функция.

• Числовое преобразование "undefined" вернет "NaN".

• "NaN" преобразеутся в "false".

• Для преобразования объектов в примитивы, методы переписываются/задаются вручную. Если есть универсальный метод "[Symbol.toPrimitive]", то он используется для всех преобразований.
Методы "toString" и "valueOf" устаревшие способы преобразования.

• Методы для преобразований объектов в примитивы ("[Symbol.toPrimitive]", "valueOf" и "toString") не обязаны возвращать именно требуемый "хинтом" тип примитива.

• Для преобразования объектов в примитивы есть обязательное требование: методы ("[Symbol.toPrimitive]"/"toString"/"valueOf") должны возвращать примитив, а не объект.

• Используя специальное свойство "new.target" внутри функции, можно проверить, вызвана ли функция при помощи оператора "new" или без него.

• Обычно у конструкторов отсутствует "return".

• Функции-кострукторы. При вызове "return" с объектом, будет возвращён объект, а не "this". А при вызове "return" с примитивным значением, примитивное значение будет отброшено.

• Если вызов конструктора идёт без аргументов, то можно не ставить скобки после "new".

• Для примитивов создается "объект-обертка" на время вызова метода у него, а затем удалятся.

• Использование конструкторов для "String", "Number", "Boolean" может привести к проблемам, так как то что они возвращают, может быть объектом, вместо примитива.

• В строгом режиме попытка присвоения свойства примитиву (через точку ".") вернет ошибку.

• Особенные примитивы "null" и "undefined" являются исключениями. У них нет соответствующих "объектов-обёрток", и они не имеют никаких методов.
Попытка доступа к свойствам такого значения возвратит ошибку.

• Константы записанные в верхнем регистре, являются общепринятымы "жестко закодированными" переменными (когда значение известно до выполнения
скрипта и записывается непосредственно в код).

• Любая операция с "NaN" возвращает "NaN".

• Результатом вызова "typeof null" является "object". Это неверно. Это официально признанная ошибка в "typeof", сохранённая для совместимости.

• Пробельные символы, такие как "\t" и "\n" по краям строки игнорируются при преобразовании в число, так что строка "\t" "\n", аналогично пустой строке, становится "0" после численного преобразования.

• Все объекты в логическом контексте являются "true".

• Имя конструктора рекомендуется объявлять с большой буквы.

• Для записи длинного числа можно использовать букву "e" с числом после нее, указывающую число нулей (отрицательное число для числа с плавающей точкой).

• Для записи чисел в шестнадцатеричной, двоичной, восьмеричной системе записи используются пары символов соответственно "0x", "0b", "0o".

• Чтобы вызвать метод непосредственно на числе, нужно указать методе после двух точек.

• Для проверки является ли аргуент обычным числом, т.е. не "NaN"/"Infinity"/"-Infinity"	-	"isFinite(<аргумент>);".
Пустая строка интерпретируется как 0 во всех числовых функциях, включая "isFinite()"

• Функция шаблонизации "let str = func`моя строка`;".

• У массива строковых значений полученные функцией в результате выполнения функции шаблонизации, есть свойство "raw", которое содержит "исходный" - изначальный вид введенных строк (вместе со спец символами).

• Разницей двух вариантов получения символа в указанной позиции в том, что при использовании квадратных скобок "[<позиция>]", если в указанной позиции нет символа,
то она вернет "undefined", а при использовании метода "charAt()" она вернет пустую строку.

• Результат "-1" поиска подстроки методом "indexOf(<подстрока>, <позиция (опционально)>)" означает что искомая подсторока не найлена в строке.

• Метод "substring()" схож с методом "slice()", за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними.
В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.

• У метода "substr()" есть недостаток - он может не поддерживаться в средах отличных от браузера.

• Существует специальный метод "is()" у главного объекта "Object", который сравнивает значения примерно как "===".

• Длина суррогатных строк ("length") — 2.

• Массивы являются "перебираемыми" объектами.

• Если в качестве аргумента объекту "Array" передать один целочисленный аргумент, то он сработает как указатель на количество элементов ново создаваемого/возвращаемого	массива.

• Массивы копируются по ссылке как и объекты.

• Вызов методов "push" и "unshift" без аргументов у массива вернет длину массива.

• Не рекомендуется создавать "дыры" в массиве, добавляя в него значения под большим индексом (например "arr[9999] = 'apple';").

• Массивам не рекомендуется присваивать свойства как к объектам, так как движок "JavaScript" перестанет их оптимизировать как нормальный массив.

• При удалении элементов массива оператором "delete", элемент удаляется, а его место сохраняется, то есть свойство "length" массива останется неизменным.

• Методы "pop"/"push" работают быстрее методов "shift"/"unshift".

• Технически, так как массив является объектом, можно использовать и вариант "for <элемент> in <массив>", но не рекомендуется это делать из-за проблем, которые он может вызвать.

• Массивы не имеют ни "[Symbol.toPrimitive]", ни функционирующего "valueOf", они реализуют только преобразование "toString".

• "this" работает с массивами так же как и с объектами.

• Чтобы метод "concat" сработал у массива, при передаваемом аргументе в виде массивоподобного объекта, то нужно такому объекту задать специальный символ "[Sybmol.isConcatSpreadable]" со значением "true".
Для корректной обработки в объекте обязательно должны быть числовые свойства и "length".

• Результат функции метода "forEach" массива (если она вообще что-то возвращает) отбрасывается и игнорируется.

• Методы "indexOf", "lastIndexOf", "includes" массива используют строгое сравнение при выборе элементов. Метод "includes" правильно обрабатывает "NaN" в отличие от "indexOf" и "lastIndexOf".

• По умолчанию элементы массива при методе "sort" сортируются как строки.

• Вызов метода "split" с пустыми аргументами разбил бы строку на массив букв.

• Если массив пуст, то вызов "reduce" без начального значения выдаст ошибку.

• Строковой итератор знает про суррогатные пары.

• "Map" использует почти такое же сравнение, что и "===", с той лишь разницей, что "NaN" считается равным "NaN". Так что "NaN" также может использоваться в качестве ключа.

• Каждый вызов метода "set" у объекта "Map" возвращает объект "Map", так что можно объединить вызовы в цепочку.

• У метода "forEach" объекта "Set" дублируются аргументы "<значение>", так как он имеет только значения, и сделано оно так для обратной совместимости с объектом "Map".

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

• Отличия "WeakMap" и "WeakSet" от "Map" и "Set" в том, что ключи/значения в "WeakMap" и "WeakSet" должны быть только объектами, а не примитивными данными.

• Ненужные элементы массива/объекта для деструктурированного присваивания могут быть отброшены через пустую запятую.

• Значения по умолчанию в деструктуризации могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

• Метод "stringify" объекта "JSON" пропускает циклические ссылки (объект содержащий объект из-вне), методы объектов, символьные свойства и свойства со значениями "undefined".

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON".

• "JSON" не поддерживает комментарии.

• "Object.keys/values/entries" игнорируют символьные свойства.

• Стрелочные функции не имеют свойства "arguments". Если стрелочная функция находится внутри обычной функции, то если обратиться к "arguments" из стрелочной функции,
то получим аргументы внешней обыной функции. Свойство "arguments" у функций является перебираемым объектом и псевдомассивом, но у него нет методов обычного массива.

• Функция получает текущее значение внешних переменных, то есть, их последнее значение.

• Встроенное свойство "length" у функций возвращает количество параметров функции в её объявлении (кроме "...rest").

• "Named Function Expression".

• "new Function()".

• Когда функция создаётся с использованием "new Function", в её "[[Environment]]" записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.

• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями.

• Рекурсивный "setTimeout" позволяет задать задержку между выполнениями более точно, чем "setInterval". "setTimeout" с нулевой задержкой начинает выполняться только после выполнения текущего кода.

• Результатом вызова метода "bind" является особый "экзотический объект".

• Стрелочные функции нельзя использовать как конструкторы *с ключевым словом "new"), так как у них нет собственного "this".

• В строгом режиме попытка выпонить операции с объектом/свойством, запрещенные дескриптором свойства, приведет к ошибке.

• Можно установить геттеры и сеттеры через метод "defineProperty".

• Дескрипторы геттеров и сеттеров отличаются от обычных дескрипторов свойств, они не имеют флагов "value" и "writable", но взамен предлагают функции "get" и "set".

• "__proto__" является геттером и сеттером для "[[Prototype]]". Свойство "__proto__" не может идти по кругу.

• Цикл "for ... in ..." проходит не только по собственным, но и по унаследованным свойствам объекта.

• Если у функции-конструктора, в свойстве "prototype" содержится объект, оператор "new" устанавливает его в качестве "[[Prototype]]" для нового объекта.
Присвоенное значение свойству "prototype" у	функции-конструктора сработает только при его вызове с "new".
Для самой функции-конструктора, "prototype" является всего лишь свойством, указывающий/содержащий объект, который затем станет прототипом для новосозданного объекта.

• У объектов есть свойство "constructor", которое указывает обратно на функцию-конструктор, который его создал.

• У обычных объектов нет свойства "prototype", вместо этого - "__proto__".

• Попытка удаления свойства прототипа (оператор "delete"), через его наследника ни к чему не приведет.

• Прототипом ново-созданного объекта (по умолчанию) является объект со свойством "constructor".

• "typeof" класса это функция.
Синтаксис классов отличается от литералов объектов - методы в классе не разделяются запятой.
Значения свойств (обычных свойств, не статичных) ставятся не после двоеточия (":") как в литерале объекта, а через равно "=" (свойства, которые будут непосредственно у новосозданного объекта, а не у его прототипа).
Аргементы передающиеся в скобки класса попадают в конструктор класса.
Методы указанные в классе, после создания объекта (после "new"), приписываются прототипу новосозданного объекта.
Методы класса являются неперечисляемыми.
Классы всегда используют "'use strict'".
Аналогично "Named Function Expression", "Class Expression" может иметь имя.

• У стрелочных функций нет "super". При обращении к "super" стрелочной функции он берётся из внешней обычной функции.

• Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся "пустой" конструктор с методом "super".

• Когда запускается конструктор унаследованного класса, он не создает пустой объект и не присваивает его "this" (как это делает обычный конструктор), а вместо этого он ожидает что это сделает конструктор родительского класса.

• У функциий есть внутреннее специальное свойство "[[HomeObject]]". Когда функция объявлена как метод внутри класса или объекта, её свойство "[[HomeObject]]" становится равно этому объекту.

• Свойство "[[HomeObject]]" определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как "<метод>()", а не "<метод>: function()"

• Значение "this" при вызове статического метода класса - это сам текущий класс.

• Статические свойства и методы доступны только у самого класса. Статические свойства и методы наследуются (через "extends").

• Чтобы создать приватное свойство в классе, нужно перед именем свойства использовать символ решетки "#". Если класс наследуется от другого класса,
у которого есть приватное свойство, но наследуемый касс не будет иметь доступа к этому приватному свойству. Возможность приватных свойств через "#" была добавлена в язык недавно.
В движках "JavaScript" эта возможность пока не поддерживается или поддерживается частично, необратим полифил.

• Работа "[Symbol.species]". То что возвращает "[Sybmol.species]", будет установлено в качестве конструктора для создания новых объектов.

• Работа "[Sybmol.hasInstance]". Если имеется статический метод "[Symbol.hasInstance]" у класса, то при использовании оператора "instanceof" он будет вызываться. Он принимает проверяемый объект, и должен
вернуть либо "true", либо "false".

• У метода объектов "toString" есть скрытая возможность - возвращать тип.

• Поведение метода объектов "toString" можно изменить с помощью символа "[Sybmol.toStringTag]".

• Блок "finally" является опциональным, и выполняется в любом случае (были ошибки или нет), и даже при "return". "try/catch/finally" работает синхронно. Переменные внутри "try/catch/finally" локальны.

• Исполнитель должен вызвать что-то одно: "resolve" или "reject". Состояние промиса может быть изменено только один раз. Обработчик "finally" "пропускает" результат или ошибку дальше, к последующим обработчикам.
Сами методы-потребители промиса так же возвращает промис, так что можно вызывать методы-потребители по цепочке. Можно вручную вернуть новый промис из метода "then", тогда дальнейшая цепочка методов-потребителей будет уже у нового промиса.
Вокруг функции промиса и обработчиков находится невидимый "try"/"catch". Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий "then".

• Обработчик промисов может возвращать не только объекты-промисы, но и любые объекты, содержащие метод "then". Такие объекты называют "thenable".

• "Promise.all" может принимать любой перебираемый объект, и если это не является промисов, то передаст его в итоговый массив как есть.
Все действия промисов проходят через внутреннюю очередь "promise jobs", так называемую "очередь микрозадач". Таким образом, обработчики "then"/"catch"/"finally" вызываются
после выполнения текущего кода.

• Оператор "Async" ставится перед функцией и всегда возвращает промис. Оператор "Await" нельзя использовать в обычных функциях (в функциях без "Async").
Оператор "Await" ожидает разрешения промиса и возвращает полученное значение.
Оператор "Await" позволяет работать с промис–совместимыми объектами (объекты с методом "then"). Идея в том, что если у объекта можно вызвать метод "then", этого достаточно,
чтобы использовать его с "await".

• Генераторы являются перебираемыми объектами.
Композиция генераторов.
Метод генератора "next" может принимать параметр, который будет обратно отослан в генератор, и будет установлен как результат текущего "yield" (через присвоение переменной).
С помощью генераторов можно превратить обычный объект в перебираемый.

• Асинхронные итераторы и генераторы и асинхронно перебираемые объекты.

• Метод "next()" асинронных итераторов и асинхронных генераторов возвращают промис.

• Импортированные модули работают в строгом режиме. Модули имеют локальную область видимости.
В модулях внешний "this" не определен (равен "undefined", а не "window").
Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом "defer".
Динамической импорт возвращает промис.




































































































