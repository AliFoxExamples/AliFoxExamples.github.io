• "isNaN".

• Можно объединять/группировать блоки кода в фигурные скобки.

• Строки в "JavaScript" кодируются в формате "UTF-16".

• Метод "toFixed" у чисел возвращает строковое значение числа.

• Оператор "запятая" предоставляет возможность вычислять несколько выражений, разделяя их запятой ",". Каждое выражение выполняется, но возвращается результат только последнего.
Оператор "," имеет очень низкий приоритет, ниже чем у "=".

• Оператор "=" возвращает значение. Вызов "x = value" записывает "value" в "x" и возвращает его.

• Для нестрогого равенства "==" значений "undefined" и "null" действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.

• Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора.

• Несколько вариантов "case" оператора "switch", использующих один код, можно группировать.

• Точка с запятой после "while" в цикле "do{} while();" является обязательным.

• Метки конструкций ("label"). Вызов "break" или "continue" возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

• Функции, созданные, как "Function Declaration" могут быть вызваны раньше своих определений.

• В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.

• "Function Expression" создаётся, когда выполнение доходит до него, и затем уже может использоваться.

• В конце создания функции "Function Expression" (после "}") ставится ";", так как это все равно операция присваивания.

• Пустой "return" в функции аналогичен "return undefined".

• Обращение к имени функции без скобок вернет его исходный код.

• Если имя свойства состоит из числа, то доступ у нему нельзя будет осуществить через точку ".", а только через квадратные скобки "[]".

• В свойствах объекта можно указывать вычисляемые свойства с помощью квадрадных скобок "[]".

• Если название свойства объекта совпадает с именем переменной, то можно не указывать значение вычисляемого свойства объекта.

• Чтобы выяснить, содержит ли определенный объект определенное свойство, существует оператор "in", который возвращает булево значение.

• В объектах есть свойство "__proto__", и оно всегда указывает на объект. Если нужно его переопределить, то переопределяемое значение должно быть всегда объектом.

• Порядок вывода свойств зависит от того, из каких символов состоят свойства. Если они содержат целочисленные значения (даже если в кавычках), то они будут
выводится в порядка возрастания. Чтобы этого избежать, нужно добавить символ плюса "+" перед числом ("44" => "+44"). В таком случае они будут выводиться
в порядке их объявления.

• Свойства объекта, чьи имена созданы с помощью символов не итерируются с помощью циклов "for in", а так же с помощью метода "keys"
объекта "Object" - ("Object.keys(obj)"). Метод "assign" объекта "Object" напротив имеет доступ ко всем свойствам объекта, как к остальным примитивным типам данных,
так и символьным типам.

• Существует встроенный метод "getOwnPropertySymbols" объекта "Object" - "Object.getOwnPropertySymbols(obj)" – с его помощью можно получить все свойства объекта с
ключами-символами. Также существует метод "ownKeys" объекта "Reflect" - "Reflect.ownKeys(obj)" - который возвращает все ключи объекта, включая символьные.

• Варианты создания методов, сокращенное, в литерале объекта, и полное (через "function"), в литерале объекта, не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.

• "this" внутри функции (который (если) в свою очередь является методом объекта) является ссылкой на объект, который указан "перед точкой".

• В строгом режиме вызов "this" без объекта = "undefined". В строгом режиме ('"use strict"') в коде значением "this" будет являться "undefined".
В нестрогом режиме значением "this" в таком случае будет глобальный объект ("window").

• Потеря значения "this". Если создать функцию через "Function Expression", беря саму функцию как метод, из какого либо объекта, который внутри себя использут "this", то созданная
функция потеряет контекст вызова "this".

• У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).

• Команда "debugger" предназначена для того чтобы установить точку останова в коде, тем самым останавливая выполнение кода.

• Контекст вызова "this" не смотрит на объявление объекта, а лишь на момент вызова.

• В конце создания объекта (после литерала оъекта - после "}"), рекомендуетяся ставить ";".

• Рекомендуется ставить точку с запятой после выражения (на усмотрение), если после нее идет самовызываемая функция.

• Числовое преобразование "undefined" вернет "NaN".

• "NaN" преобразеутся в "false".

• Для преобразования объектов в примитивы, методы переписываются/задаются вручную. Если есть универсальный метод "[Symbol.toPrimitive]", то он используется для всех преобразований.
Методы "toString" и "valueOf" устаревшие способы преобразования.

• Методы для преобразований объектов в примитивы ("[Symbol.toPrimitive]", "valueOf" и "toString") не обязаны возвращать именно требуемый "хинтом" тип примитива.

• Для преобразования объектов в примитивы есть обязательное требование: методы ("[Symbol.toPrimitive]"/"toString"/"valueOf") должны возвращать примитив, а не объект.

• Используя специальное свойство "new.target" внутри функции, можно проверить, вызвана ли функция при помощи оператора "new" или без него.

• Обычно у конструкторов отсутствует "return".

• Функции-кострукторы. При вызове "return" с объектом, будет возвращён объект, а не "this". А при вызове "return" с примитивным значением, примитивное значение будет отброшено.

• Если вызов конструктора идёт без аргументов, то можно не ставить скобки после "new".

• Для примитивов создается "объект-обертка" на время вызова метода у него, а затем удалятся.

• Использование конструкторов для "String", "Number", "Boolean" может привести к проблемам, так как то что они возвращают, может быть объектом, вместо примитива.

• В строгом режиме попытка присвоения свойства примитиву (через точку ".") вернет ошибку.

• Особенные примитивы "null" и "undefined" являются исключениями. У них нет соответствующих "объектов-обёрток", и они не имеют никаких методов.
Попытка доступа к свойствам такого значения возвратит ошибку.

• Константы записанные в верхнем регистре, являются общепринятымы "жестко закодированными" переменными (когда значение известно до выполнения
скрипта и записывается непосредственно в код).

• Любая операция с "NaN" возвращает "NaN".

• Результатом вызова "typeof null" является "object". Это неверно. Это официально признанная ошибка в "typeof", сохранённая для совместимости.

• Пробельные символы, такие как "\t" и "\n" по краям строки игнорируются при преобразовании в число, так что строка "\t" "\n", аналогично пустой строке, становится "0" после численного преобразования.

• Все объекты в логическом контексте являются "true".

• Имя конструктора рекомендуется объявлять с большой буквы.

• Для записи длинного числа можно использовать букву "e" с числом после нее, указывающую число нулей (отрицательное число для числа с плавающей точкой).

• Для записи чисел в шестнадцатеричной, двоичной, восьмеричной системе записи используются пары символов соответственно "0x", "0b", "0o".

• Чтобы вызвать метод непосредственно на числе, нужно указать методе после двух точек.

• Для проверки является ли аргуент обычным числом, т.е. не "NaN"/"Infinity"/"-Infinity"	-	"isFinite(<аргумент>);".
Пустая строка интерпретируется как 0 во всех числовых функциях, включая "isFinite()"

• Функция шаблонизации "let str = func`моя строка`;".

• У массива строковых значений полученные функцией в результате выполнения функции шаблонизации, есть свойство "raw", которое содержит "исходный" - изначальный вид введенных строк (вместе со спец символами).

• Разницей двух вариантов получения символа в указанной позиции в том, что при использовании квадратных скобок "[<позиция>]", если в указанной позиции нет символа,
то она вернет "undefined", а при использовании метода "charAt()" она вернет пустую строку.

• Результат "-1" поиска подстроки методом "indexOf(<подстрока>, <позиция (опционально)>)" означает что искомая подсторока не найлена в строке.

• Метод "substring()" схож с методом "slice()", за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними.
В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.

• У метода "substr()" есть недостаток - он может не поддерживаться в средах отличных от браузера.

• Существует специальный метод "is()" у главного объекта "Object", который сравнивает значения примерно как "===".

• Длина суррогатных строк ("length") — 2.

• Массивы являются "перебираемыми" объектами.

• Если в качестве аргумента объекту "Array" передать один целочисленный аргумент, то он сработает как указатель на количество элементов ново создаваемого/возвращаемого	массива.

• Массивы копируются по ссылке как и объекты.

• Вызов методов "push" и "unshift" без аргументов у массива вернет длину массива.

• Не рекомендуется создавать "дыры" в массиве, добавляя в него значения под большим индексом (например "arr[9999] = 'apple';").

• Массивам не рекомендуется присваивать свойства как к объектам, так как движок "JavaScript" перестанет их оптимизировать как нормальный массив.

• При удалении элементов массива оператором "delete", элемент удаляется, а его место сохраняется, то есть свойство "length" массива останется неизменным.

• Методы "pop"/"push" работают быстрее методов "shift"/"unshift".

• Технически, так как массив является объектом, можно использовать и вариант "for <элемент> in <массив>", но не рекомендуется это делать из-за проблем, которые он может вызвать.

• Массивы не имеют ни "[Symbol.toPrimitive]", ни функционирующего "valueOf", они реализуют только преобразование "toString".

• "this" работает с массивами так же как и с объектами.

• Чтобы метод "concat" сработал у массива, при передаваемом аргументе в виде массивоподобного объекта, то нужно такому объекту задать специальный символ "[Sybmol.isConcatSpreadable]" со значением "true".
Для корректной обработки в объекте обязательно должны быть числовые свойства и "length".

• Результат функции метода "forEach" массива (если она вообще что-то возвращает) отбрасывается и игнорируется.

• Методы "indexOf", "lastIndexOf", "includes" массива используют строгое сравнение при выборе элементов. Метод "includes" правильно обрабатывает "NaN" в отличие от "indexOf" и "lastIndexOf".

• По умолчанию элементы массива при методе "sort" сортируются как строки.

• Вызов метода "split" с пустыми аргументами разбил бы строку на массив букв.

• Если массив пуст, то вызов "reduce" без начального значения выдаст ошибку.

• Строковой итератор знает про суррогатные пары.

• "Map" использует почти такое же сравнение, что и "===", с той лишь разницей, что "NaN" считается равным "NaN". Так что "NaN" также может использоваться в качестве ключа.

• Каждый вызов метода "set" у объекта "Map" возвращает объект "Map", так что можно объединить вызовы в цепочку.

• У метода "forEach" объекта "Set" дублируются аргументы "<значение>", так как он имеет только значения, и сделано оно так для обратной совместимости с объектом "Map".

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

• Отличия "WeakMap" и "WeakSet" от "Map" и "Set" в том, что ключи/значения в "WeakMap" и "WeakSet" должны быть только объектами, а не примитивными данными.

• Ненужные элементы массива/объекта для деструктурированного присваивания могут быть отброшены через пустую запятую.

• Значения по умолчанию в деструктуризации могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

• Метод "stringify" объекта "JSON" пропускает циклические ссылки (объект содержащий объект из-вне), методы объектов, символьные свойства и свойства со значениями "undefined".

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON".

• "JSON" не поддерживает комментарии.

• "Object.keys/values/entries" игнорируют символьные свойства.

• Стрелочные функции не имеют свойства "arguments". Если стрелочная функция находится внутри обычной функции, то если обратиться к "arguments" из стрелочной функции,
то получим аргументы внешней обыной функции.

• Функция получает текущее значение внешних переменных, то есть, их последнее значение.

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

