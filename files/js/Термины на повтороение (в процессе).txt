◘◘◘◘ Общее.

• Любая операция с "NaN" возвращает "NaN".

• Команда "debugger" предназначена для того чтобы установить точку останова в коде, тем самым останавливая выполнение кода.

• Лексическое окружение существует для любых блоков кода "{...}" ("if", "for", "function" и т.д.).

• Можно объединять/группировать блоки кода в фигурные скобки, для изоляции переменных в "локальной области видимости".

• В строгом режиме "'use strict';" объявление переменной без ключевых слов "var","let","const" вызовет ошибку.

• Для нестрогого равенства "==" значений "undefined" и "null" действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.

• Константы записанные в верхнем регистре, являются общепринятымы "жестко закодированными" переменными (когда значение известно до выполнения
скрипта и записывается непосредственно в код).

• Результатом вызова "typeof null" является "object". Это неверно. Это официально признанная ошибка в "typeof", сохранённая для совместимости.

• Внутренние слоты. Многие встроенные объекты, например "Map", "Set", "Date", "Promise" и другие используют так называемые "внутренние слоты".

• Если переменные именуются через символ "$", то принято считать что они содержат в себе "node" элемент "DOM" дерева.

• В нестрогом режме, функции объявленные через "Function Decaration" в блоках кода будут видны за ее пределами.

◘◘◘◘ Примитивы.

• "isNaN".

• Для примитивов создается "объект-обертка" на время вызова метода у него, а затем удалятся. Особенные примитивы "null" и "undefined" являются исключениями.
У них нет соответствующих "объектов-обёрток", и они не имеют никаких методов. Попытка доступа к свойствам такого значения возвратит ошибку.

• В строгом режиме попытка присвоения свойства примитиву (через точку ".") вернет ошибку.

◘ Строки.

• Строки в "JavaScript" кодируются в формате "UTF-16".

• Текст с обратными кавычками можно записывать в нескольких строках.

• Результат "-1" поиска подстроки методом "indexOf(<подстрока>, <позиция (опционально)>)" означает что искомая подсторока не найдена в строке.

• Разницей двух вариантов получения символа в указанной позиции в том, что при использовании квадратных скобок "[<позиция>]", если в указанной позиции нет символа,
то она вернет "undefined", а при использовании метода "charAt()" она вернет пустую строку.

• Метод "substring()" схож с методом "slice()", за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними.
В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.

• Методу "codePointAt()" существует обратный метод у объекта "String" - "fromCodePoint(<код в формате "UTF-16">)", который возвращает символ по его коду.

• У метода "substr()" есть недостаток - он может не поддерживаться в средах отличных от браузера.

• Длина суррогатных строк ("length") равна 2.

• Вызов метода "split" с пустыми аргументами разбил бы строку на массив букв.

• Строковой итератор знает про суррогатные пары.

◘ Числа.

• Потеря точности с длинным числом.

• Округление чисел. В "JavaScript" числа будет округлено до целого, если оно будет иметь больше 14 нулей, после запятой.

• "20.0" это тоже что и "20".

• В "JavaScript" самым маленьким числом является "5e-324". Числа меньше него будут конвертированы в "0".

• Метод "toFixed" у чисел возвращает строковое значение числа.

• Для записи длинного числа можно использовать букву "e" с числом после нее, указывающую число нулей (отрицательное число для числа с плавающей точкой).

• Для записи чисел в шестнадцатеричной, двоичной, восьмеричной системе записи используются пары символов соответственно "0x", "0b", "0o".

• Чтобы вызвать метод непосредственно на числе, нужно указать методе после двух точек.

• Для проверки является ли аргуент обычным числом, т.е. не "NaN"/"Infinity"/"-Infinity"	-	"isFinite(<аргумент>);".
Пустая строка интерпретируется как 0 во всех числовых функциях, включая "isFinite()".

• Есть большая разница между методом "isFinite(<аргумент>)" объекта "Number" и глобальным методом "isFinite(<аргумент>)".
Метод объекта "Number" "isFinite(<аргумент>)" проверяет является ли аргумент конечным числом, без принудительной конвертации в числовой тип.
Глобальный метод "isFinite(<аргумент>)" может конвертировать в числовой тип все, кроме "NaN"/"Infinity"/"-Infinity", а затем проверить является ли аргуент конечным числом.

◘ BigInt.

• "BigInt". Все операции с числами типа "bigint" возвращают "bigint". Нельзя смешивать "bigint" и обычные числа.

• Конвертирование "bigint" в число всегда происходит неявно и без генерации ошибок, но если значение "bigint" слишком велико и не подходит под тип "number", то дополнительные биты будут отброшены.

• К "BigInt" числам нельзя применить унарный оператор "+".

◘◘◘◘ Преобразование типов.

• Числовое преобразование "undefined" вернет "NaN".

• "NaN" преобразеутся в "false".

• Для преобразования объектов в примитивы, методы переписываются/задаются вручную. Если есть универсальный метод "[Symbol.toPrimitive]", то он используется для всех преобразований.
Методы "toString" и "valueOf" устаревшие способы преобразования.

• Для преобразования объектов в примитивы есть обязательное требование: методы ("[Symbol.toPrimitive]"/"toString"/"valueOf") должны возвращать примитив, а не объект.

• Методы для преобразований объектов в примитивы ("[Symbol.toPrimitive]", "valueOf" и "toString") не обязаны возвращать именно требуемый "хинтом" тип примитива.

• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями.

• Пробельные символы, такие как "\t" и "\n" по краям строки игнорируются при преобразовании в число, так что строка "\t" "\n", аналогично пустой строке, становится "0" после численного преобразования.

• У метода объектов "toString" есть скрытая возможность - возвращать тип.

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON" (вызов метода "stringify" у "JSON" для объекта)

◘◘◘◘ Операторы.

• Оператор "запятая" предоставляет возможность вычислять несколько выражений, разделяя их запятой ",". Каждое выражение выполняется, но возвращается результат только последнего.
Оператор "," имеет очень низкий приоритет, ниже чем у "=".

• Оператор "=" возвращает значение. Вызов "x = value" записывает "value" в "x" и возвращает его.

• Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора.

• Условный оператор множества условий "switch" строго ("===") сравнивает заданное имя сравниваемой переменной со всеми значениями оператора "case".

• Несколько вариантов "case" оператора "switch", использующих один код, можно группировать.

◘ Циклы.

• Точка с запятой после "while" в цикле "do{} while();" является обязательным.

• Метки конструкций ("label"). Вызов "break" или "continue" возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

• Цикл "for ... in ..." проходит не только по собственным, но и по унаследованным свойствам объекта.

◘◘◘◘ Функции.

• Функции, созданные, как "Function Declaration" могут быть вызваны раньше своих определений.

• В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.

• "Function Expression" создаётся, когда выполнение доходит до него, и затем уже может использоваться.

• В конце создания функции "Function Expression" (после "}") ставится ";", так как это все равно операция присваивания.

• Если параметр по умолчанию не был передан, или был передан "undefined", то его значением становится "undefined".

• Функция получает текущее значение внешних переменных, то есть, их последнее значение.

• Обращение к имени функции без скобок вернет его исходный код.

• Пустой "return" в функции аналогичен "return undefined".

• Рекомендуется ставить точку с запятой после выражения (на усмотрение), если после нее идет самовызываемая функция.

• Функция шаблонизации "let str = func`моя строка`;". У массива строковых значений полученные функцией в результате выполнения функции шаблонизации,
есть свойство "raw", которое содержит "исходный" - изначальный вид введенных строк (вместе со спец символами).

• Встроенное свойство "length" у функций возвращает количество параметров функции в её объявлении (кроме "...rest").

• "new Function()".

• Когда функция создаётся с использованием "new Function", в её "[[Environment]]" записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.

• "Named Function Expression".

• Тип свойства "arguments" является "[object Arguments]".

• Формы синтаксиса самовызываемой функции.

◘ Стрелочные функции.

• У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).

• Стрелочные функции не имеют свойства "arguments". Если стрелочная функция находится внутри обычной функции, то если обратиться к "arguments" из стрелочной функции,
то получим аргументы внешней обыной функции. Свойство "arguments" у функций является перебираемым объектом и псевдомассивом, но у него нет методов обычного массива.

• Стрелочные функции нельзя использовать как конструкторы (с ключевым словом "new"), так как у них нет собственного "this".

• У стрелочных функций нет "super". При обращении к "super" стрелочной функции он берётся из внешней обычной функции.
Так же со стрелочными функциями нельзя использовать методы "bind", "call", "apply".

◘◘◘◘ Объекты.

• Все объекты в логическом контексте являются "true".

• В конце создания объекта (после литерала оъекта - после "}"), рекомендуетяся ставить ";".

• Чтобы выяснить, содержит ли определенный объект определенное свойство, существует оператор "in", который возвращает булево значение.

• Если имя свойства состоит из числа, то доступ у нему нельзя будет осуществить через точку ".", а только через квадратные скобки "[]".

• В свойствах объекта можно указывать вычисляемые свойства с помощью квадрадных скобок "[]".

• Если название свойства объекта совпадает с именем переменной, то можно не указывать значение вычисляемого свойства объекта.

• В объектах есть свойство "__proto__", и оно всегда указывает на объект. Если нужно его переопределить, то переопределяемое значение должно быть всегда объектом.

• Порядок вывода свойств зависит от того, из каких символов состоят свойства. Если они содержат целочисленные значения (даже если в кавычках), то они будут
выводится в порядка возрастания. Чтобы этого избежать, нужно добавить символ плюса "+" перед числом ("44" => "+44"). В таком случае они будут выводиться
в порядке их объявления.

• "Object.keys/values/entries" игнорируют символьные свойства.

• Существует встроенный метод "getOwnPropertySymbols" объекта "Object" - "Object.getOwnPropertySymbols(obj)" – с его помощью можно получить все свойства объекта с
ключами-символами. Также существует метод "ownKeys" объекта "Reflect" - "Reflect.ownKeys(obj)" - который возвращает все ключи объекта, включая символьные.

• Варианты создания методов, сокращенное, в литерале объекта, и полное (через "function"), в литерале объекта, не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.

• Свойство "[[HomeObject]]" определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как "<метод>()", а не "<метод>: function()".

◘ Дескрипторы.

• Определение свойства как неконфигурируемого необратимо (нельзя изменить обратно).

• С помощью "Object.create()" тоже можно задать дескрипторы свойств.

• Если какой-либо флаг не указан явно, ему присваивается значение "false".

• В строгом режиме попытка выполнить операции с объектом/свойством, запрещенные дескриптором свойства, приведет к ошибке.

• Можно установить геттеры и сеттеры через метод "defineProperty".

• Дескрипторы геттеров и сеттеров отличаются от обычных дескрипторов свойств, они не имеют флагов "value" и "writable", но взамен предлагают функции "get" и "set".

• На объектах тоже можно использовать "Rest"/"Spread".

◘◘◘◘ This.

• "this" работает с массивами так же как и с объектами.

• Контекст вызова "this" не смотрит на объявление объекта, а лишь на момент вызова.

• "this" внутри функции (который (если) в свою очередь является методом объекта) является ссылкой на объект, который указан "перед точкой".

• В строгом режиме ('"use strict"') вызов "this" без объекта = "undefined". В нестрогом режиме значением "this" в таком случае будет глобальный объект ("window").

• Потеря значения "this". Если создать функцию через "Function Expression", беря саму функцию как метод, из какого либо объекта, который внутри себя использут "this", то созданная
функция потеряет контекст вызова "this".

• Значение "this" при вызове статического метода класса - это сам текущий класс.

• Частичное применение аргументов у привязки контекста "bind".

◘◘◘◘ Наследование.

• "__proto__" является геттером и сеттером для "[[Prototype]]". Свойство "__proto__" не может идти по кругу.

• Если у функции-конструктора, в свойстве "prototype" содержится объект, оператор "new" устанавливает его в качестве "[[Prototype]]" для нового объекта.
Присвоенное значение свойству "prototype" у	функции-конструктора сработает только при его вызове с "new".
Для самой функции-конструктора, "prototype" является всего лишь свойством, указывающий/содержащий объект, который затем станет прототипом для новосозданного объекта.
Прототипом объекта может являться только объект или "null".

• У объектов есть свойство "constructor", которое указывает обратно на функцию-конструктор, который его создал.

• У обычных объектов нет свойства "prototype", вместо этого - "__proto__".

• Попытка удаления свойства прототипа (оператор "delete"), через его наследника ни к чему не приведет.

• Прототипом ново-созданного объекта (по умолчанию) является объект со свойством "constructor".

◘◘◘◘ Массивы.

• Методы "splice", "sort", "reverse" меняют исходный массив.

• Массивы являются "перебираемыми" объектами.

• Массивы копируются по ссылке как и объекты.

• Если в качестве аргумента объекту "Array" передать один целочисленный аргумент, то он сработает как указатель на количество элементов ново создаваемого/возвращаемого	массива.

• Можно создать массив с помощью конструктора "Array" но без ключевого слова "new".

• Результат "-1" поиска подстроки методом "indexOf(<подстрока>, <позиция (опционально)>)" означает что искомая подсторока не найдена в строке.

• Метод "substring()" схож с методом "slice()", за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними.
В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.

• У метода "substr()" есть недостаток - он может не поддерживаться в средах отличных от браузера.

• Вызов методов "push" и "unshift" без аргументов у массива вернет длину массива.

• Массивам не рекомендуется присваивать свойства как к объектам, так как движок "JavaScript" перестанет их оптимизировать как нормальный массив.

• При удалении элементов массива оператором "delete", элемент удаляется, а его место сохраняется, то есть свойство "length" массива останется неизменным.

• Технически, так как массив является объектом, можно использовать и вариант "for <элемент> in <массив>", но не рекомендуется это делать из-за проблем, которые он может вызвать.

• Массивы не имеют ни "[Symbol.toPrimitive]", ни функционирующего "valueOf", они реализуют только преобразование "toString".

• Чтобы метод "concat" сработал у массива, при передаваемом аргументе в виде массивоподобного объекта, то нужно такому объекту задать специальный символ "[Sybmol.isConcatSpreadable]" со значением "true".
Для корректной обработки в объекте обязательно должны быть числовые свойства и "length".

• Результат функции метода "forEach" массива (если она вообще что-то возвращает) отбрасывается и игнорируется.

• Методы "indexOf", "lastIndexOf", "includes" массива используют строгое сравнение при выборе элементов. Метод "includes" правильно обрабатывает "NaN" в отличие от "indexOf" и "lastIndexOf".

• По умолчанию элементы массива при методе "sort" сортируются как строки.

• Если массив пуст, то вызов "reduce" без начального значения выдаст ошибку.

◘◘◘◘ Деструктуризация.

• Ненужные элементы массива/объекта для деструктурированного присваивания могут быть отброшены через пустую запятую.

• Значения по умолчанию в деструктуризации могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

◘◘◘◘ Методы - общее.

• Результатом вызова метода "bind" является особый "экзотический объект", который затем можно вызвать как функцию.

• Существует специальный метод "is()" у главного объекта "Object", который сравнивает значения примерно как "===".

• Рекурсивный "setTimeout" позволяет задать задержку между выполнениями более точно, чем "setInterval". "setTimeout" с нулевой задержкой начинает выполняться только после выполнения текущего кода.

• В строгом режиме у "eval" имеется своё лексическое окружение.

◘◘◘◘ Конструкторы.

• Имя конструктора рекомендуется объявлять с большой буквы.

• Если вызов конструктора идёт без аргументов, то можно не ставить скобки после "new".

• Обычно у конструкторов отсутствует "return".

• Функции-кострукторы. При вызове "return" с объектом, будет возвращён объект, а не "this". А при вызове "return" с примитивным значением, примитивное значение будет отброшено.

• Используя специальное свойство "new.target" внутри функции, можно проверить, вызвана ли функция при помощи оператора "new" или без него.

• Использование конструкторов для "String", "Number", "Boolean" может привести к проблемам, так как то что они возвращают, может быть объектом, вместо примитива.

• Конструктор главного объекта "Object" ("new Object(<цель/цели>)") создаёт объект-обёртку для переданного значения. Если значением является "null" или "undefined",
создаёт и возвращает пустой объект, в противном случае возвращает объект такого типа, который соответствует переданному значению.

• При вызове в не-конструкторном контексте (без "new"), "Object" ведёт себя идентично коду "new Object()".

◘◘◘◘ Symbol.

• Внутри метода "Symbol.keyFor" используется глобальный реестр символов для нахождения имени символа. Этот метод не будет работать для неглобальных символов.

• Для любых символов доступно свойство "description".

• Работа "[Symbol.species]". То что возвращает "[Sybmol.species]", будет установлено в качестве конструктора для создания новых объектов.

• Работа "[Sybmol.hasInstance]". Если имеется статический метод "[Symbol.hasInstance]" у класса, то при использовании оператора "instanceof" он будет вызываться. Он принимает проверяемый объект, и должен
вернуть либо "true", либо "false".

• Поведение метода объектов "toString" можно изменить с помощью символа "[Sybmol.toStringTag]".

◘◘◘◘ Классы.

• При расширении класса другим классом, новые объекты будут такого же типа, что и класс, от которого идет расшрение нового класса. Даже новые объекты, которые будут возвращаться при
применении встроенных методов от класса, от которого идет расширение нового класса, будут такого же типа. Можно настроить это поведение при помощи символа "Symbol.species", который должен быть указан
в качестве специального статического геттера. Этот статический геттер должен вернуть конструктор, который будет использован в качестве конструктора для новых объектов, которые будут создаваться уже втроенными методами.

• В ES6 всплытие классов не происходит (как например функции).

• "typeof" класса это функция. Синтаксис классов отличается от литералов объектов - методы в классе не разделяются запятой.
Значения свойств (обычных свойств, не статичных) ставятся не после двоеточия (":") как в литерале объекта, а через равно "=" (свойства, которые будут непосредственно у новосозданного объекта, а не у его прототипа).

• Аргументы передающиеся в скобки класса попадают в конструктор класса.

• Методы указанные в классе, после создания объекта (после "new"), приписываются прототипу новосозданного объекта.

• Методы класса являются неперечисляемыми.

• Классы всегда используют "'use strict'".

• Аналогично "Named Function Expression", "Class Expression" может иметь имя.

• Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся "пустой" конструктор с методом "super".

• Когда запускается конструктор унаследованного класса, он не создает пустой объект и не присваивает его "this" (как это делает обычный конструктор), а вместо этого он ожидает что это сделает конструктор родительского класса.

• У функциий есть внутреннее специальное свойство "[[HomeObject]]". Когда функция объявлена как метод внутри класса или объекта, её свойство "[[HomeObject]]" становится равно этому объекту.

• Свойство "[[HomeObject]]" определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как "<метод>()", а не "<метод>: function()"

• Статические свойства и методы доступны только у самого класса.
• Статические свойства и методы наследуются (через "extends").

• Чтобы создать приватное свойство в классе, нужно перед именем свойства использовать символ решетки "#". Если класс наследуется от другого класса,
у которого есть приватное свойство, но наследуемый касс не будет иметь доступа к этому приватному свойству. Возможность приватных свойств через "#" была добавлена в язык недавно.
В движках "JavaScript" эта возможность пока не поддерживается или поддерживается частично, необратим полифил.

• Приватные поля классов так же используют "внутренние слоты".

◘◘◘◘ Map. WeakMap.

• "Map" использует почти такое же сравнение, что и "===", с той лишь разницей, что "NaN" считается равным "NaN". Так что "NaN" также может использоваться в качестве ключа.

• Каждый вызов метода "set" у объекта "Map" возвращает объект "Map", так что можно объединить вызовы в цепочку.

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

• Отличия "WeakMap" и "WeakSet" от "Map" и "Set" в том, что ключи/значения в "WeakMap" и "WeakSet" должны быть только объектами, а не примитивными данными. "WeakMap" не является итерируемым объектом.

◘◘◘◘ Set. WeakSet.

• У метода "forEach" объекта "Set" дублируются аргументы "<значение>", так как он имеет только значения, и сделано оно так для обратной совместимости с объектом "Map".

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

• Отличия "WeakMap" и "WeakSet" от "Map" и "Set" в том, что ключи/значения в "WeakMap" и "WeakSet" должны быть только объектами, а не примитивными данными. "WeakSet" не является итерируемым объектом.

◘◘◘◘ JSON.

• Конструкция метода "stringify".

• Метод "stringify" объекта "JSON" пропускает циклические ссылки (объект содержащий объект из-вне), методы объектов, символьные свойства и свойства со значениями "undefined".

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON".

• "JSON" не поддерживает комментарии.

◘◘◘◘ Дата.

• Если было передано несколько аргументов, то из них будет слагаться соответствующая дата. В таком случае минимум передаваемых аргументов это 2 (год и месяц).

• "parse(<строка>)"	-	данный метод объекта "Date" считывает дату из строки. Формат строки должен быть следующим - "YYYY-MM-DDTHH:mm:ss.sssZ".

◘◘◘◘ Try/Catch/Finally.

• Блок "finally" является опциональным, и выполняется в любом случае (были ошибки или нет), и даже при "return". "try/catch/finally" работает синхронно. Переменные внутри "try/catch/finally" локальны.

◘◘◘◘ Промисы.

• Исполнитель должен вызвать что-то одно: "resolve" или "reject". Состояние промиса может быть изменено только один раз.

• Обработчик "finally" "пропускает" результат или ошибку дальше, к последующим обработчикам.

• Сами методы-потребители промиса так же возвращает промис, так что можно вызывать методы-потребители по цепочке. Можно вручную вернуть новый промис из метода "then", тогда дальнейшая цепочка методов-потребителей будет уже у нового промиса.

• Вокруг функции промиса и обработчиков находится невидимый "try"/"catch". Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий "then".

• Обработчик промисов может возвращать не только объекты-промисы, но и любые объекты, содержащие метод "then". Такие объекты называют "thenable".

• "Promise.all" может принимать любой перебираемый объект, и если это не является промисом, то передаст его в итоговый массив как есть.
Все действия промисов проходят через внутреннюю очередь "promise jobs", так называемую "очередь микрозадач". Таким образом, обработчики "then"/"catch"/"finally" вызываются
после выполнения текущего кода.

◘◘◘◘ Побитовые операторы.

• Побитовые операторы. Исключающее "или" можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего "ИЛИ" с тем же аргументом даёт исходное число.
У побитовых операторов низкий приоритет, меньше чем у операторов сравниваний, и меньше чем у остальной арифметики.

◘◘◘◘ Прокси.

• "Proxy" – это особый, "экзотический", объект, у него нет собственных свойств или методов. Полезной практикой будет перезаписать исходный объект, предварительно создав для
него прокси. При использовании прокси, "this" является сам прокси. Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия (Инварианты).
Обращение к методам исходного объекта, будет перехватываться ловушкой "get", так как это все развно обращение, а не запись.

• Свойства, которые былы у целевой функции (вокруг чего была создана прокси) - можно вызвать у самой прокси (например свойство "length").

• Отключаемые прокси.

◘ Рефлект.

• В отличие от большинства глобальных объектов, "Reflect" - это не конструктор. Нельзя использовать его с оператором "new" или вызывать "Reflect" как функцию.

◘◘◘◘ Async/Await.

• Оператор "Async" ставится перед функцией и всегда возвращает промис.

• Оператор "Await" нельзя использовать в обычных функциях (в функциях без "Async").

• Оператор "Await" ожидает разрешения промиса и возвращает полученное значение.

• Оператор "Await" позволяет работать с промис–совместимыми объектами (объекты с методом "then"). Идея в том, что если у объекта можно вызвать метод "then", этого достаточно,
чтобы использовать его с "await".

◘◘◘◘ Генераторы.

• Генераторы являются перебираемыми объектами.

• Композиция генераторов.

• Метод генератора "next" может принимать параметр, который будет обратно отослан в генератор, и будет установлен как результат текущего "yield" (через присвоение переменной).

• С помощью генераторов можно превратить обычный объект в перебираемый.

◘ Асинхронные генераторы.

• Асинхронные итераторы и генераторы и асинхронно перебираемые объекты.

• Метод "next()" асинронных итераторов и асинхронных генераторов возвращают промис.

◘◘◘◘ Модули.

• Работа с модулями (обычными, не динамическими) проходит на верхнем уровне (не работает на уровне блоков "{}" (например в конструкции "if")).

• Импортированные модули работают в строгом режиме.

• Модули имеют локальную область видимости.

• В модулях внешний "this" не определен (равен "undefined", а не "window").

• Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом "defer".

• Динамический импорт возвращает промис.

• Модули имеют объект "Import.meta", который содержит информацию о текущем модуле.

• Атрибут "async" тега "<script>" работает во встроенных скриптах типа модули 'type="module"'.
	
• Внешние скрипты с одинаковым атрибутом "src" запускаются только один раз.
	
• Внешний скрипт, который загружается с другого домена, требует указания заголовков "CORS".
	
• Старые браузеры не понимают атрибут 'type="module"', для них скрипт дублируется и ставится атрибут "nomodule".

======================================================================================================================================================================================================
















































































