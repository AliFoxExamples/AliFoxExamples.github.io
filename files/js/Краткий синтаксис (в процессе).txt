-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Объявление примитивов/переменных и объектов:

	var

	let

	const

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Типы данных:

	Примитивные типы данных:

		Number
		
			Infinity
			
			"0x"
			
			"0b"
			
			"0o"
		
		NaN
		
		BigInt
		
		String
		
		Boolean

		Null
		
		Undefined
		
		Symbol
		
	Особенные типы данных:
	
		Object
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы чисел:

	toFixed(<n>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы строк:

	length;
	
	charAt(<позиция>);
	
	toLowerCase();
	
	toUpperCase();
	
	trim();
	
	repeat(<количество раз>);
	
	indexOf(<подстрока>, <позиция (опционально)>);
	
	lastIndexOf(<подстрока>, <позиция (опционально));
	
	includes(<подстрока>, <позиция (опционально)>);
	
	startsWith(<подстрока>);
	
	endsWith(<подстрока>);
	
	slice(<позиция начала>, <позиция конца (опционально)>);
	
	split(<разделитель>, <количество элементов (опционально)>;
	
	substring(<позиция начала>, <позиция конца (опционально)>);
	
	substr(<позиция начала>, <длина подстроки (опционально)>);
	
	codePointAt(<позиция>);
	
	localeCompare(<строка>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы объекта "String":

	fromCodePoint(<код в формате "UTF-16">);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Преобразование типов:

	String(<аргумент>);
	
	Number(<аргумент>);
	
		parseInt(<аргумент>, <система счисления(опционально)>);
		
		parseFloat(<аргумент>, <система счисления(опционально)>);
	
	<number>.toString(<base>);
	
	Boolean();
	
	Преобразование объектов в примитивы:
	
		[Symbol.toPrimitive](hint){}
		
		toString(){}
		
		valueof(){}
		
		toJSON(){}
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Строковые операторы.

Конкатенация:

	+
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Математические операторы и операторы присваивания:

	+

	-

	*

	/

	%

	++

	--
	
	**

	=

	+=

	-=

	*=

	/=

	%=

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Инкремент. Постинкремент. Декремент. Постдекркмент:

	x++

	x--

	++x

	--x

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Операторы/Методы сравнения:

	==

	===

	!=

	!==

	>

	<

	>=

	<=
	
	isFinite(<аргумент>);
	
	isNaN(<аргумент>);
	
	Object.is(<аргумент>, <аргумент2>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Управляющий символ "\":

	\'

	\"

	\\

	\n

	\r

	\t

	\b

	\f

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Булевые значения:

	true

	false
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
Логические операторы:

	&&

	||

	!

	(<условие>) ? <выражинение для истинно>: <выражинение для ложь>;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Интерполяция строк:

	`${<имя переменной>}`

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Операторы условий, и циклов:

	if (<условие>) {<выражение>}

	else if (<условие>) {<выражение>}

	else {<выражение>}
	
	(<условие) ? <выражение для "истина"> : <выражение для "ложь">;

	switch (<имя сравниваемой переменной>) {
		case <значение>:
			<выражение>;
			break;
		default: <выражение>;
	}

	for (<начальное значение переменной>; <условие цикла>; <выражение для конца итерации>) {<выражение>}
	
		for (let <ключ> in <объект>){<выражение>}
		
		for (let <элемент> of <массив/итерируемый объект>){<выражение>}

	while (<условие цикла>) {<выражение>}

	do {<выражение>} while (<условие цикла>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Метки конструкций (label):

	<метка> : <выражение/цикл>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Операторы/Директивы - Общие:

	return;

	break;

	continue;
	
	typeof

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Функции:

	function <имя фунции> (<принимаемые параметры/аргументы>) {<тело функции>}

	let <имя переменной для функции> = function (<принимаемые параметры/аргументы>) {<тело функции>}

	(<принимаемые параметры/аргументы>)=>{<тело функции>}

	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>})();
	
	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}());
	
	!function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();
	
	+function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();
	
	let str = func`моя строка`;
	
	let func = new Function(<аргумент1>, <аргумент2>, <аргументN>, <тело функции>);
	
Встроенные методы/свойства функий:

	name;
	
	length;
	
	prototype;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Переадресация вызовов функций - "call", "apply":

	call(<контекст>, <аргуенты функции>);
	
	apply(<контекст>, <массив аргументов>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Привязка контекста вызова с помощью "bind":

	bind(<контекст>, <аргументы функции>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Дебаггер.

	debugger;
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Объекты.

	let obj = {};
	
	let obj = new Object();

Методы/свойства/операторы объектов.

	hasOwnProperty(<имя проверяемого свойства>);
	
	isPrototypeOf(<объект>);
	
	__proto__;
	
	constructor;

	delete	<объект.свойство>;
	
	<ключ/свойство> in <объект>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы главного объека "Object":

	assign(<целевой объект>, <объекты источники>);
	
	is(<аргумент>, <аргумент2>);

	keys(<целевой объект>);
	
	values(<целевой объект>);
	
	entries(<целевой объект>);
	
	fromEntries(<массив>);
	
	defineProperty(<целевой объект>, <имя свойства>, <объект с флагами (дескриптор свойства)>);
	
		<объект с флагами>:
	
			value: <значение>
			
			writable: <boolean>

			enumerable: <boolean>

			configurable: <boolean>

	getOwnPropertyDescriptor(<целевой объект>, <имя свойства>);

	defineProperties(<целевой объект>, <объект с объектами с флагами (дескрипторами свойствы)>);
	
		<объект с флагами (дескриптор свойства)>:
		
			<свойство>: <дескриптор>

	getOwnPropertyDescriptors(<целевой объект>);

	preventExtensions(<целевой объект>);

	seal(<целевой объект>);

	freeze(<целевой объект>);

	isExtensible(<целевой объект>);
	
	isSealed(<целевой объект>);

	isFrozen(<целевой объект>);
	
	create(<цель-прото>, <дескрипторы (опционально)>);

	getPrototypeOf(<целевой объект>) – возвращает свойство "[[Prototype]]" указанного целевого объекта.

	setPrototypeOf(<целевой объект>, <цель-прото>);
	
	getOwnPropertyNames(<целевой объект>);
	
	isPrototypeOf(<объект>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Массивы.

	let arr = [];
	
	let arr = new Array();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы массивов:

	length;
	
	pop();
	
	push(<элементы>);
	
	shift();
	
	unshift(<элементы>);
	
	toString();
	
	splice(<позиция>, <количество (опционально)>, <новый элемент (может быть несколько)>);
	
	slice(<позиция начала (опционально)>, <позиция конца (опционально)>);
	
	forEach(function(<элемент>, <индекс>, <сам массив>){});
	
	indexOf(<подстрока>, <позиция (опционально)>);
	
	lastIndexOf(<подстрока>, <позиция (опционально));
	
	includes(<подстрока>, <позиция (опционально)>);
	
	find(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg>);
	
	findIndex(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg>);
	
	filter(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg>);
	
	map(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg>);
	
	sort(<фукнция колбэк>);
	
	reverse();
	
	join(<соеденитель>);
	
	reduce(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>);
	
	reduceRight(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы объека "Array":

	Array.isArray(<аргумент>);
	
	Array.from(<аргумент>, <mapFn (опционально), <thisArg (опционально)>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Методы объека "Symbol":
	
	Symbol.isConcatSpreadable
	
	Symbol.iterator
	
	Symbol.asyncIterator 
	
	Symbol.toPrimitive
	
	Symbol.species
	
	Symbol.hasInstance
	
	Symbol.toStringTag

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Конструкторы. Ключевое слово "new".

	function Conctructor (){}
	
	let child = new Constructor();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Объекты "Map", "Set", "WeakMap", "WeakSet".

	Map
	
		new Map([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
		
		Методы и свойства:
			
			set(<ключ>, <значение>);
			
			get(<ключ>);
			
			has(<ключ>);
			
			delete(<ключ>);
			
			clear();
			
			size;
			
			keys();
			
			values();
			
			entries();
			
			forEach(function(<значение>, <ключ (опционально)>, <сам объект "Map" (опционально)>){});


	Set
	
		new Set([<элементы (опционально)>]);
		
		Методы и свойства:
		
			add(<значение>);
		
			delete(<значение>);
			
			has(<значение>);
			
			clear();
			
			size;
			
			keys();
		
			values();
			
			entries();
			
			forEach(function(<значение>, <значение (опционально)>, <сам объект "Set" (опционально)>){});
			
	WeakMap
	
		new WeakMap([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
		
		Методы и свойства:
			
			set(<ключ>, <значение>);
			
			get(<ключ>);
			
			has(<ключ>);
			
			delete(<ключ>);
			
	WeakSet
	
		new WeakSet([<элементы (опционально)>]);
		
		Методы и свойства:
		
			add(<значение>);
		
			delete(<значение>);
			
			has(<значение>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Деструктуризация:

	let [<переменная/свойство> = <значение по умолчанию (опционально)>, <...rest (опционально)>] = <массив/строка>;
	
	let {<переменная/свойство>: <другое имя (опционально)> = <значение по умолчанию (опционально)>, <...rest (опционально)>} = <объект>;
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Дата и время:

	Конструктор:

		let date = new Date(<аргумент/ты>);
		
		let date = new Date("<год (опционально)>-<месяц (опционально)>-<день (опционально)>-<часы (опционально)>-<минуты (опционально)>-<секунды (опционально)>-<миллисекунды (опционально)>");

	Методы объекта "Date":
	
		now();
	
	Методы созданного объекта конструктором "Date":
	
		Полчучение:

			getFullYear();
			
			getMonth();

			getDate();

			getHours();

			getMinutes();
			
			getSeconds();
			
			getMilliseconds();
			
			getDay();
			
			
			getUTCFullYear();
			
			getUTCMonth();
			
			getUTCDay();
			
			getTime();
			
			getTimezoneOffset();
		
		Установка (опциональные параметры, которые не будут переданы, останутся неизменными):
		
			setFullYear(<год>, <месяц (опционально)>, <день (опционально)>);
			
			setMonth(<месяц>, <день (опционально)>);

			setDate(<день>);

			setHours(<часы>, <минуты (опционально)>, <секунды (опционально)>, <миллисекунды (опционально)>);

			setMinutes(<минуты>, <секунды (опционально)>, <миллисекунды (опционально)>);

			setSeconds(<секунды>, <миллисекунды (опционально)>);

			setMilliseconds(<миллисекунды>);

			setTime(<миллисекунды>);
			
			
			setUTSFullYear(<год>, <месяц (опционально)>, <день (опционально)>);
			
			setUTSMonth(<месяц>, <день (опционально)>);

			setUTSDate(<день>);

			setUTSHours(<часы>, <минуты (опционально)>, <секунды (опционально)>, <миллисекунды (опционально)>);

			setUTSMinutes(<минуты>, <секунды (опционально)>, <миллисекунды (опционально)>);

			setUTSSeconds(<секунды>, <миллисекунды (опционально)>);

			setUTSMilliseconds(<миллисекунды>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Объект "JSON".

	Методы:
	
		stringify(<целевой объект>, <массив свойств или функция соответствия "function (<ключ>, <значение>)" (опционально)>, <количество пробелов, используемых для форматирования (опционально)>);
		
		parse(<целевой "JSON" объект>, <функция соответствия "function (<ключ>, <значение>)" (опционально)>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Классы.

	Виды синтаксисов объявления классов:

		"Class Declaration":

			class <имя класса> {...}

		"Class Expression":
		
			let <имя класса> class {...}

	Синтаксис создания класса на примере "Class Decaration":

		class <имя класса> {
		
			<свойство> = <значение>;
		
			constructor(<аргументы>) {...}
		
			<метод>(<аргументы>) {...}
		
			get something(<аргументы>) {...}
		
			set something(<аргументы>) {...}
		
			[Symbol.iterator]() {...}
		
			...
		}

	Ключевые слова:
	
		extends
		
		super
		
		static
		
		instanceof

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Обработка ошибок "try/catch"

	try{<тело блока>} catch(<объект ошибки>){<тело блока>} finally {<тело блока>}

		name
		
		message
		
		stack
	
	throw <объект ошибки>;
	
	new Error(<сообщение ошибки ("message")>);
	
	new SyntaxError(<сообщение ошибки ("message")>);
	
	new ReferenceError(<сообщение ошибки ("message")>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Промисы.

	let promise = new Promise(function(resolve, reject) {<тело функции исполнителя (executor)>});
	
		resolve(<value>);
		
		reject(<error>);
	
	then(<функция для "resolve">, <функция для "reject" (опционально)>);
	
	catch(<функция для "reject">);
	
	finally(<функция по умолчанию>);
	
	Методы объекта "Promise":
	
		all([<массив промисов>]);
		
		allSettled([<массив промисов>]);
		
		resolve(<значение>);
		
		reject(<объект ошибки>);
	
	async
	
	await

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Генераторы.

	function* <имя функции-генератора>(){
		yield <возвращаемое значение>
	}
	
	let <имя генератора> = <имя функции-генератора>();
	
		next(<обратно передаваемый аргумент (опционально)>);
		
		throw(<объект ошибки>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Прокси и Рефлект ("Proxy"/"Reflect").

	new Proxy(<цель>, {<ловушка>(<аргументы>)});
	
		Ловушки:
	
			get(<цель>, <свойство>, <ресивер (опционально)>)

			set(<цель>, <свойство>, <значение>, <ресивер (опционально)>)

			has(<цель>, <свойство>)

			deleteProperty(<цель>, <свойство>)

			apply(<цель>, <передаваемый "this">, <массив аргументов>)

			construct(<цель>, <массив аргументов>)

			getPrototypeOf(<цель>)

			setPrototypeOf(<цель>)

			isExtensible(<цель>)

			preventExtensions(<цель>)

			defineProperty(<цель>, <свойство>, <дескриптор>)

			getOwnPropertyDescriptor(<цель>, <свойство>)

			ownKeys(<цель>)
		
		let {proxy, revoke} = Proxy.revocable(<цель>, {<ловушка>(<аргументы>)});
	
	Методы "Reflect":
	
		Методы:
	
			get(<цель>, <свойство>, <ресивер (опционально)>);

			set(<цель>, <свойство>, <значение>, <ресивер (опционально)>);

			has(<цель>, <свойство>);

			deleteProperty(<цель>, <свойство>);

			apply(<цель>, <передаваемый "this">, <массив аргументов>);

			construct(<цель>, <массив аргументов>);

			getPrototypeOf(<цель>);

			setPrototypeOf(<цель>);

			isExtensible(<цель>);

			preventExtensions(<цель>);

			defineProperty(<цель>, <свойство>, <дескриптор>);

			getOwnPropertyDescriptor(<цель>, <свойство>);

			ownKeys(<цель>);
		
			isExtensible(<цель>);
			
			preventExtensions(<цель>);

			enumerate(<цель>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



























-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Модули.

	export {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу>}

	import {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу>} from "<ссылка из атрибута "src" тега "<script>">";

	import * as <пользовательское имя> from "<ссылка из атрибута "src" тега "<script>">";
	
	export default <функции/объекты/классы/примитивы и т.д.>
	
	export {<функции/объекты/классы/примитивы и т.д.> as default}
	
	import * as <пользовательское имя> from "<ссылка из атрибута "src" тега "<script>">";
	
	export {<функции/объекты/классы/примитивы и т.д.>} from "<ссылка из атрибута "src" тега "<script>">"
	
	export {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу> } from "<ссылка из атрибута "src" тега "<script>">"
	
	import(<модуль>).then((<объект модуля>)=><объект модуля>).catch((<объект ошибки>)=><объект ошибки>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Список Методов/Функций "JavaScript":

	alert(<передаваемое содержимое>);
	
	prompt(<текст для отображения в окне>, <содержимое по умолчанию (опционально)>);
	
	confirm(<вопрос>);
	
	setTimeout(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);
	
	clearTimeout(<идентификатор "setTimeOut">);
	
	setInterval(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);
	
	clearInterval(<идентификатор "setInterval">);
	
	eval(<исполняемый код>);
	
Методы и свойства объекта "Math":

	Math.floor();

	Math.ceil();

	Math.round();

	Math.trunc();
	
	Math.random();
	
	Math.max(<аргументы>);
	Math.min(<аргументы>);

	Math.pow(<число>, <степень>);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	





































