-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Синтаксис - операторы языка "JavaScript".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Виды синтакцсиса "JavaScript":

	1. Вложенный ("Embedded"). С помощью вложенного "JavaScript" можно добавлять скрипты в "HTML", через тег "<script>" в самом "HTML"
	документе, где сам скрипт будет распологаться в контейнере тега "<script>". Вложенный тег "<script>" может находиться в контейнере
	тега "<head>" или тега "<body>". Скрипт можно разместить в конце тега "<body>", чтобы страница загрузилась быстрее. Вид синтаксиса
	вложенного "JavaScript" соответствует синтаксису файла внешнего "JavaScript".

	Пример использования вложенного "JavaScript":

		<head>	
			<script type="text/javascript">
				alert("Hello");
			</script>
		</head>
		
		или
		
		<body>	
			<script type="text/javascript">
				alert("Hello");
			</script>
		</body>
		
	2. Внешний ("External"). С помощью внешнего "JavaScript"  можно добавлять скрипты в "HTML", через внешний "JavaScript" документ с
	расширением ".js". Этот документ подключается в документу "HTML" через тег "<script>", который обязательно должен распологаться
	в контейнере тега "<head>". В теге "<script>" будет обязательный атрибут "src="..."", где на месте "..." - будет сама "URL" адрес
	на документ (относительный или абсолютный).

	Пример подключения внешнего "CSS":

		<head>	
			<script src="myscript.js"></script>
		</head>
		
	Если указан атрибут "src", то содержимое контейнера тега игнорируется.
	
	Существуют два атрибута для тега "<script>" "defer" и "async". Подробнее в синтаксисе "HTML" - "Синтаксис - Атрибуты".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Правила языка "JavaScript":

	1.	Если при объявлении переменной (тестовой) были использованы кавычки типа """, то внутри самих кавычек, данный тип не может
	использоваться, а могут использоваться только типа "'", так как внутри и снаружи не должен быть использован один и тот же тип
	кавычек. Или же наоборот, если при объявлении переменной (тестовой) были использованы кавычки типа "'", то внутри самих кавычек,
	данный тип не может использоваться, а могут использоваться только типа """, так как внутри и снаружи не должен быть использован один и
	тот же тип кавычек.
		
	Например:

		<script>
			let x = "'Джон'";
		</script>
		
		или
		
		<script>
			let x = '"Джон"';
		</script>
		
	Если все же необходимо использовать кавычки такого же типа, что и снаружи, то перед кавычками, внутри внешних кавычек следует поставить
	управляющий символ "\".

	Например:

		<script>
			let x = '\'Джон\'';
		</script>
		
		или
		
		<script>
			let x = "\"Джон\"";
		</script>
		
	Все примеры использования управляющего символа "\" приведены ниже в пункте "Примеры использования управляющего символа "\".

	Так же если необходимо отобразить управляющий символ "\", то перед ним нужно так же поставить управляющий символ "\":

	Например:

		<script>
			document.write=("Вывод символа \\ на экран");
		</script>
		
		
		
	2. Директива ""use strict";". Данная директива введена и спользуется для того, чтобы активировать "строгий режим" кода (перевод кода режим полного соответствия
	современного стандарта синтаксиса "JavaScript". Некоторые библиотеки, которые написаны без ""use strict";", не всегда корректно работают, если
	вызывающий код содержит ""use strict";". Некоторые функции языка, такие как «классы» и «модули», автоматически включают строгий режим.
	
		Ообенности строгого режима:
		
			1. В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.
			
			2. В строгом режиме вызов "this" без объекта = "undefined".
			
			3. В строгом режиме попытка присвоения свойства примитиву (через точку ".") вернет ошибку.
		
	3.  Рекомендуется ставить точку с запятой после выражения (на усмотрение), если после нее идет самовызываемая функция ("IIFE").
	
	4. Лексическое окружение существует для любых блоков кода "{...}" ("if", "for", "function" и т.д.).
	
	5. Можно объединять/группировать блоки кода в фигурные скобки, для изоляции переменных в "локальной области видимости":
	
		{
			// блок кода
			let message = "Hello";

			alert( message );
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объявление переменных.

Переменные в "JavaScript" могут объявляться с помощью ключевых слов "var", "let", "const". "var" является устаревшим. Рекомендуется использовать "let" или "const".
При объявлении переменной с помощью ключевого слова "let", значение переменной можно изменять с дальнейшем, а переобъявлять имя переменной нельзя.
При объявлении переменной с помощью ключевого слова "const",  в дальнейшем нельзя изменять значение переменной, а так же переобъявлять имя переменной. Исключением же является
изменение содержимого массива или объекта, созданного с помощью ключевого слова "const". Содержимое таких массивов и объектов изменять можно.

Синтаксис объявления переменной на примере "let":

	let <имя_переменной> = <значение>

		Ключевое слово для объявления переменных, где на месте "<имя_переменной>" - будет имя переменной, а на месте "<значение>" будет
		значение переменной. "JavaScript" чувствителен к регистру текста, так что символ "x" нижнего регистра не равен
		символу "X" верхнего регистра (то есть выражения "var x = 10;" и "var X = 10;" не одно и тоже).
		
		Первым символом имени переменной могут быть буквы или символы "_", "$". Последующими символами могут быть буквы, цифры
		символы "_", "$".
		Имена переменных не могут начинаться с чисел, и не могут содержать в себе пробелы и математические операторы
		("+", "-", "*" и тд.).
		В именах переменных так же не могут присутствовать специальные символы "#", "%" и тд.
		Имена переменных содержащие несколько слов принято писать сначала со строчной буквы, а затем с заглавной. Например:
		
			let userName = "Alex";
			
		В именах переменных не могут содержаться следующие зарезервированные в "JavaScript" слова:
		
			abstract
			boolean
			break
			byte
			case
			catch
			char
			class
			const
			continue
			debugger
			default
			delete
			do
			double	else
			enum
			export
			extends
			false
			final
			finally
			float
			for
			function
			goto
			if
			implements
			import
			in	instanceof
			int
			interface
			long
			native
			new
			null
			package
			private
			protected
			public
			return
			short
			static
			super	switch
			synchronized
			this
			throw
			throws
			transient
			true
			try
			typeof
			var
			void
			volatile
			while
			with

		Способы объявления переменной:
		
			1. Объявление и присваивание переменной в одной строке:
			
				let x = 1;
				
			2. Объявление и присваивание переменной в разных строках:
			
				let x;
				x = 1;
				
			3. Объявление и присваивание нескольких переменных в нескольких строках:
			
				let x;
				let y;
				x = 1;
				y = 2;
				
			4. Объявление нескольких переменных в одной строке, и присваивание нескольких переменных:
			
				let x, y;
				x = 1; y = 2;
				
			5. Объявление и присваивание нескольких переменных в одной строке:
			
				let x = 1, y = 2;
				
				Для удобства читаемоси можно разбить по строкам:
				
					let x = 1,
						y = 2;
						
Константы в верхнем регистре. Константы записанные в верхнем регистре, являются общепринятымы "жестко закодированными" переменными (когда значение известно до выполнения
скрипта и записывается непосредственно в код). Например:

	const COLOR_ORANGE = "#FF7F00";
	
	К примеру следующий пример не требует букв в верхнем регистре, так как значение переменной не объявляется изначально, а зависит от результата функции "someCode()".
	
	const age = someCode(BIRTHDAY);
	
• Особенности переменной объявленной с помощью "var":

	1. Для "var" не существует блочной области видимости. Область видимости переменных "var" ограничивается либо функцией, либо, если переменная глобальная, то скриптом.
	Такие переменные доступны за пределами блока.
	
	2. Объявления переменных "var" обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной). Объявления переменных "всплывают",
	но присваивания значений – нет.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типы данных.

Примитивные типы данных:

	1. "Number"	-	(число). Числовой тип данных  представляет как целочисленные значения, так и числа с плавающей точкой.

		"Infinity". Представляет собой математическую бесконечность "∞". Это особое значение, которое больше любого числа. Мы можем получить его в результате деления на ноль:

			alert( 1 / 0 );
			
			Или задать его явно:

				alert( Infinity );
				
		Для проверки является ли аргуент обычным числом, т.е. не "NaN"/"Infinity"/"-Infinity":
		
			isFinite(<аргумент>);
			
			Примечание! Пустая строка интерпретируется как 0 во всех числовых функциях, включая "isFinite()".

	2. "NaN"	-	("Not a Number" - не число). Означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
	
		Для проверки является ли аргумент "NaN":
		
			isNaN(<аргумент>);

		alert( "не число" / 2 );
		
		Любая операция с "NaN" возвращает "NaN".

	3. "BigInt". Тип данных для хранения больших целых чисел. Чтобы создать значение типа "BigInt", необходимо добавить "n" в конец числового литерала:

		let bigInt = 1234567890123456789012345678901234567890n;
		
		Примечание. В данный момент "BigInt" поддерживается только в браузерах "Firefox" и "Chrome", но не поддерживается в "Safari"/"IE"/"Edge".

	4. "String"	-	(строка). 
	
	5. "Boolean"	-	(булевый тип). "true" - истинно, "false" - ложь.
	
	6. "Null"	-	(ничего).
	
	7. "Undefined"	-	(не определено). Данный тип данных означает, что значение не было присвоено.
	
	8. "Symbol".
	
Особенные типы данных:

	9. "Object".
		
• Оператор "typeof". Возвращает тип аргумента. Примеры:

	typeof undefined // "undefined"

	typeof 0 // "number"

	typeof 10n // "bigint"

	typeof true // "boolean"

	typeof "foo" // "string"

	typeof Symbol("id") // "symbol"

	typeof Math // "object" 

	typeof null // "object" 
	
		Результатом вызова "typeof null" является "object". Это неверно.
		Это официально признанная ошибка в "typeof", сохранённая для совместимости.
		Конечно, "null" не является объектом. Это специальное значение с отдельным типом. Повторимся, это ошибка в языке.

	typeof alert // "function"
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Числа.

Способы записи числа:

	Десятичные числа:

		Явное указание числа:

			let billion = 1000000000;
			
		Использование ключевой буквы "e":

			let billion = 1e9;
			
				Число после буквы "e" указывает на количество нулей после нее. Другими словами, "e" производит операцию умножения числа на 1 с указанным количеством нулей.
			
		Чтобы указать число с плавающей с множеством нулей, можно использовать отрицательное число после буквы "e":

			let ms = 0.000001;
			
			let ms = 1e-6;	//	шесть нулей, слева от 1.
			
	Шестнадцатеричные числа:

		Указание символов "0x", после чего идет само число в данном формате:
		
			console.log( 0xff );	//	255
			
			console.log( 0xFF );	//	255 (тоже самое, регистр не имеет значения).
			
	Восьмеричные, и двоичные числа:

		Указание символов "0b" (для двоичной системы), и "0o" (для восьмеричной системы) после чего идет само число в данном формате:
		
			let a = 0b11111111;	//	бинарная форма записи числа 255.
			let b = 0o377;	//	восьмеричная форма записи числа 255.

			alert( a == b );	//	true, с двух сторон число 255.
		
• Потеря точности.

Решение проблемы с "0.1 + 0.2 != 0.3":

	let sum = 0.1 + 0.2;
	console.log( sum.toFixed(2) );	//	0.30
	
Потеря точности с длинным числом:

	console.log( 9999999999999999 );	//	покажет 10000000000000000.
	
• Методы чисел:

	toFixed(<n>);

		Округляет число до "<n>" знаков после запятой и возвращает строковое представление результата.
		Результатом "toFixed()" является строка. Пример:
		
			let num = 12.34;
			
			console.log( num.toFixed(1) );	//	"12.3"
			
		Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:
		
			let num = 12.34;

			console.log( num.toFixed(5) );	//	"12.34000", добавлены нули, чтобы получить 5 знаков после запятой.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Строки.

Строки в "JavaScript" кодируются в формате "UTF-16".
Способы записи строк:

	Кавычки:
	
		let single = 'одинарные кавычки';
		let double = "двойные кавычки";

		let backticks = `обратные кавычки`;
		
		Текст с обратными кавычками можно записывать в нескольких строках:
		
			let guestList = `Guests:
			 * John
			 * Pete
			 * Mary
			`;
			
		С помощью обратных кавычек можно интерполяцию строк. Подробнее в главе "Интерполяция строк".
		С помощью обратных кавычек также можно пользоваться функцией шаблонизации, подробнее в главе "Функции".
		
• Спецсимволы. Подробнее в главе "Примеры использования управляющего символа".

У строк можно вызвать свойство "length", которое вернет длину строки (количество символов):

	console.log( "abc".length );	//	3
	
У строк можно получить определенный символ с помощью квадратных скобок "[<позиция>]" или с помощью метода "charAt(<позиция>)":

	console.log( "Hello"[0] )	//	H
	console.log( "Hello".charAt(0) )
	
	Разницей этих двух вариантов получения символа в указанной позиции в том, что при использовании квадратных скобок "[<позиция>]", если в указанной позиции нет символа,
	то она вернет "undefined", а при использовании метода "charAt()" она вернет пустую строку.
	
Так же можно перебрать строку с помощью цикла "for of":

	for (let char of "Hello") {
		console.log(char);	//	H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.).
	}
	
Изменение регистра:

	Верхний регистр:
	
		console.log( "hello".toUpperCase() )	//	HELLO
		
	Нижний регистр:
	
		console.log( "HELLO".toLowerCase() )	//	hello
		
	Если мы захотим перевести в нижний регистр какой-то конкретный символ:

		console.log( 'Interface'[0].toLowerCase() );	//	'i'.
		
Удаление пробелов по сторонам строки. Для этого есть метод "trim()":

	console.log( " hello ".trim() );	//	hello

Повторение строки. У строки можно вызвать метод "repeat(<количество раз>)", который будет повторять строку в указанное количество раз.

• Поиск позиции подстроки.

Метод - "indexOf(<подстрока>, <позиция (опционально)>)". Он ищет подстроку в строке, начиная с указанной позиции,
и возвращает позицию, на которой располагается совпадение, либо "-1" при отсутствии совпадений:

	let str = 'Widget with id';
	
	console.log( str.indexOf('Widget') );	//	0, потому что подстрока 'Widget' найдена в начале.

	console.log( str.indexOf('widget') );	//	-1, совпадений нет, поиск чувствителен к регистру.

	console.log( str.indexOf("id") );	//	1, подстрока "id" найдена на позиции 1 (..idget with id).
	
	Необязательный второй аргумент позволяет начать поиск с определённой позиции.
	Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

		let str = 'Widget with id';

		console.log( str.indexOf('id', 2) )	//	12
		
Метод - "lastIndexOf(<подстрока>, <позиция (опционально))" схож с методом выше, но он ищет с конца строки к её началу.
Он используется тогда, когда нужно получить самое последнее вхождение - перед концом строки или начинающееся до (включительно) определённой позиции.

Метод - "includes(<подстрока>, <позиция (опционально)>)". Данный метод возвращает "true", если в строке есть подстрока, либо "false", если нет. Пример:

	console.log( "Widget with id".includes("Widget") );	//	true

	console.log( "Hello".includes("Bye") );	//	false
	
	В методе также есть необязательный второй аргумент, который позволяет начать поиск с определённой позиции.
	
Методы "startsWith(<подстрока>)" и "endsWith(<подстрока>)" проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

	console.log( "Widget".startsWith("Wid") ); //	true, "Wid" — начало "Widget".

	console.log( "Widget".endsWith("get") ); //	true, "get" — окончание "Widget".
	
• Получение подстроки.

Метод "slice(<позиция начала>, <позиция конца (опционально)>)" возвращает часть строки от начальной позиции до (не включая) конечной позиции.
Если не указана конечная позиция, то будет возвращена подстрока от начальной позиции до самого конца. Примеры:

	let str = "stringify";

	console.log( str.slice(0, 5) );	//	'strin', символы от 0 до 5 (не включая 5).

	console.log( str.slice(0, 1) );	//	's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0.

	console.log( str.slice(2) );	//	ringify, с позиции 2 и до конца.
	
	Также для позиций начала и конца можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:
	
		let str = "stringify";

		// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа.
		console.log( str.slice(-4, -1) ); // gif
		
Метод "split(<разделитель>, <количество элементов (опционально)>" разбивает строку на массив, по заданному разделителю и на заданное количество
элементов (опционально). Вызов данного метода с пустыми аргументами разбил бы строку на массив букв. Пример:

	'Вася, Петя, Маша, Саша'.split(', ', 2);

	alert(arr);	//	Вася, Петя

Метод "substring(<позиция начала>, <позиция конца (опционально)>)" возвращает часть строки между начальной и конечной позицией.
Данный метод схож с методом выше ("slice()"), за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними:

	let str = "stringify";

	// для substring эти два примера — одинаковы
	console.log( str.substring(2, 6) );	//	"ring".
	console.log( str.substring(6, 2) ); //	"ring".

	// …но не для slice:
	console.log( str.slice(2, 6) ); //	"ring" (то же самое).
	console.log( str.slice(6, 2) ); //	"" (пустая строка).
	
	В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.
	
Метод "substr(<позиция начала>, <длина подстроки (опционально)>)" возвращает часть строки он начальной позиции на указанную длину:

	let str = "stringify";
	
	//	ring, получаем 4 символа, начиная с позиции 2.
	console.log( str.substr(2, 4) );

	Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

		let str = "stringify";
		
		//	gi, получаем 2 символа, начиная с позиции 4 с конца строки.
		console.log( str.substr(-4, 2) );
		
	У данного метода есть недостаток - он может не поддерживаться в средах отличных от браузера.
	
• Коды символов.

Метод "codePointAt(<позиция>)" возвращает код символа в формате "UTF-16" на указанной позиции:

	// одна и та же буква в нижнем и верхнем регистре будет иметь разные коды.
	console.log( "z".codePointAt(0) ); //	122
	console.log( "Z".codePointAt(0) ); //	90
	
	Методу "codePointAt()" существует обратный метод у объекта "String" - "fromCodePoint(<код в формате "UTF-16">)", который возвращает символ по его коду:
	
		console.log( String.fromCodePoint(90) ); //	Z
		
		Также можно добавлять юникодные символы по их кодам, используя "\u" с шестнадцатеричным кодом символа:
		
			// "90" — это "5a" в шестнадцатеричной системе счисления.
			console.log( '\u005a' ); //	Z
			
	Оба этих метода умеют работать с суррогатными парами.

Метод "localeCompare(<строка>)" возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

	1. Отрицательное число, если строка, у которой был вызван этот метод меньше чем "<строка>".

	2. Положительное число, если строка, у которой был вызван этот метод больше чем "<строка>"..

	3. "0", если строки равны.
	
	Пример:
	
		console.log( 'Österreich'.localeCompare('Zealand') ); // -1

	У этого метода есть два дополнительных аргумента, которые указаны в документации.
	Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв.
	Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

• Суррогатные пары.

Многие символы возможно записать одним 16-битным словом: это и буквы большинства европейских языков, и числа, и даже многие иероглифы. Но 16 битов — это 65536 комбинаций,
так что на все символы этого, разумеется, не хватит. Поэтому редкие символы записываются двумя 16-битными словами — это также называется "суррогатная пара".
Длина таких строк ("length") — 2:

	console.log( '𝒳'.length ); //	2

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Преобразование типов.

Строковое преобразование:

	String(<аргумент>);
	
Численное преобразование:

	Number(<аргумент>);

		undefined	-	преобразуется в "NaN".
		
		null	-	преобразуется в "0".

		true / false	-	преобразуется в "1 / 0".

		string	-	пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то "0", иначе из непустой строки "считывается число".
		При ошибке результат "NaN".
		
	<number>.toString(<base>);
	
		Данный метод возвращает строковое представление числа "<number>" в системе счисления "<base>".
		"<base>" может варьироваться от 2 до 36 (по умолчанию 10). Пример:

			let num = 255;

			console.log( num.toString(16) );	//	ff
			console.log( num.toString(2) );	//	11111111
			
		Чтобы использовать данный метод непосредственно на числе, нужно указать метод с двумя точками:
		
			console.log( 123456..toString(36) );	//	2n9c
			
		Если мы поставим одну точку, тогда это будет ошибкой, поскольку синтаксис "JavaScript" предполагает,
		что после первой точки начинается десятичная часть числа. А если поставить две точки, то "JavaScript" понимает,
		что десятичная часть отсутствует, и начинается метод.

		Также можно записать как:
		
			console.log( (123456).toString(36) )
			
	Для изъятия числа из строки (первое встречаемое число в строке) используют функции "parseInt(<аргумент>, <система счисления(опционально)>)" - для целых чисел,
	и "parseFloat(<аргумент>, <система счисления(опционально)>)" - для чисел с плавающей точкой. Примеры:
	
		console.log( parseInt('100px') );	//	100
		console.log( parseFloat('12.5em') );	//	12.5

		console.log( parseInt('12.3') );	//	12, вернётся только целая часть.
		console.log( parseFloat('12.3.4') );	//	12.3, произойдёт остановка чтения на второй точке.
		
		Функция "parseInt()" имеет необязательный второй параметр. Он определяет систему счисления, таким образом "parseInt()" может также читать строки
		с шестнадцатеричными числами, двоичными числами и т.д. (максимально до 36-ричными числами):
		
			console.log( parseInt('0xff', 16) );	//	255
			console.log( parseInt('ff', 16) );	//	255, без 0x тоже работает

			console.log( parseInt('2n9c', 36) );	//	123456
	
Логическое преобразование. Значения, которые интуитивно "пустые", вроде "0", пустой строки, "null", "undefined" и "NaN", становятся "false".
Все остальные значения становятся "true". Пример:

	console.log ( Boolean(1) ); // true
	
	console.log ( Boolean(0) ); // false

	console.log ( Boolean("Привет!") ); // true

	console.log ( Boolean("") ); // false
	
Некоторые языки (к примеру, "PHP") воспринимают строку "0" как "false". Но в "JavaScript", если строка не пустая, то она всегда "true". Пример:

	console.log ( Boolean("0") ); // true
	
	console.log ( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)

• Строковые операторы:

	+	-	оператор соединения (конкатенации) значений. Используется в скобках функций (методов) для соединения значений. Например:
	
		let string1 = "Java";
		let string2 = "Script";
		document.write(string1 + string2); // JavaScript
			
		console.log ( 1 + '2' ); // '12'
		
		console.log ( '1' + 2 ); // '12'
		
Примеры с преобразованиями типов данных:

	"" + 1 + 0 // "10"
	
	"" - 1 + 0 // -1

	true + false // 1

	6 / "3" // 2

	"2" * "3" // 6

	4 + 5 + "px" // "9px"

	"$" + 4 + 5 // "$45"

	"4" - 2 // 2

	"4px" - 2 // NaN

	7 / 0 // Infinity

	" -9  " + 5 // " -9  5"

	" -9  " - 5 // -14

	null + 1 // 1 // (5)

	undefined + 1 // NaN

	" \t \n" - 2 // -2
	
		Пробельные символы, такие как "\t" и "\n" по краям строки игнорируются при преобразовании в число,
		так что строка "\t" "\n", аналогично пустой строке, становится "0" после численного преобразования.
		
• Примитив как объект.

Для примитивов создается "объект-обертка" на время вызова метода у него, а затем удалятся.
Каждый примитив имеет свой собственный "объект-обёртку", которые называются: "String", "Number", "Boolean" и "Symbol".
Таким образом, они имеют разный набор методов.
К примеру, существует метод "str.toUpperCase()", который возвращает строку в верхнем регистре:

		let str = "Привет";

		console.log( str.toUpperCase() );	//	ПРИВЕТ
		
		Что происходит во время вызова метода "toUpperCase" у строки:
		
			1. Строка "str" – примитив. В момент обращения к его свойству, создаётся специальный объект,
			который знает значение строки и имеет такие полезные методы, как "toUpperCase()".
			
			2. Этот метод запускается и возвращает новую строку.
			
			3. Специальный объект удаляется, оставляя только примитив "str".
			
Для чисел так же создаются "объекты-обертки", например метод "toFixed()":

	let n = 1.23456;

	console.log( n.toFixed(2) );	//	1.23

Использование конструкторов для "String", "Number", "Boolean" - в главе "Конструкторы".

"null"/"undefined" не имеют методов.

Особенные примитивы "null" и "undefined" являются исключениями. У них нет соответствующих "объектов-обёрток", и они не имеют никаких методов.
Попытка доступа к свойствам такого значения возвратит ошибку:

	console.log(null.test);	//	ошибка.
	
Присвоение свойства примитиву. 
	
	Пример:
	
		let str = "Привет";

		str.test = 5;

		console.log(str.test);
		
	В зависимости от того, используется ли строгий режим ('"use strict"') или нет, результат может быть:
	
	1. undefined	-	(без strict).
	
	2. Ошибка	-	(strict mode).
	
	В момент обращения к свойству "str" создаётся "объект-обёртка". В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
	Без строгого режима, операция продолжается, объект получает свойство "test", но после этого он удаляется,
	так что на последней линии "str" больше не имеет свойства "test".		

• Преобразование объектов в примитивы.

1. Все объекты в логическом контексте являются "true". Существуют лишь их численные и строковые преобразования.

2. Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции.
Например, объекты "Date"  могут вычитаться, и результатом "date1 - date2" будет временной отрезок между двумя датами.

3. Что касается строковых преобразований – они обычно происходят, когда мы выводим объект "alert(obj)", а также в других случаях, когда объект используется как строка.
	
Три варианта преобразования объектов к примитивам (три хинта):

	1. Для преобразования объекта к строке, когда операция ожидает получить строку, например "alert()" ("string"):
			
		alert(obj);	//	Вывод.

		anotherObj[obj] = 123;	//	Используем объект в качестве имени свойства.
		
	2. Для преобразования объекта к числу, в случае математических операций ("number"):
		
		let num = Number(obj);	//	Явное преобразование

		//	Математическое (исключая бинарный оператор "+").
		let n = +obj; // Унарный плюс.
		let delta = date1 - date2;
		
		let greater = user1 > user2;	//	Сравнения больше/меньше.
		
	3. Вариант по умолчанию ("default"):
		
		let total = car1 + car2;	//	бинарный плюс.

		if (user == 1) { ... };	//	obj == string/number/symbol
		
В процессе преобразования движок "JavaScript" пытается найти и вызвать три следующих метода объекта:

	1. Вызывает "obj[Symbol.toPrimitive](hint)" – метод с символьным ключом "[Symbol.toPrimitive]" (системный символ), если такой метод существует, и передаёт ему хинт.
	
	2. Иначе, если хинт равен "string" пытается вызвать "obj.toString()", а если его нет, то "obj.valueOf()", если он существует.
	
	3. В случае, если хинт равен "number" или "default" пытается вызвать "obj.valueOf()", а если его нет, то "obj.toString()", если он существует.
	
Метод "[Symbol.toPrimitive]". Метод с таким названием (если есть) используется для всех преобразований:

	obj[Symbol.toPrimitive] = function(hint) {
		//	должен вернуть примитивное значение
		//	hint равно чему-то одному из: "string", "number" или "default"
	};
	
Пример использования метода "[Symbol.toPrimitive]":

	let user = {
		name: "John",
		money: 1000,

		[Symbol.toPrimitive](hint) {
			alert(`hint: ${hint}`);
			return hint == "string" ? `{name: "${this.name}"}` : this.money;
		}
	};

	//	демонстрация результатов преобразований:
	alert(user);	//	hint: string -> {name: "John"}
	alert(+user);	//	hint: number -> 1000
	alert(user + 500);	//	hint: default -> 1500
	
	В данном примере в ручную переписывается/задается код для метода "[Symbol.toPrimitive]".
	
Методы "toString" и "valueOf". Если нет метода "[Symbol.toPrimitive]", движок "JavaScript" пытается найти эти методы и вызвать их следующим образом:

	1. toString -> valueOf для хинта со значением «string».
	
	2. valueOf -> toString – в ином случае.
	
Пример использования методов "toString" и "valueOf":

	let user = {
		name: "John",
		money: 1000,

		//	для хинта равного "string"
		toString() {
			return `{name: "${this.name}"}`;
		},

		//	для хинта равного "number" или "default"
		valueOf() {
			return this.money;
		}

	};

	alert(user);	//	toString -> {name: "John"}
	alert(+user);	//	valueOf -> 1000
	alert(user + 500);	//	valueOf -> 1500
	
В отсутствие методов "[Symbol.toPrimitive]", "valueOf" и "toString" обработает все случаи преобразований к примитивам.
Важно понимать, что все описанные методы для преобразований объектов не обязаны возвращать именно требуемый "хинтом" тип примитива.
Нет обязательного требования, чтобы "toString()" возвращал именно строку, или чтобы метод "[Symbol.toPrimitive]" возвращал именно число для хинта "number".
Единственное обязательное требование: методы должны возвращать примитив, а не объект.
По историческим причинам, если "toString" или "valueOf" вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало).
Метод "[Symbol.toPrimitive]", напротив, обязан возвращать примитив, иначе будет ошибка.
Обычно для встроенных объектов хинт "default" обрабатывается так же, как "number".

Итого. Алгоритм преобразований к примитивам следующий:

	1. Сначала вызывается метод "obj[Symbol.toPrimitive](hint)", если он существует.
	
	2. Иначе, если хинт равен "string",	происходит попытка вызвать "obj.toString()", затем "obj.valueOf()", смотря что есть.
	
	3. Иначе, если хинт равен "number" или "default", происходит попытка вызвать "obj.valueOf()", затем "obj.toString()", смотря что есть.

На практике довольно часто достаточно реализовать только "obj.toString()" как "универсальный" метод для всех типов преобразований,
возвращающий "читаемое" представление объекта, достаточное для логирования или отладки.

Для преобразоания объектов в примитивы, методы переписываются/задаются вручную. Если есть универсальный метод "[Symbol.toPrimitive]", то он используется для всех преобразований.
Методы "toString" и "valueOf" устаревшие способы преобразования.

• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями:

	function fn() {}
	fn[Symbol.toPrimitive] = function(){ return 20 }

• Преобразование объектов в "JSON". У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта
в "JSON" (вызов метода "stringify" у "JSON" для объекта):

	let room = {
		number: 23,
		toJSON() {
			return this.number;
		}
	};
	
	JSON.stringify(room);	//	"23".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Термины "Операнд", "Унарный" и "Бинарный".

"Операнд"	-	то, к чему применяется оператор. Например, в умножении "5 * 2" есть два операнда: левый операнд равен "5", а правый операнд равен "2".
Иногда их называют "аргументами" вместо "операндов".

"Унарным" называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный.
Сам оператор ставится непосредственно перед операндой. Пример:

	let x = 1;

	x = -x;

	console.log ( x ); // -1, применили унарный минус

"Бинарным" называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

	let x = 1, y = 3;
	
	console.log ( y - x ); // 2, бинарный минус

Преобразование к числу, "унарный плюс" ("+"). Плюс "+" существует в двух формах: бинарной, и унарной.
Унарный, то есть применённый к одному значению, плюс "+" ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число. Пример:

	// Преобразует нечисла в числа
	
	console.log ( +"12"); // 12
	
	console.log ( +true ); // 1

	console.log ( +"" );   // 0

Приоритет операторов.

	+	-	"унарный плюс", приоритет - "16".
	-	-	"унарный минус", приоритет - "16".
	*	-	"умножение", приоритет - "14".
	/	-	"деление", приоритет - "14".
	+	-	"сложение", приоритет - "13".
	-	-	"вычитание", приоритет - "13".
	…	…	…
	=	-	"присваивание", приоритет - "3".
	…	…	…
	
	Так как "унарный плюс" имеет приоритет "16", который выше, чем "13" у "сложения" ("бинарный плюс"), то в выражении "+apples + +oranges" сначала выполнятся унарные плюсы,
	а затем сложение.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Математические операторы "JavaScript":

	+	-	сложение.

	-	-	вычитание.

	*	-	умножение.

	/	-	деление.

	%	-	деление по модулю.
	
	**	-	возведение в степень. Например:
	
		console.log ( 2 ** 2 ); // 4  (2 * 2);
		
		console.log ( 2 ** 3 ); // 8  (2 * 2 * 2);
	
		console.log ( 2 ** 4 ); // 16 (2 * 2 * 2 * 2);
		
		console.log ( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
		
		console.log ( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)

	++	-	инкремент.

	--	-	декремент.	
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Инкремент. Постинкремент/Декремент/Постдекркмент.

Постфиксная форма:

		Постинкремент (var++):

			var a = 0; b = 10;
			var a = b++;
			
			Результат:
			
				a = 10; b = 11;
				
		Постдекремент (var--):

			var a = 0; b = 10;
			var a = b--;
			
			Результат:
			
				a = 10; b = 9;
				
		Постфиксная форма сначала возвращает старое значение, затем изменяет текущее.

Префиксная форма:
		
		Преинкремент (++var):

			var a = 0; b = 10;
			var a = ++b;
			
			Результат:
			
				a = 11; b = 11;
			
		Предекремент (--var):

			var a = 0; b = 10;
			var a = --b;
			
			Результат:
			
				a = 9; b = 9;
				
		Префиксная форма возвращает новое измененное значение.

 Инкремент/декремент можно применить только к имени переменной. Попытка использовать его на значении, типа "5++", приведёт к ошибке.			
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Побитовые операторы:

	AND	-	"и" ("&").
	
	OR	-	"или" ("|").
	
	XOR	-	"побитовое исключающее" или ("^").
	
	NOT	-	"не" ("~").
	
	LEFT SHIFT	-	"левый сдвиг" ("<<").
	
	RIGHT SHIFT	-	"правый сдвиг" (">>").
	
	ZERO-FILL RIGHT SHIFT	-	"правый сдвиг с заполнением нулями" (">>>").
	
	Подробнее с статье "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
◘ Операторы присваивания:

	=	-	x = y
	
	+=	-	x = x + y
	
	-=	-	x = x - y
	
	*=	-	x = x * y
	
	/=	-	x = x / y
	
	%=	-	x = x % y
	
Так же можно использовать несколько операторов присваивания в одно строке:

	x -= y += 9;
	
Так же существует оператор "запятая". Редко используется и является одним из самых необычных. Оператор "запятая" предоставляет возможность вычислять несколько выражений,
разделяя их запятой ",". Каждое выражение выполняется, но возвращается результат только последнего. Например:

	let a = (1 + 2, 3 + 4);

	console.log ( a ); // 7 (результат 3 + 4)
	
	Оператор "," имеет очень низкий приоритет, ниже чем у "=", поэтому скобки важны в приведённом выше примере.
	
Оператор "=" возвращает значение. Вызов "x = value" записывает "value" в "x" и возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:

	let a = 1;
	let b = 2;
	let c = 3 - (a = b + 1);
	console.log( a ); // 3
	console.log( c ); // 0

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Операторы/Методы сравнения.

Условие (возвратит "true", если сравниваемые значения соответствуют начальному условию, возвратит "false",
если сравниваемые значения не соответствуют начальному условию):
	
	==	-	равняется (возвратит "true", если сравниваемые значения равны, возвратит "false", если сравниваемые значение не равны).
	
	===	-	идентично (равно и одинакового типа (строго равны)).
	
	!=	-	не равно.
	
	!==	-	не идентично (не равно и не одинакового типа).
	
	>	-	больше чем.
	
	<	-	меньше чем.
	
	>=	-	больше или равно.
	
	<=	-	меньше или равно.
	
Сравнения "null" и "0":

	console.log ( null > 0 );  // false
	
	console.log ( null == 0 ); // false
	
		Для нестрогого равенства "==" значений "undefined" и "null" действует особое правило: эти значения ни к чему не приводятся,
		они равны друг другу и не равны ничему другому.

	console.log ( null >= 0 ); // true
	
Существует специальный метод "is(<аргумент>, <аргумент2>)" у главного объекта "Object", который сравнивает значения примерно как "===", но более надёжен в двух особых ситуациях:

	Работает с "NaN":
	
		console.log( Object.is(NaN, NaN) )	//	true
		
	Значения "0" и "-0" разные:
	
		console.log( Object.is(0, -0) )	//	false
		
		Это редко используется, но технически эти значения разные.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Примеры использования управляющего символа "\":

	\'	-	одинарная кавычка.
	
	\"	-	двойные кавычки.
	
	\\	-	обратный слэш.
	
	\n	-	перевод строки.
	
	\t	-	табуляция.
	
	\r	-	возврат каретки, самостоятельно не используется. В текстовых файлах "Windows" для перевода строки используется комбинация символов "\r\n".

	\b, \f, \v	-	"Backspace", "Form Feed" и "Vertical Tab" — оставлены для обратной совместимости, сейчас не используются.

	\xXX	-	символ с шестнадцатеричным юникодным кодом "XX", например, '\x7A' — то же самое, что 'z'.

	\uXXXX	-	символ в кодировке "UTF-16" с шестнадцатеричным кодом "XXXX", например, "\u00A9" — юникодное представление знака копирайта - "©".
	Код должен состоять ровно из 4 шестнадцатеричных цифр.

	\u{X…XXXXXX}	-	(от 1 до 6 шестнадцатеричных цифр)	Символ в кодировке "UTF-32" с шестнадцатеричным кодом от "U+0000" до "U+10FFFF".
	Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Булевые значения.

Например:
	
	let isActive = true;
	let isHoliday = false;
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Логические операторы.

&&	-	оператор "И" (возвращает "true", если обе операнды истинны). Оператор "И" находит первое ложное значение, и выполняет следующие действия:

		-	Вычисляет операнды слева направо.
		
		-	Каждый операнд преобразует в логическое значение. Если результат = "false", то останавливается и возвращает исходное значение этого операнда.

		-	Если все операнды были истинными, возвращается последний.

	Другими словами, "И" возвращает первое ложное значение, или последнее, если ничего не найдено.

	Вышеуказанные правила схожи с поведением "ИЛИ". Разница в том, что "И" возвращает первое ложное значение, а "ИЛИ" –  первое истинное. Например:
	
		console.log(1 && 0);	//	1
		console.log(1 && 5);	// 5
		console.log(5 && 2 && 3);	// 3
		console.log(null && 1);	//	null
		console.log( 1 && 2 && null && 3 );	//	null
		console.log( 1 && 2 && 3 );	//	3
		
	Примечание: Приоритет оператора "&&" больше, чем у "||".
	
	Сокращённое вычисление. Например:
	
		let x = 1;
		(x > 0) && console.log( 'Greater than zero!' );
		
			Действие в правой части "&&" выполнится только в том случае, если до него дойдут вычисления.
			То есть, "console.log()" сработает, если в левой части "(x > 0)" будет true.

||	-	оператор "ИЛИ" (возвращает "true", если хотя бы одна операнда истинна). Оператор "ИЛИ" находит первое истинное значение, и выполняет следующие действия:

		-	Вычисляет операнды слева направо.
		
		-	Каждый операнд конвертирует в логическое значение. Если результат "true", останавливается и возвращает исходное значение этого операнда.

		-	Если все операнды являются ложными ("false"), возвращает последний из них.

		-	Значение возвращается в исходном виде, без преобразования.

	Другими словами, цепочка "ИЛИ" возвращает первое истинное значение или последнее, если такое значение не найдено. Например:
	
		let currentUser = null;
		let defaultUser = "John";
		let name = currentUser || defaultUser || "unnamed";	// выбирается "John" – первое истинное значение.
		
	Сокращённое вычисление. Например:
	
		let x;
		true || (x = 1);
		console.log(x);	//	"undefined" - пото му что "(x = 1)" не вычисляется, так как вернулось первое с списке значение "истинно".
		
		false || (x = 1);
		console.log(x);	//	"1" - пото му что "(x = 1)" вычисляется, так как первое с списке значение "ложь", и дальше происходит вычисление.

!	-	оператор "НЕ" (возвращает "true", если операнд ложный, возвращает "false", если операнд истынный). Приоритет "НЕ" является наивысшим из всех логических операторов,
поэтому он всегда выполняется первым, перед "&&" или "||".

?	-	условный (тернарный) оператор ("variable = (condition) ? value1: value2").

	Например:
	
		let isAdult = (age < 18) ? "Too young": "Old enough";
		
	Примечание: Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора. Например:

		(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Интерполяция строк.

Интерполяция строк используется для вставки переменных в строку без использования конкатенации. Для объявления интерполяции строк нужно начать стороку с символов "`",
в которых будет содержаться выражение "${}". Переменная необходимая для вставки в сроку нужно указать в фигурных скобках.

Например:

	let personName = "Alex";
	console.log(`Hello ${personName}`);
	
		Результат:
		
			Hello Alex

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Условные операторы.
	
if (<условие>) {
	<выражение>;
}

	Условный оператор "if" проверяет условие ("<условие>"), и выполянет выражение ("<выражение>"), в случае если уловие
	выполняется. После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if":
	
		let num1 = 5;
		let num2 = 10;
		if (num1 < num2) {
			alert("The num1 is less than num2");
		}
		
	Если в теле блока условного оператора (то есть в "<выражение>") есть только одна строка, то можно обойтись и без фигурных скобок ("{}"). Например:
	
		if (a > b) alert( 'first' );



if (<условие>) {
	<выражение>;
}
else {
	<выражение>;
}

	Оператор "else" выполняет свое выражение, если условие оператора "if" не выполняется. 
	После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if" с оператором "else":
	
		let num1 = 5;
		let num2 = 10;
		if (num1 > num2) {
			alert("The num1 is more than num2");
		}
		else {
			alert("The num1 is less than num2");
		}



if (<условие>) {
	<выражение>;
}
else if (<условие>) {
	<выражение>;
}
else {
	<выражение>;
}

	Оператор "else if" проверяет условие, и выполняет свое выражение, в случае, если его условие выполняется,
	и если условие первого оператора "if" не выполняется. В случае если и условие
	оператора "else if" тоже не	выполняется, то выполняется выражение оператора "else".
	После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if" с оператором "else":
	
		let num1 = 10;
		let num2 = 10;
		if (num1 > num2) {
			alert("The num1 is more than num2");
		}
		else if (num1 < num2) {
			alert("The num1 is less than num2");
		}
		else {
			alert("The num1 equals num2");
		}
	
	Можно использовать операторы "else if", сколько потребуются.
	
	
	
(<условие) ? <выражение для "истина"> : <выражение для "ложь">;

	Тернарный оператор. Такой же оператор условия как и "if", но более компактный. Использутся для специфичных ситуаций.
	В скобках с условием пишется условие, после чего после скобок ставится знак вопроса "?", указывающий что это тернарный оператор.
	После этого знака идет первое выражение, которое вернется, усли условие оператора выполнится. После первого выражения стоит
	знак двоеточия ":", после которого будет второе выражение, которое вернется если условие оператора не выполнится.
	Тернарный оператор рекомендуется использовать в коротких выражениях, требующий вернуть какой либо результат, и не рекомендуется
	использовать для многострочных выражений.
	
	Пример использования тернарного оператора:
	
		let accessAllowed = (age > 18) ? true : false;
		
	Примечание: Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора.



switch (<имя сравниваемой переменной>) {
	case <значение_1>:
		<выражение>
		break;
	case <значение_2>:
		<выражение>
		break;
	case <значение_3>:
		<выражение>
		break
	case <значение_n>:
		<выражение>
		break;
	default:
		<выражение>
}

	Условный оператор множества условий "switch" строго ("===") сравнивает заданное имя сравниваемой переменной со всеми значениями оператора "case" ("<значение_1>",
	"<значение_2>", "<значение_3>", "<значение_n>"), и выполняет выражение соответствующего значения "case", в случае равенства.
	Оператор "break" - выполняет выход из условного оператора "switch", после выполнения выражения. Если "<условие>" не равняется ни одному из
	значений оператора "case", то выполянется выражение "<выражение_default>" оператора "default". Оператор "default" не обязателен.
	После каждого выражения должен стоять символ точки с запятой ";".
	
	Пример использования оператора множества условий "switch":
	
		let day = 2;
		switch (day) {
			case 1:
				document.whrite("Понедельник");
				break;
			case 2:
				document.whrite("Вторник");
				break;
			case 3:
				document.whrite("Среда");
				break;
			case 4:
				document.whrite("Четверг");
				break;
			case 5:
				document.whrite("Пятница");
				break;
			case 6:
				document.whrite(Суббота");
				break;
			case 7:
				document.whrite("Воскресенье");
				break;
			default:
				console.log("Не является днем недели");	//	"Вторник"
		}
		
	Несколько вариантов "case", использующих один код, можно группировать:
	
		let a = 2 + 2;
		switch (a) {
			case 4:
				alert('Правильно!');
				break;

			case 3: // (*) группируем оба case
			case 5:
				alert('Неправильно!');
				alert("Может вам посетить урок математики?");
				break;

			default:
				alert('Результат выглядит странновато. Честно.');
		}
		
		В данном примере оба варианта "3" и "5" выводят одно сообщение.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Циклы.						

for (<начальное значение переменной>; <условие цикла>; <выражение для конца итерации>) {
	<выражение>;
}

	Оператор цикла. Где "<начальное значение переменной>" - выражение, которое выполнится до запуска блока цикла;
	"<условие цикла>" - условие, которое должно выполняться,
	чтобы цикл продолжался; "<выражение для конца итерации>" - выражение, которое будет выполняться после каждого цикла;
	"<выражение>" - выражение, которое будет выполняться в каждом цикле.
	
	Пример использования цикла "for":
	
		for (i=1; i<=5; i++) {
			document.write(i + "<br />");
		}
	
	"<начальное значение переменной>" - является опциональным, при необходимости можно не указывать, оставив на его месте только символ точки с запятой ";",
	если необходимые значения указаны до цикла:
	
		let <переменная> = <значение>;
		for (; <условие цикла>; <выражение для конца итерации>) {
			<выражение>;
		}
		
		Например:
			
			var i = 1;
			for (; i<=5; i++) {
				document.write(i + "<br />");
			}
		
	На месте "<начальное значение переменной>" могут быть несколько значений, перечисляя после запятой:
	
		for (<выражение_1, выражение2, выражение_3, выражение_n>; <условие цикла>; <выражение для конца итерации>) {
			<выражение>;
		}
		
	"<условие цикла>" - также является опциональным, при необходимости можно не указывать, оставив на его месте только символ точки с запятой ";".
	Если его не использовать, то необходимо указать оператор "break", чтобы создать выход из цикла.
	
	"<выражение для конца итерации>" - также является опциональным, при необходимости можно не указывать.
	На его месте не будет ставиться символ точки с запятой ";", как	в случаях выше, так как это выражение является последним в скобках:
	
		for (; <условие цикла>; ) {
			<выражение>;
		}
		
	Существуют циклы для перебора объектов - "for <ключ> in <объект>", в которых при каждой итерации будет поочередно браться ключ данного объекта:
	
		let obj = {
			"a": 1,
			"b": 2,
			"e": 76
		}
		
		for (let key in obj) {
			console.log(obj[key]);	//	Выведет "1", "2", "76".
		}
		
	Существуют циклы для перебора массивов - "for <элемент> of <массив/итерируемый объект>", в которых при каждой итерации будет поочередно браться индекс данного массива:
	
		let arr = [1, 2, 76]
		
		for (let i of arr) {
			console.log(i);	//	Выведет "1", "2", "76".
		}
		


while (<условие>) {
	<выражение>;
}

	Цикл "while", повторяет блок кода (напр. "<выражение>"), пока действует условие "<условие>".
	
	Пример использования цикла "while":
	
		var i = 0;
		while (i<=10) {
			document.write(i + "<br />");
		}
		
	Фигурные скобки ("{}") не требуются для тела цикла из одной строки:
	
		let i = 3;
		while (i) alert(i--);



do {
	<выражение>;
}
while ("<условие>");

	Цикл "do while" является вариацией цикла "while". Данный цикл выполнит "<выражение>" один раз, до проверки правильности условия "<условие>", а затем цикл будет
	повторяться, пока будет выполняться условие "<условие>".
	Точка с запятой после "while" является обязательным.
	
	
	
• Если цикл содержит только одну строку, то можно обойтись без фигурных скобок:

	for (let i of arr) alert(i);



break;

	Выражение, которое завершает цикл.
	
	Например:
	
		for (i=0; i<=10; i++) {
			if (i == 5) {
				break;
			}
			document.write(i + "<br />");
		}
		
		В данном примере если число "i" равняется 5, то цикл прекращается.
		
		Примечание:
		
			Выражение "return" так же нарушит цикл, вернув некоторое значение из цикла.



continue;

	Выражение, которое останавливает одну итерацию, и продолжает со следующей (перескакивает на следующий цикл).
	
	Например:
	
		for (i=0; i<=10; i++)	{
			if (i == 5) {
				continue;
			}
			document.write(i + "<br />");
		}
		
		В данном примере если число "i" равняется 5, то цикл пропускает текущую итерацию, и переходит к следующей, пропуская печать числа 5.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Метки инструкций (label). Инструкция метки (label) используется вместе с директивами (операторами) "break" или "continue" для альтернативного выхода из цикла.
Оно добавляется перед блочным выражением в качестве ссылки, которая может быть использована в дальнейшем. Например:

	let i, j;

	loop1:	for (i = 0; i < 3; i++) {	//Первый цикл, обозначенный меткой "loop1".
	   loop2:
	   for (j = 0; j < 3; j++) {	//	Второй цикл, обозначенный меткой "loop2".
		  if (i == 1 && j == 1) {
			 continue loop1;
		  }
		  console.log("i = " + i + ", j = " + j);
	   }
	}
	
	Вызов "break" или "continue" возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функции.

Функцией языка "JavaScript" является блок кода, созданный для выполнения специального задания. Есть два способа объявления/создания функции.
Первый это объявление фунции через объявление имени функции "Function Declaration":

	function <имя функции> (<принимаемые параметры/аргументы>) {
		<тело функции>;
	}
	
	"Function Declaration" можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке). Другими словами, когда движок "JavaScript"
	готовится выполнять скрипт или блок кода, прежде всего он ищет в нём "Function Declaration" и создаёт все такие функции. Можно считать этот процесс "стадией инициализации".
	И только после того, как все объявления "Function Declaration" будут обработаны, продолжится выполнение. В результате, функции, созданные, как "Function Declaration"
	могут быть вызваны раньше своих определений.
	
	В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.
	
Второй это объявление фунции через функциональное выражение "Function Expression":

	let <имя переменной для функции> = function (<принимаемые параметры/аргументы>) {
		<тело функции>;
	};
	
	Важно! В конце такого способа (после "}") ставится ";", так как это все равно операция присваивания.
	
	"Function Expression" создаётся, когда выполнение доходит до него, и затем уже может использоваться.
	После того, как поток выполнения достигнет правой части выражения присваивания "let <имя переменной для функции> = function…" – с этого момента,
	функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).
	
	Так же функцию можно скопировать в другую переменную:
	
		let fn2 = fn;
		
			Здесь "fn" является функцией, и пишется без скобок, чтобы присвоить ее саму переменной "fn2", иначе бы (если со скобками) этой переменной присвоилось бы то,
			что возвращает функция "fn".
			
	• "Named Function Expression". Это термин для "Function Expression", у которого есть имя:
	
		let sayHi = function func (who) {
			alert(`Hello, ${who}`);
		};
		
	Это имя не доступно за пределами функции.	
	Данный способ используется для чтобы позволить функции ссылаться на саму себя, даже если переменная функции больше не будет доступна:

		let sayHi = function func(who) {
			if (who) {
				alert(`Hello, ${who}`);
			} else {
				func("Guest");
			}
		};

		let welcome = sayHi;
		sayHi = null;

		welcome(); // "Hello, Guest" (вложенный вызов работает).

Объявление (определение) и вызов (выполнение) функции (на примере первого способа объявления/создания функции "Function Declaration"):

	function <имя функции> (<принимаемые параметры/аргументы>) {
		<тело функции>;
	}
	
	Где "<имя функции>" - это имя создаваемой функции, которое может состоять только из допустимых символов в "JavaScript" (так же как и для переменных);
	"<принимаемые параметры/аргументы>" - это входные параметры	(аргументы) фукции, которые будут использоваться в самой функции.
	В "<принимаемые параметры/аргументы>" могут быть несколько значений, перечисляясь через запятую.
	"<тело функции>" - код функции, который будет выполняться самой функцией.
	
	Примечание:
	
		Если в "<принимаемые параметры/аргументы>" будут переданы больше аргументов, чем описано в коде фунции, то они будут прикреплены к массиву с аргументами, и их можно будет использовать
		следующим образом:
		
			arguments[0], arguments[1], arguments[2], arguments[n]
			
		Если в "<принимаемые параметры/аргументы>" будут переданы меньше аргументов, чем описано в коде фунции, то пропущенные значения будут установлены как неопределенные, что означает что
		переменным не будет присвоено значение.
		
	Параметры по умолчанию. Если параметр не указан, то его значением становится "undefined". Можно задавать принимаемые параметры по умолчанию через "=". Например:
	
		function fn (name, years = 18) {
			console.log(name + " is " + years + " years old");
		}
	

	Чтобы вызвать (выполнить) функцию, нужно прописать имя функции, а затем добавить в скобках входные параметры (аргуенты) функции. После вызова функции, должна стоять
	точка с запятой.
	
	Форма вызова (выполнения) фукции:
	
		<имя функции>(<принимаемые параметры/аргументы>);
		
	Примеры использования фукций:
	
		Пример первый (создание и вызов функции без аргумента):
	
			function myFunction() {
				alert("Alert Box");
			}
			myFunction();
			
			Результатом данной функции будет вывод текста "Alert Box".
			
		Пример второй (создание и вызов функции с аргументом):
			
			function sayHello(name) {
				alert("Hi, " + name);
			}
			sayHello("David");
			
			Результатом данной функции будет вывод текста "Hi, David".
			
		Пример третий (создание и вызов функции с несколькими аргументоми):
		
			function personInfo(name, age) {
				document.write(name + "is" + age + "years old.");
			}
			personInfo("David", 18);
			
			Результатом данной функции будет вывод текста "David is 18 years old.".
			
Возвращение значения функции.

	Функция может иметь опциональную инструкцию (выражение) "return", она используется для возвращения значения функции. Эта функция полезна при выполнении вычислений, для
	немедленного получения результата. Когда "JavaScript" достигает инструкции "return", функция останавливает выполнение. После инструкции "return" ставится точка с запятой.
	
	Примеры использования инструкции "return":
	
		Пример первый:
	
			function myFunction(a, b) {
				return a*b;
			}
			let x = myFunction(5,6);
			
			Результатом данной функции будет возвращение значения произведения "a*b" функции "myFunction",
			затем присвоение ее значения переменной "х" (то есть "x" будет равен 30).
			
		Пример второй:
		
			function addNumbers(a, b) {
				let c = a + b;
				return c;
			}
			document.write(addNumbers(40, 2));
			
			Результатом данной функции будет возвращение значения переменной "c" функции "addNumbers", затем печать результата функции "addNumbers" (то есть печать числа 42).

	Вызовов "return" может быть несколько, а так же возможно использовать "return" и без значения, что приведёт к немедленному выходу из функции.
	Если функция не возвращает значения, это всё равно, как если бы она возвращала "undefined". Пустой "return" аналогичен "return undefined".

Обращение к имени функции без скобок вернет его исходный код. Например:

	function fn (x) {
		alert(x);
	}
	
	console.log(fn);	//	Выведет код функции.
	
• Функции шаблонизации. Можно использовать свою функцию шаблонизации для строк. Название этой функции ставится перед первой обратной кавычкой:

	let str = func`моя строка`;
	
Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров "${…}" и сами эти параметры. Например:

	function f(strings, ...values) {
	  console.log(JSON.stringify(strings));	//	["Sum of "," + "," =\n ","!"]
	  console.log(JSON.stringify(strings.raw));	//	["Sum of "," + "," =\\n ","!"]
	  console.log(JSON.stringify(values));	//	[3,5,8]
	}

	let apples = 3;
	let oranges = 5;

	let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
	
	В примере выше видно, что строка разбивается по очереди на части: "кусок строки" – "параметр" – "кусок строки" – "параметр".
	Участки строки идут в первый аргумент-массив "strings".
	У этого массива есть дополнительное свойство "strings.raw". В нём находятся строки в точности как в оригинале.
	Это влияет на спец-символы, например в "strings" символ "\n" – это перевод строки, а в "strings.raw" – это именно два символа "\" и "n".
	Дальнейший список аргументов функции шаблонизации – это значения выражений в "${...}", в данном случае их три.
	
• У функций есть свойство "arguments", которое содержит все принимаемые аргументы:

	function showName() {
		console.log( arguments.length );
		console.log( arguments[0] );
		console.log( arguments[1] );

	  // Объект arguments можно перебирать
	  // for (let arg of arguments) console.log(arg);
	}
	
Свойство "arguments" у функций является перебираемым объектом и псевдомассивом, но у него нет методов обычного массива.

	
	showName("Hello", "World");	//	2, Hello, World
	
• Функция получает текущее значение внешних переменных, то есть, их последнее значение.	

• У функций (а так же методов объектов) есть встроенные свойства:

	name	-	возвращает имя фукнции. У "Named Function Expression" это имя будет именем перед скобками.
	
	length	-	возвращает количество параметров функции в её объявлении (кроме "...rest").
	
• Синтаксис "new Function" - ещё один вариант объявлять функции. Он используется крайне редко. Данный способ схож с методом "eval()", но имеет отличия.
Форма синтаксиса "new Function":

	let func = new Function(<аргумент1>, <аргумент2>, <аргументN>, <тело функции>);
	
	Аргументы также могут быть объявлены через запятую в одной строке.
	
Когда функция создаётся с использованием "new Function", в её "[[Environment]]" записывается ссылка не на внешнее лексическое окружение, в котором она была создана,
а на глобальное.
Пример использования "new Function":

	let sum = new Function('a', 'b', 'return a + b');

	console.log( sum(1, 2) );	//	3
	
• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями. Подробнее в главе "Преобразование типов".
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Стрелочные функции.

"функции-стрелки" или "стрелочные функции" (arrow functions), т.к. выглядит следующим образом:

	let <имя переменной для функции> = (<принимаемые параметры/аргументы>)=>{<тело функции>}
	
	Чтобы объявить стрелочную функцию, нужно указать круглые скобки "()" для входных параметров, а затем после них указать сочетание "=>", что является указанием что
	это стрелочная функция.
	
	Пример:
	
		let sum = (a, b) => {
			return a+b;
		}
		
	Если входной параметр только один, то можно обойтись без круглых скобок "()":
	
		let double = a => {
			return a*2;
		}
		
	Если нет аргументов, указываются пустые круглые скобки:
	
		let great = () => {
			console.log("Hello");
		}
		
	Если тело функции состоит только из одной строки, то можно обойтись и без фигурных скобок "{}" и директивы "return":
	
		let double = a => a*2;
		
• У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).
Например:

	let user = {
		firstName: "Илья",
		sayHi() {
			let arrow = () => console.log(this.firstName);
			arrow();
		}
	};
	
	user.sayHi();	//	Илья
	
• Стрелочные функции не имеют свойства "arguments". Если стрелочная функция находится внутри обычной функции, то если обратиться к "arguments" из стрелочной функции,
то получим аргументы внешней обыной функции.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Самовызываемые функции (или немедленно вызываемые функции - "Immediately-Invoked Function Expression" - "IIFE").

Самовызываемые функции это функции, которые вызываются сразу же после объявления. Такие функции вызываются с помощью операторов группировки (скобки "()").

Формы синтаксиса самовызываемой функции:

	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>})();	//	Скобки вокруг функции.
	
	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}());	//	Скобки вокруг всего.
	
	!function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();	//	Выражение начинается с побитового оператора "NOT".
	
	+function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();	//	Выражение начинается с унарного плюса.
	
Пример самовызываемой функции:

	(function fn() { console.log("Test"); } )();	//	Test
	
	В данном примере в первых скобках находится объявление функции. Первые скобки "группируют" то, что нахоится в ней. Вторые скобки уже действуют как скобки у обычного
	вызова функции, в них даже можно передать параметры:
	
		(function fn(input) { console.log(input); } )("Test");	//	Test
		
Так же можно создать самовызываемаю функцию с помощью анонимной функции:

	(function (input) { console.log(input); } )("Test");
		
Так же можно создать самовызываемую функцию с помощью стрелочных функций:

		(input => console.log(input) )("Test");	//	Test
		
Примечание! Рекомендуется ставить точку с запятой после какого-либо выражения (на усмотрение), если после нее идет самовызываемая функция. Пример:

	let user = {
	  name: "Джон",
	  go: function() { alert(this.name) }
	}

	(user.go)()	//	Ошибка !
	
	Данный пример вызовет ошибку, так как пропущена точка с запятой поле объявления (литерала) объекта, потому что "JavaScript" попытается вызвать объект "user" ("{...}")
	как функцию с парамтрами первых скобок "(user.go)".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дебаггер. Команда "debugger" предназначена для того чтобы установить точку останова в коде, тем самым останавливая выполнение кода.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функции высшего порядка и колбэки.

Колбэки ("ClassBack") это функции, передаваемые в другую функцию (в функцию высшего порядка), в качестве аргументов, которые будут выполнены позже.
Функции высшего порядка ("Higher-order function") это функции, которые принимают колбэки, в качестве аргументов. Пример:

	function callBackYes(){
		console.log("Yes!");
	}
	
	function callBackNo(){
		console.log("No!");
	}
	
	function higherOrderFunction(input, yes, no) {
		if (input == "yes") yes();
		else if (input == "no") no();
	}
	
	higherOrderFunction("yes", callBackYes, callBackNo);
	

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Анонимные функции.

Один из способов создать анонимную функцию, это задать ее как колбэк. Например:

	function ask (question, ifYes, IfNo){
		if (confirm(question)) {
			ifYes();
		}
		else {
			IfNo();
		}
	}
	
	ask("Вы согласны?", function() { alert("Вы согласились."); },  function() { alert("Вы отменили выполнение.");
	
		В данном примере два передаваемыех колбэка в функцию "ask" являются анонимными, на в самой функции "ask" им определены имена "ifYes" и "ifNo",
		по которым они могут дальше вызываться.
		
Еще способ создать внонимную функцию, это через самовызываемую функцию:

	(function (input) { console.log(input); } )("Test");

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Области видимости переменных.

1. Глобальная область видимости переменных - область, где все переменные доступны в любом участке кода.

2. Локальная облать видимости - область, где все переменные доступны только в блоке кода, где они были созданы (например в теле функции).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объекты.

Объекты это "контейнеры", для хранения полей/свойств (сущностей/элементов). Один из способов создания объектов, это с помощью литерала объекта - фигурных скобок "{}".
Свойства в объете должны перечисляться с помощью запятой, а значения этим элементам присваиваются с помощью двоеточия (":"), а не равно ("=").
После фигурных скобок рекомендуется ставить точку с запятой ";".
Пример:

	let obj = {
		name: "Alex",
		age: 18
	};
	
Другой способ создания объекта это с помощью встроенного главного объекта "Object" с ключевым словом "new":

	let obj = new Object();	//	Будет создан пустой объект, как если бы он был создан таким образом: "let obj = {};".

Доступ к свойствам объекта можно получить с помощью точки ".":

	let obj = {
		name: "Alex",
		age: 18
	};
	
	console.log(obj.name);	//	 Alex
	
Можно также изменять значения свойств с помощью точки ".":

	obj.name = "Bob";
	
Чтобы удалить свойство объекта, используют оператор "delete":

	delete obj.name;
	
Если имя свойства объекта состоит из нескольких слов, то его заключают в кавычки '""':

	let obj = {
		"max num": 200;
	};
	
Чтобы обратиться к таким свойствам, нужно указать из в квадратных скобках "[]":

	console.log(obj["max num"]);
	
Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

	let max = "max num";
	
	obj[max] = 200;
	
К именам свойств объекта применяются те же правила, что и к именам переменных. Если имя совойства состоит из числа, то доступ у нему нельзя будет осуществить
через точку ".", а только через квадратные скобки "[]".
	
В свойствах объекта можно указывать вычисляемые свойства с помощью квадрадных скобок "[]":

	function fn() { return "apple"; }

	let fruit = fn();
		
	let obj = {
		name: "Alex",
		age: 18,
		[fruit]: 5	//	имя свойства будет взято из переменной "fruit", и оно будет "apple".
	};
		
Так же можно присвоить значение свойству через обращение к нему:

	function fn() { return "apple"; }

	let fruit = fn();
	
	obj[fruit] = 5;
	
Так же можно использовать и более сложные выражения в квадратных скобках:

	let fruit = "apple";
	
	let obj = {
		name: "Alex",
		age: 18,
		[fruit + "Juice"]: 5	//	obj.appleJuice = 5.
	};
	
Если название свойства объекта совпадает с именем переменной, то можно не указывать значение вычисляемого свойства объекта:

	let name = "Alex";
	
	let obj = {
		name,
		age: 18
	};
	
В объектах есть свойство "__proto__", и оно всегда указывает на объект. Если нужно его переопределить, то переопределяемое значение должно быть
всегда объектом.

Чтобы выяснить, содержит ли определенный объект определенное свойство, существует оператор "in", который возвращает булево значение:

	let user = {
		name: "Alex"
	};
	
	console.log("name" in user);	//	true
	console.log("age" in user);	//	false
	
Для перебора всех свойств в объекте существует цикл "for in", который будет получать каждое свойство для каждной итерации цикла:

	let user = {
		name: "Alex",
		age: 18
	};

	for (let key in user) {
		console.log(user[key]);	// тело цикла выполнится для каждого свойства объетка "user".
	}
	
Важно! Порядок вывода свойств зависит от того, из каких символов состоят свойства. Если они содержат целочисленные значения (даже если в кавычках), то они будут
выводится в порядка возрастания. Чтобы этого избежать, нужно добавить символ плюса "+" перед числом ("44" => "+44"). В таком случае они будут выводиться
в порядке их объевления.

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются "по ссылке".
Примитивные типы: строки, числа, логические значения – присваиваются и копируются "по значению".
Переменная объекта хранит не сам объект, а его "адрес в памяти", другими словами "ссылку" на него:

	let user1 = {
		name: "Alex";
	};
	let user2 = user1;	//	Здесь "user2" является ссылкой на объект "user1", а не его копией.
	
	user2.name = "Bob";
	
	console.log(user1.name);	//	Bob
	
Чтобы клонировать объект, можно перебрать объект с помощью цикла "for in", и присваивать каждый ключ новому объекту.
Есть еще способ клонировать объект, это с помощью метода "assign" встроенного объекта "Object" ( "Object.assign(<целевой объект>, <объекты источники>);" ):

	let obj1 = {
		name: "Alex",
		age: 18
	};
	
	let obj2 = {};
	
	Object.assign(obj2, obj1);
	
Также можно использовать "Object.assign" для простого клонирования:

	let user = {
		name: "John",
		age: 30
	};

	let clone = Object.assign({}, user);
	
В обоих случаях, если объекты содержит вложенные объекты (объекты внутри объектов), то они не будут клонированы, вместо этого будут созданы ссылки на них.

Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение "user[key]" объектом, и если это так – копируем и его структуру тоже.
Это называется "глубокое клонирование".


• Методы объекта. Методы это функции объектов. Примеры создания методов:

	1. Создание метода через "Function Expression":
	
		let user = {
			name: "Alex"
		};
		
		user.sayHi = function() {
			alert("Hi");
		}
		
	2. Создание метода через "Function Declaration":
	
		let user = {
			name: "Alex"
		};
		
		function sayHi () {
			alert("Hi");
		}
		
		user.sayHi = sayHi;
		
	3. Создание метода в литерале объекта:
	
		let user = {
			name: "Alex",
			sayHi: function () {
				alert("Hi");
			}
		};
		
	4. Упрощенное создание метода в литерале объекта:
	
		let user = {
			name: "Alex",
			sayHi() {
				alert("Hi");
			}
		};
		
Важно ! Варианты создания методов "3" и "4"  не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов.
	
Чтобы вызвать метод объекта, нужно указать имя объекта, а затем через точку (".") указать метод вместе со скобками (так как метод это функция):

	user.sayHi();	//	Hi
	
• Перебор объекта с помощью циклов. Перебрать объект можно с помощью цикла "for <ключ> in <объект>". Подробнее в главе "Циклы".

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON" (вызов метода "stringify" у "JSON" для объекта),
подробнее в главе "Преобразование типов".

• Главный объект "Object" имеет следующие методы:

	assign(<целевой объект>, <объекты источники>)	-	создание/(добавление в) объекта/объект "<целевой объект>" из указанных источников "<объекты источники>".
	
	is(<аргумент>, <аргумент2>)	-	сравнивание указанных значений примерно как "===".

	keys(<целевой объект>)	-	возвращает массив ключей объекта. Игнорируются символьные свойства.
	
	values(<целевой объект>)	-	возвращает массив значений объекта. Игнорируются символьные свойства.
	
	entries(<целевой объект>)	-	возвращает массив пар ключ-значение. Игнорируются символьные свойства.
	
	fromEntries(<массив>)	-	создает объект из массива пар ключ-значение.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
◘ Массивы.

Массивы это "контейнеры", для хранения коллекции данных по индексами (которые начинаются с нуля). Элементы в массиве должны перечисляться с помощью запятой.
В массиве могут храниться элементы любого типа (числа, строки, другие массивы, объеты и т.д.). Массив является типом данных - "объект". Массивы копируются по ссылке как и объекты.
Массивы являются "перебираемыми" объектами.

Способы создания массивов:

	Через литерал массива:
	
		let arr = ["Яблоко", 'Груша', `Слива`];
		
	Через объект "Array":
	
		let arr = new Array("Яблоко", 'Груша', `Слива`);
		
		Если в качестве аргумента объекту "Array" передать один целочисленный аргумент, то он сработает как указатель на количество элементов ново создаваемого/возвращаемого
		массива:
		
			let arr = new Array(5);
			
			console.log( arr.length )	//	5
		
Чаще всего используется метод литера массива.
	
Чтобы получить доступ к элементу массива нужно исрльзовать квадратные скобки с индексом элемента (индекс элементов начинается с нуля):

	console.log(arr[0]);	//	"Яблоко"
	
Для получения доступа к длине массива есть свойство "length":

	let arr = ["Яблоко", 'Груша', `Слива`];
	
	console.log( arr.length );	//	3
	
	Свойство "length" автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.
	Например, единственный элемент, имеющий большой индекс, даёт большую длину:
	
		let fruits = [];
		fruits[123] = "Яблоко";

		console.log( fruits.length ); // 124

• Перебор массива с помощью циклов. Перебрать объект можно с помощью обычного цикла "for", а так же "for <элемент> of <массив/итерируемый объект>". Подробнее в главе "Циклы".
Технически, так как массив является объектом, можно использовать и вариант "for <ключ> in <объект>", но не рекомендуется это делать из-за проблем, которые он может вызвать.

• Правила массивов. 

Технически массивам можно присваивать свойства как и объектам, но так как массивы в своей основе являются объектами, то это не рекомендуется делать,
так как тогда движок "JavaScript" будет работать с массивом как с объектом. Движок "JavaScript" работая с нормальными массивами обрабатыват их быстро, так как он оптимизирует их,
но когда массиву будет присвоено свойство как к объекту, он перестанет их обрабатывать как массив, и это скажется на оптимизации.

Не рекомендуется создавать "дыры" в массиве, добавляя в него значения под большим индексом (например "arr[9999] = 'apple';").

• "this" в массивах. "this" работает с массивами так же как и с объектами:

	let arr = ["a", "b"];

	arr.push(function() {
		console.log( this );
	})

	arr[2](); //  "a","b",function
	
• Удаление элементов массива с помощью оператора "delete". При удалении элементов этим способом, элемент удаляется, а его место сохраняется, то есть свойство "length" массива
останется неизменным.
	
• Методы массивов:

	"pop()"	-	удаляет последний элемент массива, и возвращает его.

	"push(<элементы>)"	-	добавляет элементы в конец массива. Можно передавать больше одного элемента в метод "push". Вызов данного метода без аргументов вернет длину массива.

	"shift"	-	удаляет из массива первый элемент и возвращает его.

	"unshift(<элементы>)"	-	добавляет элементы в начало массива. Можно передавать больше одного элемента в метод "unshift". Вызов данного метода без аргументов вернет длину массива.

	"pop"/"push"	-	работают быстрее методов "shift"/"unshift".

	"toString()"	-	возвращает список элементов, разделённых запятыми.
	Массивы не имеют ни "[Symbol.toPrimitive]", ни функционирующего "valueOf", они реализуют только преобразование "toString".
	
	"splice(<позиция>, <количество (опционально)>, <новый элемент (может быть несколько)>)"	-	универсальный метод для удаления, добавления и замены элементов массива.
	Данный метод начинает с позиции "<позиция>", удаляет "<количество (опционально)>" элементов и вставляет "<новый элемент (может быть несколько)>" на их место.
	Возвращает массив из удалённых элементов. Еслли не задавать параметров кроме "<позиция>", то будут удалены все элементы, начиная с заданной позиции.
	Если "<количество (опционально)>" задать 0, то новые передаваемые элементы будут добавлены в массив начиная с заданной позиции. Позицию можно задать отрицательным числом,
	тогда позиция будет с конца массива.
	
	"slice(<позиция начала (опционально)>, <позиция конца (опционально)>)"	-	возвращает новый массив, в который копирует элементы, начиная с начальной позиции и до
	конечной позиции (не включая позицию конца). Оба индекса параметра могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
	Оба индекса опциональны. Если данному методу не задать никаких параметров, то он вернет копию массива (без глубокого копирования).
	
	"concat(<аргумент1>, <аргумент2 (опционально)>, <аргументN (опционально)>)"	-	данный метод копирует аргументы в массив, у которого вызван данный метод.
	Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
	Если в качестве параметра передать массивоподобный объект, то метод не сработает:
	
		let arr = [1, 2];
		
		let arrayLike = {
			0: "something",
			length: 1
		}
		
		console.log ( arr.concat(arrayLike) );	//	1,2,[object Object]
		
		Чтобы метод сработал при таком аргументе, то нужно такому объекту задать специальный символ "[Sybmol.isConcatSpreadable]" со значением "true":
		
			let arr = [1, 2];
		
			let arrayLike = {
				0: "something",
				1, "something else",
				[Symbol.isConcatSpreadable}: true,
				length: 2
			}
			
			console.log ( arr.concat(arrayLike) );	//	1,2,something, something else
			
		Для корректной обработки в объекте обязательно должны быть числовые свойства и "length".
		
	"forEach(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){})"	-	данный метод выполняет фукцию для каждого элемента массива.
	Принимает колбэк функцию, который в свою очередь принимает текущий элемент массива, его индекс и сам массив.
	Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
	
	"indexOf(<подстрока>, <позиция (опционально)>);", "lastIndexOf(<подстрока>, <позиция (опционально));", "includes(<подстрока>, <позиция (опционально)>);"	-	эти методы
	аналогичны методам строк, но вместо символов они работают с элементами массива. Эти методы используют строгое сравнение при выборе элементов.
	Метод "includes" отличается от двух остальных методов работой с "NaN":
	
		const arr = [NaN];
		console.log( arr.indexOf(NaN) );	//	-1 (должен быть 0, но === проверка на равенство не работает для NaN).
		console.log( arr.includes(NaN) );	//	true (верно).
	
	"find(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg (опционально)>)"	-	данный метод предназначен для поиска элемента массива с определенным условием.
	Данный массив принимает колбэк функцию, который в свою очередь принимает текущий элемент, его индекс и сам массив. Если функция возвращает "true", то выполнение фукции
	останавливается, и возвращается текущий элемент. Если ничего не найдено, то возвращается "undefined". "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let users = [
			{id: 1, name: "Вася"},
			{id: 2, name: "Петя"},
			{id: 3, name: "Маша"}
		];

		let user = users.find(item => item.id == 1);

		console.log(user.name);	//	Вася
		
	"findIndex(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>{}, <thisArg (опционально)>)"	-	данный метод схож с методом "find", но возвращает индекс,
	на котором был найден элемент, а не сам элемент, и "-1", если ничего не найдено. "<thisArg (опционально)>" - явное указание "this" методу.
	
	"filter(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>{}, <thisArg (опционально)>)"	-	данный метод схож с методом "find", но в отличии от него, при нахождении множества
	элементов возвращает массив из всех подходящих элементов. "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let users = [
			{id: 1, name: "Вася"},
			{id: 2, name: "Петя"},
			{id: 3, name: "Маша"}
		];

		//	возвращает массив, состоящий из двух первых пользователей.
		let someUsers = users.filter(item => item.id < 3);

		console.log(someUsers.length);	//	2
		
	"map(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>, <thisArg (опционально)>)"	-	данный метод вызывает функцию колбэк для каждого элемента массива,
	и возвращает массив результатов выполнения этой функции. "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
		alert(lengths);	//	5,7,6
		
	"sort(<фукнция колбэк>)"	-	метод для сортировки исходного массива. Данный метод возвращает отсортированный массив, но обычно возвращаемое значение игнорируется,
	так как изменяется сам исходный массив. Данный метод принимает функцию колбэк, который в свою очередь принимает два сравниваемых элемента. По умолчанию элементы сортируются
	как строки. Функция колбэк должна вернуть положительное число, если первый элемент больше второго, отрицательное число, если второй элемент больше первого, и ноль, если равны.
	От функции сравнения требуется любое положительное число, чтобы сказать "больше", и отрицательное число, чтобы сказать "меньше".
	Пример:
	
		function compare(a, b) {
			return a - b;
		}
		
		let arr = [ 1, 2, 15 ];

		arr.sort(compareNumeric);

		alert(arr);	//	1, 2, 15
	
		Данный метод можно записать в коротком виде с помощью стрелочных функций:
		
			arr.sort( (a, b) => a - b );
			
	"reverse()"	-	метод меняет порядок элементво в массиве на обратный.
	
	"join(<соеденитель>)"	-	данный метод делает противоположное методу "split" у строк, а именно создает строку из массива по заданному соеденителю:
	
		let arr = ['Вася', 'Петя', 'Маша'];

		let str = arr.join(';');	//	объединить массив в строку через ;

		alert( str );	//	Вася;Петя;Маша
		
	"reduce(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>)"	-	данный
	метод перебирает массив и возвращает единое результирующее значение. "<старое значение>" равно результату предыдущего вызова этой функции
	(равен "<изначальное значение (опционально)>" при первом вызове, если таковой был передан).
	При отсутствии изначального значения в колбэке, в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
	Если массив пуст, то вызов "reduce" без начального значения выдаст ошибку.
	Пример:
	
		let arr = [1, 2, 3, 4, 5];

		let result = arr.reduce((sum, current) => sum + current, 0);

		alert(result);	//	15
		
	"reduceRight(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>)" - данный
	метод идентичен методу выше, за исключеним что он работает спарава на лево.
	
• Методы объекта "Array":

	Array.isArray(<аргуент>)
	
		Метод для проверки, является ли аргумент массивом или нет. Данный метод возвращает булево значение.
		
	Array.from(<аргумент>, <mapFn (опционально), <thisArg (опционально)>)
	
		Данный метод принимает итерируемый объект или псевдомассив и делает из него "настоящий" массив. После этого можно использовать методы массивов у него.
		Например:
		
			let arrayLike = {
				0: "Hello",
				1: "World",
				length: 2
			};

			let arr = Array.from(arrayLike);
			alert(arr.pop()); // World (метод работает).
			
		То же самое с итерируемым объектом:
		
			let range = {
				from: 1,
				to: 5
			};

			range[Symbol.iterator] = function() {
				return {
					current: this.from,
					last: this.to,

					next() {
						if (this.current <= this.last) {
							return { done: false, value: this.current++ };
						} else {
							return { done: true };
						}
					}
				};
			};
		
			let arr = Array.from(range);
			alert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)
			
		Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив:
		
			//	"range" взят из примера выше.

			//	возводим каждое число в квадрат.

			let arr = Array.from(range, num => num * num);

			alert(arr);	//	1,4,9,16,25
			
		В отличие от метода "split" у строк, этот метод в работе опирается на итерируемость строки, и поэтому, как и "for... of ...", он корректно работает с суррогатными парами.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Ключевое слово "this". 

Ключевое слово "this" указывает на контекст вызова, то есть указывает на то, где оно находится (на текущий объект). Например:

	let user = {
	  name: "Джон",
	  age: 30,
	  sayHi() {
		alert(this.name);	//	здесь "this" - это "текущий объект"
	  }
	};

	user.sayHi(); // Джон
	
	В данном примере значение "this" – это объект "перед точкой", который использовался для вызова метода. То есть в данном примере "this.name" внутри объекта "user" это
	все равно что "user.name" (ссылка на объект "user").
	
Если будет создана ссылка на объект под новым именем, а затем где-то будет "затерто" первичное имя объека, то попытка использовать методы этого объекта, которые в свою очередь
внутри используют свойства этого объекта через прямое обращение через первичное имя объека (например: "user.name") приведет к ошибке, так как это имя объекта уже затерто.
Поэтому в методе нужно использовать ключевое слово "this", которое будет указывать на текущий объект.

Значение "this" вычисляется во время выполнения кода и зависит от контекста.
Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение "this" при разных вызовах:

	let user = { name: "Джон" };
	let admin = { name: "Админ" };

	function sayHi() {
	  alert( this.name );
	}

	//	используем одну и ту же функцию в двух объектах.
	user.f = sayHi;
	admin.f = sayHi;

	//	вызовы функции, приведённые ниже, имеют разное значение "this".
	//	"this" внутри функции является ссылкой на объект, который указан "перед точкой".
	user.f();	//	Джон  (this == user)
	admin.f();	//	Админ  (this == admin)

	admin['f']();	//	Админ (неважен способ доступа к методу - через точку или квадратные скобки).
	
Когда вызывается метод объекта, "object.method()", значением "this" во время вызова является объект перед точкой.
	
Примечание ! Вызов "this" без объекта = "undefined". В строгом режиме ('"use strict"') в коде значением "this" будет являться "undefined".
В нестрогом режиме значением "this" в таком случае будет глобальный объект ("window").

	function sayHi() {
	  alert(this);
	}

	sayHi();	//	undefined
	
Потеря значения "this". Если создать функцию через "Function Expression", беря саму функцию как метод, из какого либо объекта, который внутри себя использут "this", то созданная
функция потеряет контекст вызова "this":

	let user = {
		name: "Джон",
		hi() {
			alert(this.name);
		}
	};
	
	let hi = user.hi;	//	Создадим функцию через "Function Expression".
	hi(); // Ошибка, потому что значением "this" потеряно, и является "undefined".
	
Еще пример c самовызываемой функцией (или немедленно вызываемой функциией) (анонимной) ("Immediately-Invoked Function Expression" - "IIFE") с использованием тернарного оператора:

	let user = {
		name: "Джон",
		hi() { alert(this.name); },
		bye() { alert("Пока"); }
	};

	user.hi();	//	Джон (простой вызов метода работает хорошо)

	(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
	
	В данном примере при "истине", выполняется первая часть оператора, который возвращает (но не вызывает!) метод, который в свою очередь сразу же вызывается с помощью скобок "()"
	в конце тернарного оператора. Так как метод не вызвался сразу внутри тернарного оператора как метод объекта "user", а была возвращена его функция, то эта функция потеряла
	контекст вызова "this", так как уже не имеет отнощение к объекту "user". А затем эта функция была вызвана, и вызвала ошибку.
	
У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).
Например:

	let user = {
		firstName: "Илья",
		sayHi() {
			let arrow = () => console.log(this.firstName);
			arrow();
		}
	};
	
	user.sayHi();	//	Илья
	
Контекст вызова "this" не смотрит на объявление объекта, а лишь на момент вызова:

	function makeUser() {
		return {
			name: "Джон",
			ref: this
		};
	}

	let user = makeUser();

	alert( user.ref.name );	//	Error: Cannot read property 'name' of undefined
	
	Здесь значение "this" внутри "makeUser()" является "undefined", потому что "makeUser()" вызвана как функция, не через "точку" как метод.
	Таким образом, при создании объекта "ref: this" берёт текущее значение "this" функции "makeUser()".
	
	Противоположный пример:
	
		function makeUser() {
			return {
				name: "Джон",
				ref() {
					return this;
				}
			};
		}

		let user = makeUser();

		alert( user.ref().name );	//	Джон
		
	Теперь это работает, поскольку "user.ref()" вызывается как метод, и значением "this" становится объект перед точкой ".".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Переадресация вызовов функций - "call", "apply". У функций есть встроенные методы "call" и "apply", которые позволяют явео передать "this" функции.
Форма синтаксиса метода "call":

	call(<контекст>, <аргуенты функции>);
	
Пример:

	let obj = {...};
	function fn(text, number){...}
	fn.call(obj, "Hello", 155);
	
Форма синтаксиса метода "apply":

	apply(<контекст>, <массив аргументов>);
	
Пример:

	let obj = {...};
	function fn(arr){...}
	fn.apply(obj, ["Hello", 155]);
	
Разницей методов "call" и "apply" является что "call" принимает аргументы через запятую, в то время как "apply" принимает массив аргументов.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Тип данных - "Symbol".

Тип "Символ" -  представляет собой уникальный идентификатор. Новые символы с помощью функции "Symbol()":

	let id = Symbol();
	
При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода. Оно не играет большой роли кроме помощи в отладке.
Это имя/описание можно передать как параметр в функцию "Symbol()":

	let id = Symbol("id");
	
Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
Например, вот два символа с одинаковым описанием – но они не равны:

	let id1 = Symbol("id");
	let id2 = Symbol("id");
	
	console.log(id1 == id2); // false
	
Примечание! Символы не преобразуются автоматически в строки.

Чтобы обратиться/вывести описание символа, у символа есть метод "decription":

	let id = Symbol("idDescription");
	console.log(id.description);	//	idDescription
	
Символы позволяют создавать "скрытые" свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы:

	let user = {
	  name: "Вася"
	};

	let id = Symbol("id");

	user[id] = 1;

	console.log( user[id] ); // мы можем получить доступ к данным по ключу-символу
	
Если мы хотим использовать символ при литеральном объявлении объекта "{}", его необходимо заключить в квадратные скобки.

	let id = Symbol("id");

	let user = {
	  name: "Вася",
	  [id]: 123	//	просто "id: 123" не сработает
	};
	
Примечание! Свойства объекта, чьи имена созданы с помощью символов не итерируются с помощью циклов "for in", а так же с помощью метода "keys"
объекта "Object" - ("Object.keys(obj)"). Метод "assign" объекта "Object" напротив имеет доступ ко всем свойствам объекта, как к остальным примитивным типам данных,
так и символьным типам.

Глобальные символы - симолы с одинаковыми именами, указывающие на одинаковые сущности. Для этого существует "глобальный реестр символов".

Для чтения (или, при отсутствии - создания) символа из реестра используется метод "for" объекта "Symbol" - "Symbol.for(<имя ключа>)". Он проверяет глобальный реестр и,
при наличии в нём символа с именем "<имя ключа>", возвращает его, иначе же создаётся новый символ "Symbol(<имя ключа>)" и записывается в реестр под ключом "<имя ключа>".
Пример:

	let id = Symbol.for("id");	//	если символа не существует, он будет создан

	let idAgain = Symbol.for("id");	//	читаем его снова в другую переменную (возможно, из другого места кода)
	
	alert( id === idAgain ); // true
	
Символы, содержащиеся в реестре, называются "глобальными символами". Если вам нужен символ, доступный везде в коде – используйте "глобальные символы".

Метод "keyFor" объекта "Symbol" принимает глобальный символ и возвращает его имя - "Symbol.keyFor(<символ>)":

	//	получаем символ по имени
	let sym = Symbol.for("name");
	let sym2 = Symbol.for("id");

	//	получаем имя по символу
	alert( Symbol.keyFor(sym) );	//	name
	alert( Symbol.keyFor(sym2) );	//	id
	
Внутри метода "Symbol.keyFor" используется глобальный реестр символов для нахождения имени символа. Этот метод не будет работать для неглобальных символов.
Например:

	let globalSymbol = Symbol.for("name");
	let localSymbol = Symbol("name");

	alert( Symbol.keyFor(globalSymbol) );	//	"name" - глобальный символ
	alert( Symbol.keyFor(localSymbol) );	//	"undefined" - для неглобального символа

	alert( localSymbol.description );	//	name
	
Для любых символов доступно свойство "description".

• Системные символы. Существует множество "системных" символов, использующихся внутри самого "JavaScript", и мы можем использовать их, чтобы настраивать
различные аспекты поведения объектов. Некоторые из системных символов:

	Symbol.hasInstance
	
	Symbol.isConcatSpreadable
	
	Symbol.iterator
	
	Symbol.toPrimitive
	
Примечание! Существует встроенный метод "getOwnPropertySymbols" объекта "Object" - "Object.getOwnPropertySymbols(obj)" – с его помощью можно получить все свойства объекта с
ключами-символами. Также существует метод "ownKeys" объекта "Reflect" - "Reflect.ownKeys(obj)" - который возвращает все ключи объекта, включая символьные.

• "Symbol.iterator"	-	это специальный встроенный символ, который превращает неитерируемы объект в итерируемый объект (для цикла "for ... of ...").
Чтобы сделать объект итерируемым (и позволить "for... of ..." работать с ним), нам нужно добавить в объект метод с именем "Symbol.iterator".
Когда цикл "for.. of ..." запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом "next".
Результат вызова "next()" должен иметь вид "{done: Boolean, value: any}", где "done = true" означает, что итерация закончена, в противном случае "value" содержи
очередное значение. Пример:

	let range = {
		from: 1,
		to: 5
	};

	// 1.	вызов for..of сначала вызывает эту функцию
	range[Symbol.iterator] = function() {

		// ...она возвращает объект итератора:
		//	2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
		return {
			current: this.from,
			last: this.to,

			//	3. next() вызывается на каждой итерации цикла for..of
			next() {
			// 4. он должен вернуть значение в виде объекта {done:.., value :...}
				if (this.current <= this.last) {
					return { done: false, value: this.current++ };
				}
				else {
					return { done: true };
				}
			}
		};
	};

	//	теперь работает!
	for (let num of range) {
	  alert(num);	//	1, затем 2, 3, 4, 5.
	}
	
Явный вызов итератора. Можно вызвать метод "next()" у итератора вручную:

	let str = "Hello";

	//	делает то же самое, что и "for (let char of str) { alert(char)}";
	
	let iterator = str[Symbol.iterator]();

	while (true) {
		let result = iterator.next();
		if (result.done) break;
		alert(result.value); // выводит символы один за другим
	}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Конструкторы. Ключевое слово "new".

Обычный синтаксис литерала объекта "{...}" позволяет создать только один объект. Если необходимо создать множество однотипных объектов, таких как пользователи,
элементы меню и т.д., то можно сделать при помощи функции-конструктора и оператора "new".

• Функция-конструктор.

Функции-конструкторы являются обычными функциями. Но есть два соглашения:

	1. Имя функции-конструктора должно начинаться с большой буквы.
	
	2. Функция-конструктор должна вызываться при помощи оператора "new".
	
	Например:
	
		function User(name) {
			this.name = name;
			this.isAdmin = false;
		}

		let user = new User("Вася");

		alert(user.name);	//	Вася
		alert(user.isAdmin);	//	false
		
Когда функция вызывается как "new User(...)", происходит следующее:

	1. Создаётся новый пустой объект, и он присваивается "this".
	
	2. Выполняется код функции. Обычно он модифицирует "this", добавляет туда новые свойства.
	
	3. Возвращается значение "this".
	
	Другими словами, вызов "new User(...)" делает примерно вот что:

		function User(name) {
			//	this = {}; (неявно)

			//	добавляет свойства к this
			this.name = name;
			this.isAdmin = false;

			//	return this; (неявно)
		}
		
	То есть, результат вызова new User("Вася") – это тот же объект, что и:

		let user = {
			name: "Вася",
			isAdmin: false
		};
		
Технически любая функция может быть использована как конструктор. То есть, каждая функция может быть вызвана при помощи оператора "new",
и выполнится алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением по именованию,
она как бы подсказывает разработчику, что данная функция является функцией-конструктором, и её нужно вызывать через "new".

Если в нашем коде большое количество строк, создающих один сложный объект, мы можем обернуть их в функцию-конструктор следующим образом:

	let user = new function() {
		this.name = "Вася";
		this.isAdmin = false;

		//	...другой код для создания пользователя
		//	возможна любая сложная логика и выражения
		//	локальные переменные и т. д.
	};
	
	Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создаётся и тут же вызывается.
	Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, но без возможности его повторного использования.
	
• Проверка на вызов в режиме конструктора: "new.target" (данный метод используется очень редко).

Используя специальное свойство "new.target" внутри функции, можно проверить, вызвана ли функция при помощи оператора "new" или без него.
В случае, если функция вызвана при помощи "new", то в "new.targe"t будет сама функция, в противном случае - "undefined".
Это можно использовать, чтобы отличить обычный вызов от вызова "в режиме конструктора". В частности, вот так можно сделать,
чтобы функцию можно было вызывать как с, так и без "new":

	function User(name) {
		if (!new.target) {	//	в случае, если вы вызвали без оператора "new".
			return new User(name);	//	...добавим оператор "new" за вас.
		}

		this.name = name;
	}

	let vasya = User("Вася");	//	переадресовывает вызовы на "new User".
	alert(vasya.name);	//	Вася
	
• Возврат значения из конструктора "return".

Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в "this", который в итоге станет результатом.
Но если "return" всё же есть, то применяется простое правило:

	1.При вызове "return" с объектом, будет возвращён объект, а не "this".

	2. При вызове "return" с примитивным значением, примитивное значение будет отброшено.
	
Другими словами, "return" с объектом возвращает объект, в любом другом случае конструктор вернёт "this".

В примере ниже "return" возвращает объект вместо "this":

	function BigUser() {

		this.name = "Вася";

		return { name: "Godzilla" };	//	<- возвращает этот объект.
	}

	alert( new BigUser().name );	//	"Godzilla" -> получили этот объект.
	
А вот пример с пустым "return" (или можно было поставить примитив после "return", неважно):

	function SmallUser() {

		this.name = "Вася";

		return;	//	<-	возвращает "this".
	}

	alert( new SmallUser().name );	//	Вася
	
Важно! Обычно у конструкторов отсутствует "return".

Если вызов конструктора идёт без аргументов, то можно не ставить скобки после "new":

	let user = new User;	//	<- без скобок.
	// то же, что и
	let user = new User();
	
• Создание методов в конструкторе. В "this" мы можем добавлять не только свойства, но и методы.

Например, в примере ниже, "new User(name)" создаёт объект с данным именем "name" и методом "sayHi":

	function User(name) {
		this.name = name;

		this.sayHi = function() {
			alert( "Меня зовут: " + this.name );
		};
	}

	let vasya = new User("Вася");

	vasya.sayHi(); // Меня зовут: Вася

	/*
	vasya = {
		name: "Вася",
		sayHi: function() { ... }
	}
	*/
	
• Использование конструкторов для "String", "Number" и "Boolean".

Можно создать примитивы "String", "Number" и "Boolean" с помощью конструкторов, но не рекомендуется, так как последствия могут быть катастрофическими:

	console.log( typeof 0 );	//	number

	console.log( typeof new Number(0) );	// 	object
	
Объекты в "if" всегда дают "true":

	let zero = new Number(0);

	if (zero) {
		//	zero возвращает "true", так как является объектом.
		console.log( "Test" );
	}

С другой стороны, использование функций "String"/"Number"/"Boolean" без оператора "new" – вполне разумно и полезно.
Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
К примеру, следующее вполне допустимо:

	let num = Number("123");	//	превращает строку в число.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объекты "Map", "Set", "WeakMap", "WeakSet".

"Map":

	"Map"	-	это коллекция ключ/значение, как и "Object". Но основное отличие в том, что "Map" позволяет использовать вместо ключа любой тип данных
	(примитив, объект, массив, функция и т.д.). "Map" является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "Map":
	
		let map = new Map([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
	
	Методы и свойства объека "Map":
	
		set(<ключ>, <значение>)	–	записывает по ключу "<ключ>" значение "<значение>".
		
		get(<ключ>)	–	возвращает значение по ключу или "undefined", если ключ "<ключ>" отсутствует.
		
		has(<ключ>)	–	возвращает "true", если ключ "<ключ>" присутствует в коллекции, иначе "false".
		
		delete(<ключ>)	–	удаляет элемент по ключу "<ключ>".
		
		clear()	–	очищает коллекцию от всех элементов.
		
		size	–	возвращает текущее количество элементов.
		
		keys()	–	возвращает итерируемый объект по ключам.
		
		values()	–	возвращает итерируемый объект по значениям.
		
		entries()	–	возвращает итерируемый объект по парам вида "[ключ, значение]", этот вариант используется по умолчанию в цикле "for... of ...".
		
		forEach(function(<значение>, <ключ (опционально)>, <сам объект "Map" (опционально)>){})	-	метод схожий со встроенным методом массивов "Array",
		который принимает колбэк функцию, который в свою очередь принимает текущий элемент объекта "Map", его индекс и сам массив.
		
	Пример создания нового объекта "Map":
	
		let map = new Map();

		map.set("1", "str1");	//	строка в качестве ключа.
		map.set(1, "num1");	//	цифра как ключ.
		map.set(true, "bool1");	//	булево значение как ключ.

		alert(map.get(1)); 	//	"num1".
		alert(map.get("1"));	//	"str1".

		alert(map.size); // 3
		
	Можно использовать объекты в качестве ключей:
		
		let john = { name: "John" };

		// сохраним количество посещений для каждого пользователя.
		let visitsCountMap = new Map();

		// объект "john" - это ключ для значения в объекте "Map".
		visitsCountMap.set(john, 123);

		alert(visitsCountMap.get(john));	//	123
		
	• 	"Map" использует почти такое же сравнение, что и "===", с той лишь разницей, что "NaN" считается равным "NaN". Так что "NaN" также может использоваться в качестве ключа.
	
	Каждый вызов метода "set" у объекта "Map" возвращает объект "Map", так что можно объединить вызовы в цепочку:
	
		map.set("1", "str1").set(1, "num1").set(true, "bool1");
		
	Пример использования методов "keys()", "values()", "entries()":
	
		let recipeMap = new Map([
			["огурец", 500],
			["помидор", 350],
			["лук",    50]
		]);

		//	перебор по ключам (овощи).
		for (let vegetable of recipeMap.keys()) {
			alert(vegetable);	//	огурец, помидор, лук
		}

		//	перебор по значениям (числа)
		for (let amount of recipeMap.values()) {
			alert(amount);	//	500, 350, 50
		}

		// перебор по элементам в формате [ключ, значение]
		for (let entry of recipeMap) {	//	то же самое, что и "recipeMap.entries()".
		alert(entry); // огурец,500 (и так далее)
	
	Пример использования метода "forEach":
	
		recipeMap.forEach((value, key, map) => {
			alert(`${key}: ${value}`); // огурец: 500 и так далее.
		});
		
	У главного объекта "Object" есть метод "entries(<объект>)", который получив на вход объект, вернет его в виде массива с парами ключ-значение. Из такого массива мжно создать
	объект "Map":
	
		let obj = {
			name: "John",
			age: 30
		};

		let map = new Map(Object.entries(obj));
		
	У главного объекта "Object" есть еще метод "fromEntries(<массив>)", который получив на вход масссив (вида пар ключ-значение), вернет обычный объект:
	
		let map = new Map();
		map.set('banana', 1);
		map.set('orange', 2);
		map.set('meat', 4);

		let obj = Object.fromEntries(map.entries());	//	make a plain object.

		// готово!
		// obj = { banana: 1, orange: 2, meat: 4 }

		alert(obj.orange); // 2
		
	Можно писать еще короче:
	
		let obj = Object.fromEntries(map);

"Set":

	"Set"	-	это коллекция из уникальных значений (без ключей), где каждое значение может появиться только раз. Значениями могуть быть любые данные
	(примитив, объект, массив, функция и т.д.). "Set" является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "Set":
	
		let set = new Set([<элементы (опционально)>]);
		
	Методы и свойства объекта "Set":
	
		add(<значение>)	-	добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект "set".
		
		delete(<значение>) – удаляет значение, возвращает "true" если "value" было в множестве на момент вызова, иначе "false".
		
		has(<значение>) – возвращает "true", если значение присутствует в множестве, иначе "false".
		
		clear() – удаляет все имеющиеся значения.
		
		size – возвращает количество элементов в множестве.
		
		keys()	-	возвращает перебираемый объект для значений.
		
		values()	-	то же самое, что и "keys()", присутствует для обратной совместимости с "Map".
		
		entries()	-	возвращает перебираемый объект для пар вида "[<значение>, <значение>], присутствует для обратной совместимости с "Map".
		
		forEach(function(<значение>, <значение (опционально)>, <сам объект "Set" (опционально)>){})	-	метод схож с методом "forEach" объекта "Map", отличается тем,
		что у метода "forEach" объекта "Set" дублируются аргументы "<значение>", так как он имеет только значения, и сделано оно так для обратной совместимости с
		объектом "Map".		
		
	Пример использования объекта "Set":
	
		let set = new Set();

		let john = { name: "John" };
		let pete = { name: "Pete" };
		let mary = { name: "Mary" };

		// считаем гостей, некоторые приходят несколько раз.
		set.add(john);
		set.add(pete);
		set.add(mary);
		set.add(john);
		set.add(mary);

		//	"set" хранит только 3 уникальных значения.
		alert(set.size); // 3
		
	"Set" так же как и "Map" является итерируемым объектом:
	
		let set = new Set(["апельсин", "яблоко", "банан"]);

		for (let value of set) alert(value);

		//	то же самое с "forEach":
		set.forEach((value, valueAgain, set) => {
			alert(value);
		});

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

"WeakMap":

	"WeakMap"	-	это коллекция ключ/значение, как и "Map", оличиями от "Map" являются то что ключами могут быть только объекты, а не примитивы, и то что если объект,
	который является ключом в "WeakMap" будет где-то удален, то и ключ в "WeakMap" будет удален.  "WeakMap" не является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "WeakMap":
	
		let weakMap = new WeakMap([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
		
	Методы объекта "WeakMap":
	
		set(<ключ>, <значение>)	–	записывает по ключу "<ключ>" значение "<значение>".
		
		get(<ключ>)	–	возвращает значение по ключу или "undefined", если ключ "<ключ>" отсутствует.
		
		has(<ключ>)	–	возвращает "true", если ключ "<ключ>" присутствует в коллекции, иначе "false".
		
		delete(<ключ>)	–	удаляет элемент по ключу "<ключ>".
	
	Пример использования объекта "WeakMap":
	
		let weakMap = new WeakMap();

		let obj = {};

		weakMap.set(obj, "ok");	//	работает (объект в качестве ключа).

		//	нельзя использовать строку в качестве ключа.
		weakMap.set("test", "Whoops");	//	Ошибка, потому что "test" не объект.
		
	Пример с ключом-объектом, который будет удален:
	
		let john = { name: "John" };

		let weakMap = new WeakMap();
		weakMap.set(john, "...");

		john = null;	//	перезаписываем ссылку на объект.

		//	объект john удалён из памяти!

"WeakSet":

	"WeakSet"	-	это коллекция из уникальных значений (без ключей), где каждое значение может появиться только раз. Отличием от "Set" является то, что в качестве ключей
	могут быть только объекты. "WeakSet" не является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "WeakSet":
	
		let weakSet = new WeakSet([<элементы (опционально)>]);
		
	Методы объекта "WeakSet":
	
		add(<значение>)	-	добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект "set".
		
		delete(<значение>) – удаляет значение, возвращает "true" если "value" было в множестве на момент вызова, иначе "false".
		
		has(<значение>) – возвращает "true", если значение присутствует в множестве, иначе "false".
		
	Пример использования объекта "WeakSet":
	
		let visitedSet = new WeakSet();

		let john = { name: "John" };
		let pete = { name: "Pete" };
		let mary = { name: "Mary" };

		visitedSet.add(john);	//	"John" заходил к нам.
		visitedSet.add(pete);	//	потом "Pete".
		visitedSet.add(john);	//	"John" снова.

		//	"visitedSet" сейчас содержит двух пользователей.

		//	проверка, заходил ли "John"?
		alert(visitedSet.has(john)); // true

		//	проверка, заходила ли "Mary"?
		alert(visitedSet.has(mary)); // false

		john = null;

		//	структура данных "visitedSet" будет очищена автоматически.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Деструктуризация.

Деструктуризация это синтаксис, который позволяет нам "распаковать" массивы, объекты, строки (любые перебираемые объекты) в кучу переменных/свойств.

• Деструктуризация массивов/строк. Пример синтаксиса деструктуризации массивов/строк:

	let [<переменная/свойство> = <значение по умолчанию (опционально)>, <...rest (опционально)>] = <массив/строка>;
	
В данном примере переменным задаются значения из массива/строки по очереди (на что хватит). Если в массиве/строке больше элементов,
чем присваеваемых переменных/свойств в квадратных скобках, то будут присвоены только те элементы (по порядку), что указаны в квадратных скобках.
Если в массиве/строке меньше элементов, чем присваеваемых переменных в квадратных скобках, то будут присвоены только те элементы (по порядку), которых хватит,
а тем переменным/свойствам, которым не достались значения, будут присвоены "undefined". Пример:

	let [x, y, z] = "abc";

	let arr = [1,2,3];
	
	let [a, b, c, d] = arr;
	
	console.log(a, b, c, d);	//	1, 2, 3, undefined

Ненужные элементы массива/строки для деструктурированного присваивания могут быть отброшены через пустую запятую:

	let [a, , c, d] = arr;
	
	console.log(a, c, d);	//	1, 3, undefined

Остаточные параметры "...rest". Можно указать переменную в конце литерала деструктуризации (квадратных скобок) с тремя точками с переди, и с произвольным именем,
как массив для "оставшихся" параметров/элементов:

	let [name1, name2, ...restArr] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];	//	"restArr" является массивом с двумя оставшимися элементами массива.

	Подробнее в главе "Остаточные параметры и оператор расширения ("Rest" и "Spread")".
	
Значения по умолчанию. Если в массиве/строке меньше значений, чем указанных переменных, то им будет присвоено "undefined". Можно присвоить таким переменным
значения по умолчанию:

	let [name = "Guest", surname = "Anonymous"] = ["Julius"];
	
	console.log(name);	//	"Julius" - из массива.
	console.log(surname);	//	"Anonymous" -  значение по умолчанию.
	
Значения по умолчанию в деструктуризации могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

• Деструктуризация объекта. Деструктуризация объекта такая же как и у массивов и у строк но с некоторыми отличиями. Литерал деструктуризации для объектов это фигурные
скобки. Переменные/свойства в них перечисляются произвольно (не по порядку как в массивах/строках). Имена переменных/свойств должны совпадать с именами свойств в объекте.

Пример синтаксиса деструктуризации объектов:

	let {<переменная/свойство>: <другое имя (опционально)> = <значение по умолчанию (опционально)>, <...rest (опционально)>} = <объект>;
	
Пример деструктуризации объекта:

	let options = {
		title: "Menu",
		width: 100,
		height: 200
	};

	let {width, title, height} = options;
	
При деструктуризация объекта можно указать свойству объекта другое название, для этого новое название нужно указать после двоеточия:

	let options = {
		title: "Menu",
		width: 100,
		height: 200
	};
	
	let {width: w, height: h, title} = options;
	
	console.log(w);	//	100
	
При деструктуризация объекта можно указать свойству объекта значение по умолчанию, для этого значение по умолчанию нужно указать после знака равно. Так же можно совмещать
с указанием нового названия свойства:

	let options = {
		title: "Menu"
	};

	let {width = 100, height: h = 200, title} = options;
	
Как и в случае с массивами/строками, значениями по умолчанию могут быть любые выражения или даже функции.

Остаточные параметры "...rest" при деструктуризации объекта работает так же как и у массивов/строк, за исключением того, что они будут записаны в объект, вместо массива:

	let options = {
		title: "Menu",
		height: 200,
		width: 100
	};
	
	let {title, ...rest} = options;
	
	console.log(rest.height);  // 200
	console.log(rest.width);   // 100
	
Деструктуризация работает с любым перебираемым объектом, а так же обычным объектом:
	
	let [one, two, three] = new Set([1, 2, 3]);
	
	let user = {};
	[user.name, user.surname] = "Ilya Kantor".split(' ');
	
• Чтобы указать деструктуризацию без прямой вставки "let/const/var", нужно облачить все выражение деструктуризации в скобки:

	let title, width, height;

	({title, width, height} = {title: "Menu", width: 200, height: 100});
	
• Вложенная деструктуризация. Если объект или массив содержит другие вложенные объекты или массивы, то можно деструктурировать и их. Для вложенной десруктуризации объекта
нужно указать следующий литерал деструктуризации объекта после двоеточия, а для деструктуризации массива - литерал деструктуризации массива:

	let options = {
		size: {
			width: 100,
			height: 200
		},
		items: ["Cake", "Donut"],
		extra: true
	};
	
	let {size: {width, height}, items: [item1, item2], title = "Menu"} = options;
	
• Деструктуризация для параметров функций. Пример вложенной деструктуризации для входных параметров функций, вместе с параметрами по умолчанию:

	let options = {
		title: "My menu",
		items: ["Item1", "Item2"]
	};

	function showMenu({
		title = "Untitled",
		width: w = 100,  // "width" присваивается к "w".
		height: h = 200, // "height" присваивается к "h".
		items: [item1, item2] // первый элемент "items" присваивается к "item1", второй к "item2".
	}) {}
	
Если не будет передаваться объект в функцию как фходной параметр, то можно указать пустой объет по умолчанию:

	function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
		alert( `${title} ${width} ${height}` );
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дата и время.

Встроенный объект "Date" служит для получения даты и времени. Для создания нового объекта "Date" необходимо вызвать конструктор "new Date()" с необходимыми аргументами.
Пример синтаксиса создания объекта "Date":

	let now = new Date(<аргумент/ты>);
	
Получение даты/времени прошедшего с "1 января 1970 года UTC+0" в миллисекундах. Для этого нужно в качестве аргумента передать миллисекунды, прошедшие начиная с той даты:

	let Jan01_1970 = new Date(0);
	alert( Jan01_1970 );	//	Thu Jan 01 1970 03:00:00 GMT+0300
	
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп.
Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

	let Dec31_1969 = new Date(-24 * 3600 * 1000);	//	31 декабря 1969 года

Если аргумент всего один, и это строка, то из неё "прочитывается" дата. Если конструктору "new Date()" передать дату/время в строковом формате,
то он вернет объект с указанной датой/временем в соответствующем формате. Вид синтаксиса конструктора "new Date()" принимающий дату/время в строковом формате:

	let date = new Date("<год>-<месяц>-<день (опционально)>-<часы (опционально)>-<минуты (опционально)>-<секунды (опционально)>-<миллисекунды (опционально)>");
	
	К данному синтаксису есть требования:
	
		1. Год должен состоять из четырех цифр.
		
		2. Месяц начинается с "0" (январь), по "11" (декабрь).
		
		3. Если день не задан, то он принимается за "1".
		
		4. Если параметры "часы"/"минуты"/"секунды"/"миллисекунды" отсутствуют, то на их месте будет "0".
		
		Пример:
		
			new Date(2011, 0, 1, 0, 0, 0, 0);	//	1 Jan 2011, 00:00:00
			new Date(2011, 0, 1);	//	то же самое, так как часы и проч. равны "0".

Пример создания даты в соответствующем формате передавая дату в строковом виде:

	let date = new Date("2017-01-26");
	console.log(date);	//	Thu Jan 26 2017 03:00:00 GMT+0300
	
Методы объектов, созданных конструктором "Date" (в соответствии с местным часовым поясом):

	Полчучение:

		getFullYear()	-	получить год (4 цифры)
		
		getMonth()	-	получить месяц, от 0 до 11.

		getDate()	-	получить день месяца, от 1 до 31, что несколько противоречит названию метода.

		getHours(), getMinutes(), getSeconds(), getMilliseconds()	-	получить, соответственно, часы, минуты, секунды или миллисекунды.
		
		getDay()	-	вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник,
		в "JavaScript" начало недели приходится на воскресенье. Дни недели в "getDay()" также отсчитываются с нуля, что соответствует воскресенью.
		
		getUTCFullYear(), getUTCMonth(), getUTCDay()	-	возвращение даты/времени для временной зоны "UTS-0".
		
		getTime()	-	для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с "1 января 1970 года UTC+0".
		
		getTimezoneOffset()	-	возвращает разницу в минутах между местным часовым поясом и "UTC".
	
	Установка (опциональные параметры, которые не будут переданы, останутся неизменными):
	
		setFullYear(<год>, <месяц (опционально)>, <день (опционально)>)	-	установить год (остальное опционально).
		
		setMonth(<месяц>, <день (опционально)>)	-	установить месяц (остальное опционально).

		setDate(<день>)	-	установить день.

		setHours(<часы>, <минуты (опционально)>, <секунды (опционально)>, <миллисекунды (опционально)>)	-	установить часы (остальное опционально).

		setMinutes(<минуты>, <секунды (опционально)>, <миллисекунды (опционально)>)	-	установить минуты (остальное опционально).

		setSeconds(<секунды>, <миллисекунды (опционально)>)	-	установить секунды (остальное опционально).

		setMilliseconds(<миллисекунды>)	-	установить миллисекунды.

		setTime(<миллисекунды>)	-	устанавливает дату в виде целого количества миллисекунд, прошедших с "01.01.1970 UTC".
		
Пример установки даты/времени:

	let today = new Date();

	today.setHours(0);
	alert(today);	//	выводится сегодняшняя дата, но значение часа будет "0".

	today.setHours(0, 0, 0, 0);
	alert(today);	//	всё ещё выводится сегодняшняя дата, но время будет ровно "00:00:00".
	
• Автоисправление даты. Если при установке даты указать большее значение (например месяца), то оно автоматически будет перекинуто/распределено на
остальные значения (например год).

Если объект "Date" преобразовать в число, то получим таймстамп по аналогии с "date.getTime()":

	let date = new Date();
	alert(+date);	//	количество миллисекунд, то же самое, что "date.getTime()".
	
Подсчет разности времени:

	let start = new Date();	//	начинаем отсчёт времени.
	
	//	выполняем некоторые действия...
	
	let end = new Date(); // заканчиваем отсчёт времени.
	
	console.log(end - start);	//	49732
	
• Методы объекта "Date":

	now()	-	получение текущей метки времени (миллисекунды). Пример:
	
		console.log( Date.now() );	//	1587424408820
		
	parse(<строка>)	-	данный метод считывает дату из строки. Формат строки должен быть следующим - "YYYY-MM-DDTHH:mm:ss.sssZ", где:
	
		YYYY-MM-DD	-	год-месяц-день.
		
		"T"	-	используется в качестве разделителя.
		
		HH:mm:ss.sss	-	время: часы, минуты, секунды и миллисекунды.
		
		'Z'	-	необязательная часть, обозначает часовой пояс в формате "+-hh:mm". Если указать просто букву "Z", то получим "UTC+0".
		
		Все составляющие кроме "YYYY" являются опциональными.
		
		Пример:
		
			let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

			alert(ms);	//	"1327611110417" (таймстамп).

	

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объект "JSON" ("JavaScript Object Notation)". Формат "JSON" обворачивает все строки в двойные кавычки, а так же имена свойств.
"JSON" поддерживает простые объекты, массивы, строки, числа, логические значения и "null".

	Методы объекта "JSON":
	
		stringify(<целевой объект>, <массив свойств или функция соответствия "function (<ключ>, <значение>)" (опционально)>, <количество пробелов, используемых для форматирования (опционально)>)
		-	метод,  для преобразования объекта в "JSON" формат.
		В данном методе, второй (опциональный) параметр принимает либо массив имен свойств, которые будут выбраны для преобразования, либо функция,
		которая принимает пары "ключ-значение",	и которая должна вернуть замененное	имя свойства, либо "undefined" - чтобы пропустить свойство. При первом вызове данной функции,
		ей передаётся специальный "объект-обёртка": {"": <исходный объект>}. Другими словами, первая "(<key>, <value>) пара имеет пустой ключ, а значением является целевой объект.
		Значение "this" внутри фунции – это объект, который содержит текущее свойство.
		Третий (опциональный) параметр используется для оформления "JSON". В нем указывается количество пробелов в
		цифрах для отступов. Метод "stringify" пропускает циклические ссылки (объект содержащий объект из-вне), методы объектов,
		символьные свойства и свойства со значениями "undefined". Примеры использования метода "stringify":
		
			Пример с указанием массива имен выбираемых свойств:

				let meetup = {
					title: "Conference",
					participants: [{name: "John"}, {name: "Alice"}],
				};

				alert( JSON.stringify(meetup, ['title', 'participants']) );	//	{"title":"Conference","participants":[{},{}]}
				
			Пример с фукцией для замены имен свойств:
			
				alert( JSON.stringify(meetup, function replacer(key, value) {
					alert(`${key}: ${value}`);
					return (key == 'occupiedBy') ? undefined : value;
				}));
				
			Пример с указанием пробелов:
			
				let user = {
					name: "John",
					age: 25,
				};

				alert(JSON.stringify(user, null, 2));	//	отступ в 2 пробела.
		
		parse(<целевой "JSON" объект>, <функция соответствия "function (<ключ>, <значение>)" (опционально)>)	-	метод,  для преобразования "JSON" в объект. В данном методе,
		второй (опциональный) параметр принимает функцию, которая принимает пары "ключ-значение", и которая должна вернуть модифицированное значение,
		либо "undefined" - чтобы пропустить значение.
		Пример:
		
			let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

			let meetup = JSON.parse(str, function(key, value) {
				if (key == 'date') return new Date(value);
				return value;
			});

			alert( meetup.date.getDate() );	//	30
		
• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON" (вызов метода "stringify" у "JSON" для объекта)
подробнее в главе "Преобразование типов".

! Примечание. "JSON" не поддерживает комментарии.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Остаточные параметры и оператор расширения ("Rest" и "Spread").

• Оператор "Rest" собирает "оставшиеся" аргументы/параметры в массив. Он выполняется, при получении (приеме) параметров/аргументов. Указывается он через троеточие "...".
В следующем примере оператор "Rest" с именем "allArgs" собирает в себя все передаваемые функции параметры, и суммирует их:

	function sumAll(text, ...allArgs) {
		console.log(text);
		let sum = 0;
		for (let arg of allArgs) sum += arg;
		return sum;
	}
	
	sumAll("Hello", 1, 4, 1, 4, 5, 6);

Остаточные параметры должны располагаться в конце.

• Оператор расширения (разворота) "Spread" разворачивает перебираемый объект в аргументы. Он выполняется, при передаче (отправлении) перебираемого объекта.
Указывается он так же через троеточие "...". В следующем примере оператор "Spread" с именем "arr" разворачивает массив:

	let arr = [3, 5, 1];
	let arr2 = [8, 9, 15];
	let merged = [0, ...arr, 2, ...arr2];
	
	console.log(merged);	//	0,3,5,1,2,8,9,15
	
Оператор "Spread" работает так же и со строками, так как они являются перебираемыми объектами:

	let str = "Привет";

	console.log( [...str] );	//	П,р,и,в,е,т


• Разница операторов "Rest" и "Spread" в том, где и как их использовать: "Rest" - при приеме параметров, "Spread"  - при передаче параметров.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	















































-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Список Методов/Функций "JavaScript" (Общее).


alert(<передаваемое содержимое>);

	Выведет окно с передаваемым ему содержимым при этом останавливая выполнение скрипта до тех пор пока не будет нажата кнопка "OK" (или "ЗАКРЫТЬ").
	Например:
	
		alert("Hello");
	
	
	
prompt(<текст для отображения в окне>, <содержимое по умолчанию (опционально)>);

	Отобразит модальное окно с переданным текстом, полем для ввода текста и кнопками "OK/Отмена". В поле для ввода можно указать значение по умолчанию.
	Данная функция вернет содержимое поля для ввода, если оно было заполнено, а если будет отменено, то вернет "null".
	Например:
	
		prompt("Укажите свой возраст", "18");
	
	Примечание:	Второй параметр является необязательным, но если не указать его, то "Internet Explorer" установит значение "undefined" в поле для ввода.
	
	
	
confirm(<вопрос>);

	Функция "confirm" отображает модальное окно с текстом вопроса и двумя кнопками "OK" и "Отмена". Данная функция вернет "true", если нажата кнопка "OK".
	В других случаях – "false".
	
	Например:
	
		confirm("Вам больше 18?");



isNaN(<аргумент>);

	Для проверки является ли аргумент "NaN".

	

isFinite(<аргумент>);

	Для проверки является ли аргуент обычным числом, т.е. не "NaN"/"Infinity"/"-Infinity".



setTimeout(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);

	Позволяет вызвать функцию один раз через определённый интервал времени. Аргументы, передаваемые в функцию не поддерживается в "IE9-".
	"setTimeout" с нулевой задержкой начинает выполняться только после выполнения текущего кода.
	
	Пример:
	
		function sayHi(phrase, who) {
			alert( phrase + ', ' + who );
		}

		setTimeout(sayHi, 1000, "Привет", "Джон");

	Рекурсивный "setTimeout":
	
		let timerId = setTimeout(function tick() {
			alert('tick');
			timerId = setTimeout(tick, 2000);
		}, 2000);
		
		
		
clearTimeout(<идентификатор "setTimeOut">);

	Отмена заданного интервала через идентификатор.
	
	Пример:
	
		let timerId = setTimeout(...);
		clearTimeout(timerId);



setInterval(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);

	Позволяет вызывать функцию много раз через определённый интервал времени. В большинстве браузеров, включая "Chrome" и "Firefox",
	внутренний счётчик продолжает тикать во время показа "alert"/"confirm"/"prompt".
	Рекурсивный "setTimeout" позволяет задать задержку между выполнениями более точно, чем "setInterval".



clearInterval(<идентификатор "setInterval">);

	Отмена заданного интервала через идентификатор.
	
	Пример:
	
		let intervalId = seInterval(...);
		clearInterval(intervalId);




























• Методы и свойства объекта "Math":

	Math.floor();

		Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
		
	Math.ceil();

		Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
		
	Math.round();

		Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
		
	Math.trunc();
	
		Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
		Не поддерживается в "Internet Explorer".
		
	Math.random();
	
		Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1).
		
	Math.max(<аргументы>);
	Math.min(<аргументы>);
	
		Возвращает наибольшее/наименьшее число из перечисленных аргументов.
		
	Math.pow(<число>, <степень>);
	
		Возвращает число, возведённое в степень.






















