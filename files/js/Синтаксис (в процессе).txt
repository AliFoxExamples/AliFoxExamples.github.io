-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Синтаксис - операторы языка "JavaScript".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Виды синтакцсиса "JavaScript":

	1. Вложенный ("Embedded"). С помощью вложенного "JavaScript" можно добавлять скрипты в "HTML", через тег "<script>" в самом "HTML"
	документе, где сам скрипт будет распологаться в контейнере тега "<script>". Вложенный тег "<script>" может находиться в контейнере
	тега "<head>" или тега "<body>". Скрипт можно разместить в конце тега "<body>", чтобы страница загрузилась быстрее. Вид синтаксиса
	вложенного "JavaScript" соответствует синтаксису файла внешнего "JavaScript".

	Пример использования вложенного "JavaScript":

		<head>	
			<script type="text/javascript">
				alert("Hello");
			</script>
		</head>
		
		или
		
		<body>	
			<script type="text/javascript">
				alert("Hello");
			</script>
		</body>
		
	2. Внешний ("External"). С помощью внешнего "JavaScript"  можно добавлять скрипты в "HTML", через внешний "JavaScript" документ с
	расширением ".js". Этот документ подключается в документу "HTML" через тег "<script>", который обязательно должен распологаться
	в контейнере тега "<head>". В теге "<script>" будет обязательный атрибут "src="..."", где на месте "..." - будет сама "URL" адрес
	на документ (относительный или абсолютный).

	Пример подключения внешнего "CSS":

		<head>	
			<script src="myscript.js"></script>
		</head>
		
	Если указан атрибут "src", то содержимое контейнера тега игнорируется.
	
	Существуют два атрибута для тега "<script>" "defer" и "async". Подробнее в синтаксисе "HTML" - "Синтаксис - Атрибуты".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Правила языка "JavaScript":

	1.	Если при объявлении переменной (тестовой) были использованы кавычки типа """, то внутри самих кавычек, данный тип не может
	использоваться, а могут использоваться только типа "'", так как внутри и снаружи не должен быть использован один и тот же тип
	кавычек. Или же наоборот, если при объявлении переменной (тестовой) были использованы кавычки типа "'", то внутри самих кавычек,
	данный тип не может использоваться, а могут использоваться только типа """, так как внутри и снаружи не должен быть использован один и
	тот же тип кавычек.
		
	Например:

		<script>
			let x = "'Джон'";
		</script>
		
		или
		
		<script>
			let x = '"Джон"';
		</script>
		
	Если все же необходимо использовать кавычки такого же типа, что и снаружи, то перед кавычками, внутри внешних кавычек следует поставить
	управляющий символ "\".

	Например:

		<script>
			let x = '\'Джон\'';
		</script>
		
		или
		
		<script>
			let x = "\"Джон\"";
		</script>
		
	Все примеры использования управляющего символа "\" приведены ниже в пункте "Примеры использования управляющего символа "\".

	Так же если необходимо отобразить управляющий символ "\", то перед ним нужно так же поставить управляющий символ "\":

	Например:

		<script>
			document.write=("Вывод символа \\ на экран");
		</script>
		
		
		
	2. Директива ""use strict";". Данная директива введена и спользуется для того, чтобы активировать "строгий режим" кода (перевод кода режим полного соответствия
	современного стандарта синтаксиса "JavaScript". Некоторые библиотеки, которые написаны без ""use strict";", не всегда корректно работают, если
	вызывающий код содержит "'use strict';". Некоторые функции языка, такие как «классы» и «модули», автоматически включают строгий режим.
	
		Ообенности строгого режима:
		
			1. В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.
			
			2. В строгом режиме вызов "this" без объекта = "undefined".
			
			3. В строгом режиме попытка присвоения свойства примитиву (через точку ".") вернет ошибку.
			
			4. В строгом режиме попытка выпонить операции с объектом/свойством, запрещенные дескриптором свойства, приведет к ошибке.
			
			5. В строгом режиме у "eval" имеется своё лексическое окружение.
			
			6. В строгом режиме объявление переменной без ключевых слов "var","let","const" вызовет ошибку.
		
	3.  Рекомендуется ставить точку с запятой после выражения (на усмотрение), если после нее идет самовызываемая функция ("IIFE").
	
	4. Лексическое окружение существует для любых блоков кода "{...}" ("if", "for", "function" и т.д.).
	
	5. Можно объединять/группировать блоки кода в фигурные скобки, для изоляции переменных в "локальной области видимости":
	
		{
			// блок кода
			let message = "Hello";

			alert( message );
		}
		
	Примечание. В нестрогом режме, функции объявленные через "Function Decaration" в блоках кода будут видны за ее пределами.
		
	6. Существует всеобщее соглашение о том, что свойства объектов, которые начинаются с символа "_", являются внутренними, и к ним не следует обращаться напрямую из-за пределов
	объекта.
	
	7. Если в условии, или цикле, выполняемое выражение одно, то можно фигурные скобки не ставить:

		if (a == b) alert("Hi");
	
	8. Если переменные именуются через символ "$", то принято считать что они содержат в себе "node" элемент "DOM" дерева.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объявление переменных.

Переменные в "JavaScript" могут объявляться с помощью ключевых слов "var", "let", "const". "var" является устаревшим. Рекомендуется использовать "let" или "const".
При объявлении переменной с помощью ключевого слова "let", значение переменной можно изменять с дальнейшем, а переобъявлять имя переменной нельзя.
При объявлении переменной с помощью ключевого слова "const",  в дальнейшем нельзя изменять значение переменной, а так же переобъявлять имя переменной. Исключением же является
изменение содержимого массива или объекта, созданного с помощью ключевого слова "const". Содержимое таких массивов и объектов изменять можно.
В строгом режиме "'use strict';" объявление переменной без ключевых слов "var","let","const" вызовет ошибку.

Синтаксис объявления переменной на примере "let":

	let <имя_переменной> = <значение>

		Ключевое слово для объявления переменных, где на месте "<имя_переменной>" - будет имя переменной, а на месте "<значение>" будет
		значение переменной. "JavaScript" чувствителен к регистру текста, так что символ "x" нижнего регистра не равен
		символу "X" верхнего регистра (то есть выражения "var x = 10;" и "var X = 10;" не одно и тоже).
		
		Первым символом имени переменной могут быть буквы или символы "_", "$". Последующими символами могут быть буквы, цифры
		символы "_", "$".
		Имена переменных не могут начинаться с чисел, и не могут содержать в себе пробелы и математические операторы
		("+", "-", "*" и тд.).
		В именах переменных так же не могут присутствовать специальные символы "#", "%" и тд.
		Имена переменных содержащие несколько слов принято писать сначала со строчной буквы, а затем с заглавной. Например:
		
			let userName = "Alex";
			
		В именах переменных не могут содержаться следующие зарезервированные в "JavaScript" слова:
		
			abstract
			boolean
			break
			byte
			case
			catch
			char
			class
			const
			continue
			debugger
			default
			delete
			do
			double	else
			enum
			export
			extends
			false
			final
			finally
			float
			for
			function
			goto
			if
			implements
			import
			in	instanceof
			int
			interface
			long
			native
			new
			null
			package
			private
			protected
			public
			return
			short
			static
			super	switch
			synchronized
			this
			throw
			throws
			transient
			true
			try
			typeof
			var
			void
			volatile
			while
			with

		Способы объявления переменной:
		
			1. Объявление и присваивание переменной в одной строке:
			
				let x = 1;
				
			2. Объявление и присваивание переменной в разных строках:
			
				let x;
				x = 1;
				
			3. Объявление и присваивание нескольких переменных в нескольких строках:
			
				let x;
				let y;
				x = 1;
				y = 2;
				
			4. Объявление нескольких переменных в одной строке, и присваивание нескольких переменных:
			
				let x, y;
				x = 1; y = 2;
				
			5. Объявление и присваивание нескольких переменных в одной строке:
			
				let x = 1, y = 2;
				
				Для удобства читаемоси можно разбить по строкам:
				
					let x = 1,
						y = 2;
						
Константы в верхнем регистре. Константы записанные в верхнем регистре, являются общепринятымы "жестко закодированными" переменными (когда значение известно до выполнения
скрипта и записывается непосредственно в код). Например:

	const COLOR_ORANGE = "#FF7F00";
	
	К примеру следующий пример не требует букв в верхнем регистре, так как значение переменной не объявляется изначально, а зависит от результата функции "someCode()".
	
	const age = someCode(BIRTHDAY);
	
• Особенности переменной объявленной с помощью "var":

	1. Для "var" не существует блочной области видимости. Область видимости переменных "var" ограничивается либо функцией, либо, если переменная глобальная, то скриптом.
	Такие переменные доступны за пределами блока.
	
	2. Объявления переменных "var" обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной). Объявления переменных "всплывают",
	но присваивания значений – нет.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типы данных.

Примитивные типы данных:

	1. "Number"	-	(число). Числовой тип данных  представляет как целочисленные значения, так и числа с плавающей точкой. Подробнее о типах, методах и способах записи чисел в
	главе "Числа".

		"Infinity". Представляет собой математическую бесконечность "∞". Это особое значение, которое больше любого числа. Мы можем получить его в результате деления на ноль:

			alert( 1 / 0 );
			
			Или задать его явно:

				alert( Infinity );

	2. "NaN"	-	("Not a Number" - не число). Означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
	
		Для проверки является ли аргумент "NaN":
		
			isNaN(<аргумент>);

		alert( "не число" / 2 );
		
		Любая операция с "NaN" возвращает "NaN".

	3. "BigInt". Тип данных для хранения больших целых чисел. Чтобы создать значение типа "BigInt", необходимо добавить "n" в конец числового литерала,
	или вызвать функцию "BigInt", которая создаст число типа "BigInt" из переданного аргумента. Аргументом может быть число, строка и др.
	
		Примеры:

			let bigInt1 = 1234567890123456789012345678901234567890n;
			
			let bigInt2 =  BigInt("1234567890123456789012345678901234567890");
			
			let bigInt3 =  BigInt(1234567890123456789012345678901234567890);
			
		Примечание. В данный момент "BigInt" поддерживается только в браузерах "Firefox" и "Chrome", но не поддерживается в "Safari"/"IE"/"Edge".
		
		"BigInt" можно использовать как обычные числа, к примеру:
		
			console.log(1n + 2n);	//	3n
			
			console.log(5n / 2n);	//	2n
		
		Все операции с числами типа "bigint" возвращают "bigint". Нельзя смешивать "bigint" и обычные числа:

			console.log(1n + 2);	//	Error: Cannot mix BigInt and other types
		
		Можно обратно конвертировать "bigint" в обычное число:
		
			let bigint = 1n;
			
			let number = Number(bigint);
		
		Конвертирование "bigint" в число всегда происходит неявно и без генерации ошибок, но если значение "bigint" слишком велико и не подходит под тип "number",
		то дополнительные биты будут отброшены.
		
		К "BigInt" числам нельзя применить унарный оператор "+":
		
			let bigint = 1n;

			+bigint;	//	SyntaxError: Unexpected identifier
		
		Операции сравнения, такие как "<", ">", работают с "bigint" и обычными числами как обычно:
		
			console.log(2n > 1n);	//	true
			
			console.log(2n > 1);	//	true
		
		Обычные числа и "bigint" числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении "==":
		
			console.log( 1 == 1n );	//	true

			console.log( 1 === 1n );	//	false
		
		В булевых значениях "BigInt" работают так же как и обычные числа:
		
			Boolean(0n);	//	false
			
			Boolean(1n);	//	true
		
		Логические операторы "||", "&&" и другие также работают с "bigint" числами как с обычными числами:
		
			console.log(1n || 2)	//	2
		
			console.log(1n || 0)	//	1

	4. "String"	-	(строка).  Подробнее в главе "Строки".
	
	5. "Boolean"	-	(булевый тип). "true" - истинно, "false" - ложь.
	
	6. "Null"	-	(ничего).
	
	7. "Undefined"	-	(не определено). Данный тип данных означает, что значение не было присвоено.
	
	8. "Symbol".
	
Особенные типы данных:

	9. "Object".
		
• Оператор "typeof". Возвращает тип аргумента. Примеры:

	typeof undefined // "undefined"

	typeof 0 // "number"

	typeof 10n // "bigint"

	typeof true // "boolean"

	typeof "foo" // "string"

	typeof Symbol("id") // "symbol"

	typeof Math // "object" 

	typeof null // "object" 
	
		Результатом вызова "typeof null" является "object". Это неверно.
		Это официально признанная ошибка в "typeof", сохранённая для совместимости.
		Конечно, "null" не является объектом. Это специальное значение с отдельным типом.

	typeof alert // "function"
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Числа.

Способы записи числа:

	Десятичные числа:

		Явное указание числа:

			let billion = 1000000000;
			
		Использование ключевой буквы "e":

			let billion = 1e9;
			
				Число после буквы "e" указывает на количество нулей после нее. Другими словами, "e" производит операцию умножения числа на 1 с указанным количеством нулей.
			
		Чтобы указать число с плавающей с множеством нулей, можно использовать отрицательное число после буквы "e":

			let ms = 0.000001;
			
			let ms = 1e-6;	//	шесть нулей, слева от 1.
			
	Шестнадцатеричные числа:

		Указание символов "0x", после чего идет само число в данном формате:
		
			console.log( 0xff );	//	255
			
			console.log( 0xFF );	//	255 (тоже самое, регистр не имеет значения).
			
	Восьмеричные, и двоичные числа:

		Указание символов "0b" (для двоичной системы), и "0o" (для восьмеричной системы) после чего идет само число в данном формате:
		
			let a = 0b11111111;	//	бинарная форма записи числа 255.
			let b = 0o377;	//	восьмеричная форма записи числа 255.

			alert( a == b );	//	true, с двух сторон число 255.

• Для проверки, является ли аргуент конечным числом, у объекта "Number" есть метод "isFinite(<аргумент>)".
Есть большая разница между методом "isFinite(<аргумент>)" объекта "Number" и глобальным методом "isFinite(<аргумент>)".
Метод объекта "Number" "isFinite(<аргумент>)" проверяет является ли аргумент конечным числом, без принудительной конвертации в числовой тип.
Глобальный метод "isFinite(<аргумент>)" может конвертировать в числовой тип все, кроме "NaN"/"Infinity"/"-Infinity", а затем проверить является ли аргуент конечным числом.

• Для проверки, является ли аргуент целым числом, у объекта "Number" есть метод "isInteger(<аргумент>)". Если значение "NaN" или "Infinity", то возвращает "false".
Метод также возвращает "true", если это вещественное число с точкой, которое может быть представлено в целочисленном виде (например "20.0" это тоже что и "20").

• В "JavaScript" самым маленьким числом является "5e-324". Числа меньше него будут конвертированы в "0".

Примечание! Пустая строка интерпретируется как 0 во всех числовых функциях, включая "isFinite()".
		
• Потеря точности.

Решение проблемы с "0.1 + 0.2 != 0.3":

	let sum = 0.1 + 0.2;
	console.log( sum.toFixed(2) );	//	0.30

Округление чисел. В "JavaScript" числа будет округлено до целого, если оно будет иметь больше 14 нулей, после запятой.
Например:

	5.000000000000001	==	5.000000000000001
	
	5.0000000000000001	==	5

Потеря точности с длинным числом:

	console.log( 9999999999999999 );	//	покажет 10000000000000000.
	
• Методы у чисел:

	toFixed(<n>);

		Округляет число до "<n>" знаков после запятой и возвращает строковое представление результата.
		Результатом "toFixed()" является строка. Пример:
		
			let num = 12.34;
			
			console.log( num.toFixed(1) );	//	"12.3"
			
		Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:
		
			let num = 12.34;

			console.log( num.toFixed(5) );	//	"12.34000", добавлены нули, чтобы получить 5 знаков после запятой.
	
	toLocaleString([<локали>, [<опции (опционально)>] (опционально)])	-	подробнее в главе 'Интернационализация ("Intl")',
	в подглаве 'Методы в объектах "Date", "String", "Number"'.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Строки.

Строки в "JavaScript" кодируются в формате "UTF-16".
Способы записи строк:

	Кавычки:
	
		let single = 'одинарные кавычки';
		let double = "двойные кавычки";

		let backticks = `обратные кавычки`;
		
		Текст с обратными кавычками можно записывать в нескольких строках:
		
			let guestList = `Guests:
			 * John
			 * Pete
			 * Mary
			`;
			
		С помощью обратных кавычек можно интерполяцию строк. Подробнее в главе "Интерполяция строк".
		С помощью обратных кавычек также можно пользоваться функцией шаблонизации, подробнее в главе "Функции".
		
• Спецсимволы. Подробнее в главе "Примеры использования управляющего символа".

У строк можно вызвать свойство "length", которое вернет длину строки (количество символов):

	console.log( "abc".length );	//	3
	
У строк можно получить определенный символ с помощью квадратных скобок "[<позиция>]" или с помощью метода "charAt(<позиция>)":

	console.log( "Hello"[0] )	//	H
	console.log( "Hello".charAt(0) )
	
	Разницей этих двух вариантов получения символа в указанной позиции в том, что при использовании квадратных скобок "[<позиция>]", если в указанной позиции нет символа,
	то она вернет "undefined", а при использовании метода "charAt()" она вернет пустую строку.
	
Так же можно перебрать строку с помощью цикла "for of":

	for (let char of "Hello") {
		console.log(char);	//	H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.).
	}
	
Изменение регистра:

	Верхний регистр:
	
		console.log( "hello".toUpperCase() )	//	HELLO
		
	Нижний регистр:
	
		console.log( "HELLO".toLowerCase() )	//	hello
		
	Если мы захотим перевести в нижний регистр какой-то конкретный символ:

		console.log( 'Interface'[0].toLowerCase() );	//	'i'.
		
Удаление пробелов по сторонам строки. Для этого есть метод "trim()":

	console.log( " hello ".trim() );	//	hello

Повторение строки. У строки можно вызвать метод "repeat(<количество раз>)", который будет повторять строку в указанное количество раз.

• Поиск позиции подстроки.

Метод - "indexOf(<подстрока>, <позиция (опционально)>)". Он ищет подстроку в строке, начиная с указанной позиции,
и возвращает позицию, на которой располагается совпадение, либо "-1" при отсутствии совпадений:

	let str = 'Widget with id';
	
	console.log( str.indexOf('Widget') );	//	0, потому что подстрока 'Widget' найдена в начале.

	console.log( str.indexOf('widget') );	//	-1, совпадений нет, поиск чувствителен к регистру.

	console.log( str.indexOf("id") );	//	1, подстрока "id" найдена на позиции 1 (..idget with id).
	
	Необязательный второй аргумент позволяет начать поиск с определённой позиции.
	Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

		let str = 'Widget with id';

		console.log( str.indexOf('id', 2) )	//	12
		
Метод - "lastIndexOf(<подстрока>, <позиция (опционально))" схож с методом выше, но он ищет с конца строки к её началу.
Он используется тогда, когда нужно получить самое последнее вхождение - перед концом строки или начинающееся до (включительно) определённой позиции.

Метод - "includes(<подстрока>, <позиция (опционально)>)". Данный метод возвращает "true", если в строке есть подстрока, либо "false", если нет. Пример:

	console.log( "Widget with id".includes("Widget") );	//	true

	console.log( "Hello".includes("Bye") );	//	false
	
	В методе также есть необязательный второй аргумент, который позволяет начать поиск с определённой позиции.
	
Методы "startsWith(<подстрока>)" и "endsWith(<подстрока>)" проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

	console.log( "Widget".startsWith("Wid") ); //	true, "Wid" — начало "Widget".

	console.log( "Widget".endsWith("get") ); //	true, "get" — окончание "Widget".
	
• Получение подстроки.

Метод "replace(<регулярное выражение>, <заменяемая строка>|<заменяющая функция>)". Подробнее в главе 'Регулярные выражения "RegEx"'.

Метод "slice(<позиция начала>, <позиция конца (опционально)>)" возвращает часть строки от начальной позиции до (не включая) конечной позиции.
Если не указана конечная позиция, то будет возвращена подстрока от начальной позиции до самого конца. Примеры:

	let str = "stringify";

	console.log( str.slice(0, 5) );	//	'strin', символы от 0 до 5 (не включая 5).

	console.log( str.slice(0, 1) );	//	's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0.

	console.log( str.slice(2) );	//	ringify, с позиции 2 и до конца.
	
	Также для позиций начала и конца можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:
	
		let str = "stringify";

		// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа.
		console.log( str.slice(-4, -1) ); // gif
		
Метод "split(<разделитель>, <количество элементов (опционально)>" разбивает строку на массив, по заданному разделителю и на заданное количество
элементов (опционально). Вызов данного метода с пустыми аргументами разбил бы строку на массив букв. Пример:

	'Вася, Петя, Маша, Саша'.split(', ', 2);

	alert(arr);	//	Вася, Петя

Метод "substring(<позиция начала>, <позиция конца (опционально)>)" возвращает часть строки между начальной и конечной позицией.
Данный метод схож с методом выше ("slice()"), за исключением что позиция конца может быть больше чем позиция начала, так как она все равно возвращает то что между ними:

	let str = "stringify";

	// для substring эти два примера — одинаковы
	console.log( str.substring(2, 6) );	//	"ring".
	console.log( str.substring(6, 2) ); //	"ring".

	// …но не для slice:
	console.log( str.slice(2, 6) ); //	"ring" (то же самое).
	console.log( str.slice(6, 2) ); //	"" (пустая строка).
	
	В отличие от метода "slice()", метод "substring()" отрицательные значения не поддерживает, т.к. они интерпретируются как 0.
	
Метод "substr(<позиция начала>, <длина подстроки (опционально)>)" возвращает часть строки он начальной позиции на указанную длину:

	let str = "stringify";
	
	//	ring, получаем 4 символа, начиная с позиции 2.
	console.log( str.substr(2, 4) );

	Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

		let str = "stringify";
		
		//	gi, получаем 2 символа, начиная с позиции 4 с конца строки.
		console.log( str.substr(-4, 2) );
		
	У данного метода есть недостаток - он может не поддерживаться в средах отличных от браузера.
	
• Коды символов.

Метод "codePointAt(<позиция>)" возвращает код символа в формате "UTF-16" на указанной позиции:

	// одна и та же буква в нижнем и верхнем регистре будет иметь разные коды.
	console.log( "z".codePointAt(0) ); //	122
	console.log( "Z".codePointAt(0) ); //	90
	
	Методу "codePointAt()" существует обратный метод у объекта "String" - "fromCodePoint(<код в формате "UTF-16">)", который возвращает символ по его коду:
	
		console.log( String.fromCodePoint(90) ); //	Z
		
		Также можно добавлять юникодные символы по их кодам, используя "\u" с шестнадцатеричным кодом символа:
		
			// "90" — это "5a" в шестнадцатеричной системе счисления.
			console.log( '\u005a' ); //	Z
			
	Оба этих метода умеют работать с суррогатными парами.

Метод "localeCompare(<строка>, [<локали>, [<опции (опционально)>] (опционально)])" возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

	1. Отрицательное число, если строка, у которой был вызван этот метод меньше чем "<строка>".

	2. Положительное число, если строка, у которой был вызван этот метод больше чем "<строка>"..

	3. "0", если строки равны.
	
	Пример:
	
		console.log( 'Österreich'.localeCompare('Zealand') ); // -1

	У этого метода есть два дополнительных аргумента, которые указаны в документации.
	Первый позволяет указать язык (локали) (по умолчанию берётся из окружения) — от него зависит порядок букв.
	Второй — определить, дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".
	
	Подробнее в главе 'Интернационализация ("Intl")' в подглаве 'Методы в объектах "Date", "String", "Number"'.

• Суррогатные пары.

Многие символы возможно записать одним 16-битным словом: это и буквы большинства европейских языков, и числа, и даже многие иероглифы. Но 16 битов — это 65536 комбинаций,
так что на все символы этого, разумеется, не хватит. Поэтому редкие символы записываются двумя 16-битными словами — это также называется "суррогатная пара".
Длина таких строк ("length") — 2:

	console.log( '𝒳'.length ); //	2

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Преобразование типов.

Строковое преобразование:

	String(<аргумент>);
	
Численное преобразование:

	Number(<аргумент>);

		undefined	-	преобразуется в "NaN".
		
		null	-	преобразуется в "0".

		true / false	-	преобразуется в "1 / 0".

		string	-	пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то "0", иначе из непустой строки "считывается число".
		При ошибке результат "NaN".
		
	<number>.toString(<base>);
	
		Данный метод возвращает строковое представление числа "<number>" в системе счисления "<base>".
		"<base>" может варьироваться от 2 до 36 (по умолчанию 10). Пример:

			let num = 255;

			console.log( num.toString(16) );	//	ff
			console.log( num.toString(2) );	//	11111111
			
		Чтобы использовать данный метод непосредственно на числе, нужно указать метод с двумя точками:
		
			console.log( 123456..toString(36) );	//	2n9c
			
		Если мы поставим одну точку, тогда это будет ошибкой, поскольку синтаксис "JavaScript" предполагает,
		что после первой точки начинается десятичная часть числа. А если поставить две точки, то "JavaScript" понимает,
		что десятичная часть отсутствует, и начинается метод.

		Также можно записать как:
		
			console.log( (123456).toString(36) )
			
	Для изъятия числа из строки (первое встречаемое число в строке) используют функции "parseInt(<аргумент>, <система счисления(опционально)>)" - для целых чисел,
	и "parseFloat(<аргумент>, <система счисления(опционально)>)" - для чисел с плавающей точкой. Примеры:
	
		console.log( parseInt('100px') );	//	100
		console.log( parseFloat('12.5em') );	//	12.5

		console.log( parseInt('12.3') );	//	12, вернётся только целая часть.
		console.log( parseFloat('12.3.4') );	//	12.3, произойдёт остановка чтения на второй точке.
		
		Функция "parseInt()" имеет необязательный второй параметр. Он определяет систему счисления, таким образом "parseInt()" может также читать строки
		с шестнадцатеричными числами, двоичными числами и т.д. (максимально до 36-ричными числами):
		
			console.log( parseInt('0xff', 16) );	//	255
			console.log( parseInt('ff', 16) );	//	255, без 0x тоже работает

			console.log( parseInt('2n9c', 36) );	//	123456
	
Логическое преобразование. Значения, которые интуитивно "пустые", вроде "0", пустой строки, "null", "undefined" и "NaN", становятся "false".
Все остальные значения становятся "true". Пример:

	console.log ( Boolean(1) ); // true
	
	console.log ( Boolean(0) ); // false

	console.log ( Boolean("Привет!") ); // true

	console.log ( Boolean("") ); // false
	
Некоторые языки (к примеру, "PHP") воспринимают строку "0" как "false". Но в "JavaScript", если строка не пустая, то она всегда "true". Пример:

	console.log ( Boolean("0") ); // true
	
	console.log ( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)

• Строковые операторы:

	+	-	оператор соединения (конкатенации) значений. Используется в скобках функций (методов) для соединения значений. Например:
	
		let string1 = "Java";
		let string2 = "Script";
		document.write(string1 + string2); // JavaScript
			
		console.log ( 1 + '2' ); // '12'
		
		console.log ( '1' + 2 ); // '12'
		
Примеры с преобразованиями типов данных:

	"" + 1 + 0 // "10"
	
	"" - 1 + 0 // -1

	true + false // 1

	6 / "3" // 2

	"2" * "3" // 6

	4 + 5 + "px" // "9px"

	"$" + 4 + 5 // "$45"

	"4" - 2 // 2

	"4px" - 2 // NaN

	7 / 0 // Infinity

	" -9  " + 5 // " -9  5"

	" -9  " - 5 // -14

	null + 1 // 1

	undefined + 1 // NaN

	" \t \n" - 2 // -2
	
		Пробельные символы, такие как "\t" и "\n" по краям строки игнорируются при преобразовании в число,
		так что строка "\t" "\n", аналогично пустой строке, становится "0" после численного преобразования.
		
• Примитив как объект.

Для примитивов создается "объект-обертка" на время вызова метода у него, а затем удалятся.
Каждый примитив имеет свой собственный "объект-обёртку", которые называются: "String", "Number", "Boolean" и "Symbol".
Таким образом, они имеют разный набор методов.
К примеру, существует метод "str.toUpperCase()", который возвращает строку в верхнем регистре:

		let str = "Привет";

		console.log( str.toUpperCase() );	//	ПРИВЕТ
		
		Что происходит во время вызова метода "toUpperCase" у строки:
		
			1. Строка "str" – примитив. В момент обращения к его свойству, создаётся специальный объект,
			который знает значение строки и имеет такие полезные методы, как "toUpperCase()".
			
			2. Этот метод запускается и возвращает новую строку.
			
			3. Специальный объект удаляется, оставляя только примитив "str".
			
Для чисел так же создаются "объекты-обертки", например метод "toFixed()":

	let n = 1.23456;

	console.log( n.toFixed(2) );	//	1.23

Использование конструкторов для "String", "Number", "Boolean" - в главе "Конструкторы".

"null"/"undefined" не имеют методов.

Особенные примитивы "null" и "undefined" являются исключениями. У них нет соответствующих "объектов-обёрток", и они не имеют никаких методов.
Попытка доступа к свойствам такого значения возвратит ошибку:

	console.log(null.test);	//	ошибка.
	
Присвоение свойства примитиву. 
	
	Пример:
	
		let str = "Привет";

		str.test = 5;

		console.log(str.test);
		
	В зависимости от того, используется ли строгий режим ('"use strict"') или нет, результат может быть:
	
		1. undefined	-	(без strict).
		
		2. Ошибка	-	(strict mode).
	
	В момент обращения к свойству "str" создаётся "объект-обёртка". В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
	Без строгого режима, операция продолжается, объект получает свойство "test", но после этого он удаляется,
	так что на последней линии "str" больше не имеет свойства "test".		

• Преобразование объектов в примитивы.

1. Все объекты в логическом контексте являются "true". Существуют лишь их численные и строковые преобразования.

2. Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции.
Например, объекты "Date"  могут вычитаться, и результатом "date1 - date2" будет временной отрезок между двумя датами.

3. Что касается строковых преобразований – они обычно происходят, когда мы выводим объект "alert(obj)", а также в других случаях, когда объект используется как строка.
	
Три варианта преобразования объектов к примитивам (три хинта):

	1. Для преобразования объекта к строке, когда операция ожидает получить строку, например "alert()" ("string"):
			
		alert(obj);	//	Вывод.

		anotherObj[obj] = 123;	//	Используем объект в качестве имени свойства.
		
	2. Для преобразования объекта к числу, в случае математических операций ("number"):
		
		let num = Number(obj);	//	Явное преобразование

		//	Математическое (исключая бинарный оператор "+").
		let n = +obj; // Унарный плюс.
		let delta = date1 - date2;
		
		let greater = user1 > user2;	//	Сравнения больше/меньше.
		
	3. Вариант по умолчанию ("default"):
		
		let total = car1 + car2;	//	бинарный плюс.

		if (user == 1) { ... };	//	obj == string/number/symbol
		
В процессе преобразования движок "JavaScript" пытается найти и вызвать три следующих метода объекта:

	1. Вызывает "obj[Symbol.toPrimitive](hint)" – метод с символьным ключом "[Symbol.toPrimitive]" (системный символ), если такой метод существует, и передаёт ему хинт.
	
	2. Иначе, если хинт равен "string", пытается вызвать "obj.toString()", а если его нет, то "obj.valueOf()", если он существует.
	
	3. В случае, если хинт равен "number" или "default" пытается вызвать "obj.valueOf()", а если его нет, то "obj.toString()", если он существует.
	
Метод "[Symbol.toPrimitive]". Метод с таким названием (если есть) используется для всех преобразований:

	obj[Symbol.toPrimitive] = function(hint) {
		//	должен вернуть примитивное значение
		//	hint равно чему-то одному из: "string", "number" или "default"
	};
	
Пример использования метода "[Symbol.toPrimitive]":

	let user = {
		name: "John",
		money: 1000,

		[Symbol.toPrimitive](hint) {
			alert(`hint: ${hint}`);
			return hint == "string" ? `{name: "${this.name}"}` : this.money;
		}
	};

	//	демонстрация результатов преобразований:
	alert(user);	//	hint: string -> {name: "John"}
	alert(+user);	//	hint: number -> 1000
	alert(user + 500);	//	hint: default -> 1500
	
	В данном примере в ручную переписывается/задается код для метода "[Symbol.toPrimitive]".
	
Методы "toString" и "valueOf". Если нет метода "[Symbol.toPrimitive]", движок "JavaScript" пытается найти эти методы и вызвать их следующим образом:

	1. toString -> valueOf для хинта со значением «string».
	
	2. valueOf -> toString – в ином случае.
	
Пример использования методов "toString" и "valueOf":

	let user = {
		name: "John",
		money: 1000,

		//	для хинта равного "string"
		toString() {
			return `{name: "${this.name}"}`;
		},

		//	для хинта равного "number" или "default"
		valueOf() {
			return this.money;
		}
	};

	alert(user);		//	"toString" -> "John".
	alert(+user);		//	"valueOf" -> 1000.
	alert(user + 500);	//	"valueOf" -> 1500.
	
В отсутствие методов "[Symbol.toPrimitive]", "valueOf" и "toString" обработает все случаи преобразований к примитивам.
Важно понимать, что все описанные методы для преобразований объектов не обязаны возвращать именно требуемый "хинтом" тип примитива.
Нет обязательного требования, чтобы "toString()" возвращал именно строку, или чтобы метод "[Symbol.toPrimitive]" возвращал именно число для хинта "number".
Единственное обязательное требование: методы должны возвращать примитив, а не объект.
По историческим причинам, если "toString" или "valueOf" вернёт объект, то ошибки не будет, но такое значение будет проигнорировано (как если бы метода вообще не существовало).
Метод "[Symbol.toPrimitive]", напротив, обязан возвращать примитив, иначе будет ошибка.
Обычно для встроенных объектов хинт "default" обрабатывается так же, как "number".

Итого. Алгоритм преобразований к примитивам следующий:

	1. Сначала вызывается метод "obj[Symbol.toPrimitive](hint)", если он существует.
	
	2. Иначе, если хинт равен "string",	происходит попытка вызвать "obj.toString()", затем "obj.valueOf()", смотря что есть.
	
	3. Иначе, если хинт равен "number" или "default", происходит попытка вызвать "obj.valueOf()", затем "obj.toString()", смотря что есть.

На практике довольно часто достаточно реализовать только "obj.toString()" как "универсальный" метод для всех типов преобразований,
возвращающий "читаемое" представление объекта, достаточное для логирования или отладки.

Для преобразоания объектов в примитивы, методы переписываются/задаются вручную. Если есть универсальный метод "[Symbol.toPrimitive]", то он используется для всех преобразований.
Методы "toString" и "valueOf" устаревшие способы преобразования.

• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями:

	function fn() {}
	fn[Symbol.toPrimitive] = function(){ return 20 }

• У метода "toString" есть скрытая возможность - возвращать тип.

	let objectToString = Object.prototype.toString;

	let arr = [];

	alert( objectToString.call(arr) );	//	[object Array]
	
Согласно спецификации встроенный метод "toString" может быть позаимствован у объекта и вызван в контексте любого другого значения.
И результат зависит от типа этого значения:

	Для числа это будет "[object Number]".
	Для булева типа это будет "[object Boolean]".
	Для "null": "[object Null]".
	Для "undefined": "[object Undefined]".
	Для массивов: "[object Array]"
	…и т.д. (поведение настраивается).
	
• Изменение поведения метода "toString".
Поведение метода объектов "toString" можно настраивать, используя специальное свойство объекта "[Symbol.toStringTag]".
Данное символьное свойство может устанавливать выводимый результат при преобразовании объектов (то есть то что идет после "object" в квадратных скобках):

	let objectToString = Object.prototype.toString;

	let user = {
		[Symbol.toStringTag]: "User"
	};

	alert( objectToString.call(user) );	//	[object User]

• Преобразование объектов в "JSON". У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта
в "JSON" (вызов метода "stringify" у "JSON" для объекта):

	let room = {
		number: 23,
		toJSON() {
			return this.number;
		}
	};
	
	JSON.stringify(room);	//	"23".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Термины "Операнд", "Унарный" и "Бинарный".

"Операнд"	-	то, к чему применяется оператор. Например, в умножении "5 * 2" есть два операнда: левый операнд равен "5", а правый операнд равен "2".
Иногда их называют "аргументами" вместо "операндов".

"Унарным" называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный.
Сам оператор ставится непосредственно перед операндой. Пример:

	let x = 1;

	x = -x;

	console.log ( x ); // -1, применили унарный минус

"Бинарным" называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

	let x = 1, y = 3;
	
	console.log ( y - x ); // 2, бинарный минус

Преобразование к числу, "унарный плюс" ("+"). Плюс "+" существует в двух формах: бинарной, и унарной.
Унарный, то есть применённый к одному значению, плюс "+" ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число. Пример:

	// Преобразует нечисла в числа
	
	console.log ( +"12"); // 12
	
	console.log ( +true ); // 1

	console.log ( +"" );   // 0

Приоритет операторов.

	+	-	"унарный плюс", приоритет - "16".
	-	-	"унарный минус", приоритет - "16".
	*	-	"умножение", приоритет - "14".
	/	-	"деление", приоритет - "14".
	+	-	"сложение", приоритет - "13".
	-	-	"вычитание", приоритет - "13".
	…	…	…
	=	-	"присваивание", приоритет - "3".
	…	…	…
	
	Так как "унарный плюс" имеет приоритет "16", который выше, чем "13" у "сложения" ("бинарный плюс"), то в выражении "+apples + +oranges" сначала выполнятся унарные плюсы,
	а затем сложение.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Математические операторы "JavaScript":

	+	-	сложение.

	-	-	вычитание.

	*	-	умножение.

	/	-	деление.

	%	-	деление по модулю.
	
	**	-	возведение в степень. Например:
	
		console.log ( 2 ** 2 ); // 4  (2 * 2);
		
		console.log ( 2 ** 3 ); // 8  (2 * 2 * 2);
	
		console.log ( 2 ** 4 ); // 16 (2 * 2 * 2 * 2);
		
		console.log ( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
		
		console.log ( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)

	++	-	инкремент.

	--	-	декремент.	
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Инкремент. Постинкремент/Декремент/Постдекркмент.

Постфиксная форма:

		Постинкремент (var++):

			var a = 0; b = 10;
			var a = b++;
			
			Результат:
			
				a = 10; b = 11;
				
		Постдекремент (var--):

			var a = 0; b = 10;
			var a = b--;
			
			Результат:
			
				a = 10; b = 9;
				
		Постфиксная форма сначала возвращает старое значение, затем изменяет текущее.

Префиксная форма:
		
		Преинкремент (++var):

			var a = 0; b = 10;
			var a = ++b;
			
			Результат:
			
				a = 11; b = 11;
			
		Предекремент (--var):

			var a = 0; b = 10;
			var a = --b;
			
			Результат:
			
				a = 9; b = 9;
				
		Префиксная форма возвращает новое измененное значение.

 Инкремент/декремент можно применить только к имени переменной. Попытка использовать его на значении, типа "5++", приведёт к ошибке.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
◘ Операторы присваивания:

	=	-	x = y
	
	+=	-	x = x + y
	
	-=	-	x = x - y
	
	*=	-	x = x * y
	
	/=	-	x = x / y
	
	%=	-	x = x % y
	
Так же можно использовать несколько операторов присваивания в одно строке:

	x -= y += 9;
	
Так же существует оператор "запятая". Редко используется и является одним из самых необычных. Оператор "запятая" предоставляет возможность вычислять несколько выражений,
разделяя их запятой ",". Каждое выражение выполняется, но возвращается результат только последнего. Например:

	let a = (1 + 2, 3 + 4);

	console.log ( a ); // 7 (результат 3 + 4)
	
	Оператор "," имеет очень низкий приоритет, ниже чем у "=", поэтому скобки важны в приведённом выше примере.
	
Оператор "=" возвращает значение. Вызов "x = value" записывает "value" в "x" и возвращает его. Благодаря этому присваивание можно использовать как часть более сложного выражения:

	let a = 1;
	let b = 2;
	let c = 3 - (a = b + 1);
	console.log( a ); // 3
	console.log( c ); // 0

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Операторы/Методы сравнения.

Условие (возвратит "true", если сравниваемые значения соответствуют начальному условию, возвратит "false",
если сравниваемые значения не соответствуют начальному условию):
	
	==	-	равняется (возвратит "true", если сравниваемые значения равны, возвратит "false", если сравниваемые значение не равны).
	
	===	-	идентично (равно и одинакового типа (строго равны)).
	
	!=	-	не равно.
	
	!==	-	не идентично (не равно и не одинакового типа).
	
	>	-	больше чем.
	
	<	-	меньше чем.
	
	>=	-	больше или равно.
	
	<=	-	меньше или равно.
	
Сравнения "null" и "0":

	console.log ( null > 0 );  // false
	
	console.log ( null == 0 ); // false
	
		Для нестрогого равенства "==" значений "undefined" и "null" действует особое правило: эти значения ни к чему не приводятся,
		они равны друг другу и не равны ничему другому.

	console.log ( null >= 0 ); // true
	
Существует специальный метод "is(<аргумент>, <аргумент2>)" у главного объекта "Object", который сравнивает значения примерно как "===", но более надёжен в двух особых ситуациях:

	Работает с "NaN":
	
		console.log( Object.is(NaN, NaN) )	//	true
		
	Значения "0" и "-0" разные:
	
		console.log( Object.is(0, -0) )	//	false
		
		Это редко используется, но технически эти значения разные.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Примеры использования управляющего символа "\":

	\'	-	одинарная кавычка.
	
	\"	-	двойные кавычки.
	
	\\	-	обратный слэш.
	
	\n	-	перевод строки.
	
	\t	-	табуляция.
	
	\r	-	возврат каретки, самостоятельно не используется. В текстовых файлах "Windows" для перевода строки используется комбинация символов "\r\n".

	\b, \f, \v	-	"Backspace", "Form Feed" и "Vertical Tab" — оставлены для обратной совместимости, сейчас не используются.

	\xXX	-	символ с шестнадцатеричным юникодным кодом "XX", например, '\x7A' — то же самое, что 'z'.

	\uXXXX	-	символ в кодировке "UTF-16" с шестнадцатеричным кодом "XXXX", например, "\u00A9" — юникодное представление знака копирайта - "©".
	Код должен состоять ровно из 4 шестнадцатеричных цифр.

	\u{X…XXXXXX}	-	(от 1 до 6 шестнадцатеричных цифр)	Символ в кодировке "UTF-32" с шестнадцатеричным кодом от "U+0000" до "U+10FFFF".
	Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Булевые значения.

Например:
	
	let isActive = true;
	let isHoliday = false;
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Логические операторы.

&&	-	оператор "И" (возвращает "true", если обе операнды истинны). Оператор "И" находит первое ложное значение, и выполняет следующие действия:

		-	Вычисляет операнды слева направо.
		
		-	Каждый операнд преобразует в логическое значение. Если результат = "false", то останавливается и возвращает исходное значение этого операнда.

		-	Если все операнды были истинными, возвращается последний.

	Другими словами, "И" возвращает первое ложное значение, или последнее, если ничего не найдено.

	Вышеуказанные правила схожи с поведением "ИЛИ". Разница в том, что "И" возвращает первое ложное значение, а "ИЛИ" –  первое истинное. Например:
	
		console.log(1 && 0);	//	1
		console.log(1 && 5);	// 5
		console.log(5 && 2 && 3);	// 3
		console.log(null && 1);	//	null
		console.log( 1 && 2 && null && 3 );	//	null
		console.log( 1 && 2 && 3 );	//	3
		
	Примечание: Приоритет оператора "&&" больше, чем у "||".
	
	Сокращённое вычисление. Например:
	
		let x = 1;
		(x > 0) && console.log( 'Greater than zero!' );
		
			Действие в правой части "&&" выполнится только в том случае, если до него дойдут вычисления.
			То есть, "console.log()" сработает, если в левой части "(x > 0)" будет true.

||	-	оператор "ИЛИ" (возвращает "true", если хотя бы одна операнда истинна). Оператор "ИЛИ" находит первое истинное значение, и выполняет следующие действия:

		-	Вычисляет операнды слева направо.
		
		-	Каждый операнд конвертирует в логическое значение. Если результат "true", останавливается и возвращает исходное значение этого операнда.

		-	Если все операнды являются ложными ("false"), возвращает последний из них.

		-	Значение возвращается в исходном виде, без преобразования.

	Другими словами, цепочка "ИЛИ" возвращает первое истинное значение или последнее, если такое значение не найдено. Например:
	
		let currentUser = null;
		let defaultUser = "John";
		let name = currentUser || defaultUser || "unnamed";	// выбирается "John" – первое истинное значение.
		
	Сокращённое вычисление. Например:
	
		let x;
		true || (x = 1);
		console.log(x);	//	"undefined" - пото му что "(x = 1)" не вычисляется, так как вернулось первое с списке значение "истинно".
		
		false || (x = 1);
		console.log(x);	//	"1" - пото му что "(x = 1)" вычисляется, так как первое с списке значение "ложь", и дальше происходит вычисление.

!	-	оператор "НЕ" (возвращает "true", если операнд ложный, возвращает "false", если операнд истынный). Приоритет "НЕ" является наивысшим из всех логических операторов,
поэтому он всегда выполняется первым, перед "&&" или "||".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Интерполяция строк.

Интерполяция строк используется для вставки переменных в строку без использования конкатенации. Для объявления интерполяции строк нужно начать стороку с символов "`",
в которых будет содержаться выражение "${}". Переменная необходимая для вставки в сроку нужно указать в фигурных скобках.

Например:

	let personName = "Alex";
	console.log(`Hello ${personName}`);
	
		Результат:
		
			Hello Alex

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Условные операторы.
	
if (<условие>) {
	<выражение>;
}

	Условный оператор "if" проверяет условие ("<условие>"), и выполянет выражение ("<выражение>"), в случае если уловие
	выполняется. После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if":
	
		let num1 = 5;
		let num2 = 10;
		if (num1 < num2) {
			alert("The num1 is less than num2");
		}
		
	Если в теле блока условного оператора (то есть в "<выражение>") есть только одна строка, то можно обойтись и без фигурных скобок ("{}"). Например:
	
		if (a > b) alert( 'first' );

if (<условие>) {
	<выражение>;
}
else {
	<выражение>;
}

	Оператор "else" выполняет свое выражение, если условие оператора "if" не выполняется. 
	После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if" с оператором "else":
	
		let num1 = 5;
		let num2 = 10;
		if (num1 > num2) {
			alert("The num1 is more than num2");
		}
		else {
			alert("The num1 is less than num2");
		}



if (<условие>) {
	<выражение>;
}
else if (<условие>) {
	<выражение>;
}
else {
	<выражение>;
}

	Оператор "else if" проверяет условие, и выполняет свое выражение, в случае, если его условие выполняется,
	и если условие первого оператора "if" не выполняется. В случае если и условие
	оператора "else if" тоже не	выполняется, то выполняется выражение оператора "else".
	После каждого выражения должны стоять точка с запятой ";".
	
	Пример использования условного оператора "if" с оператором "else":
	
		let num1 = 10;
		let num2 = 10;
		if (num1 > num2) {
			alert("The num1 is more than num2");
		}
		else if (num1 < num2) {
			alert("The num1 is less than num2");
		}
		else {
			alert("The num1 equals num2");
		}
	
	Можно использовать операторы "else if", сколько потребуются.	
	
(<условие>) ? <выражение для "истина"> : <выражение для "ложь">;

	Тернарный оператор. Такой же оператор условия как и "if", но более компактный. Использутся для специфичных ситуаций.
	В скобках с условием пишется условие, после чего после скобок ставится знак вопроса "?", указывающий что это тернарный оператор.
	После этого знака идет первое выражение, которое вернется, усли условие оператора выполнится. После первого выражения стоит
	знак двоеточия ":", после которого будет второе выражение, которое вернется если условие оператора не выполнится.
	Тернарный оператор рекомендуется использовать в коротких выражениях, требующий вернуть какой либо результат, и не рекомендуется
	использовать для многострочных выражений.
	
	Пример использования тернарного оператора:
	
		let accessAllowed = (age > 18) ? true : false;
		
	Примечание: Нельзя использовать директивы (операторы) "break" и "continue" для тернарного оператора.
	
		(i > 5) ? alert(i) : continue; // "continue" здесь приведёт к ошибке.

switch (<имя сравниваемой переменной>) {
	case <значение_1>:
		<выражение>
		break;
	case <значение_2>:
		<выражение>
		break;
	case <значение_3>:
		<выражение>
		break
	case <значение_n>:
		<выражение>
		break;
	default:
		<выражение>
}

	Условный оператор множества условий "switch" строго ("===") сравнивает заданное имя сравниваемой переменной со всеми значениями оператора "case" ("<значение_1>",
	"<значение_2>", "<значение_3>", "<значение_n>"), и выполняет выражение соответствующего значения "case", в случае равенства.
	Оператор "break" - выполняет выход из условного оператора "switch", после выполнения выражения. Если "<условие>" не равняется ни одному из
	значений оператора "case", то выполянется выражение "<выражение_default>" оператора "default". Оператор "default" не обязателен.
	После каждого выражения должен стоять символ точки с запятой ";".
	
	Пример использования оператора множества условий "switch":
	
		let day = 2;
		switch (day) {
			case 1:
				document.whrite("Понедельник");
				break;
			case 2:
				document.whrite("Вторник");
				break;
			case 3:
				document.whrite("Среда");
				break;
			case 4:
				document.whrite("Четверг");
				break;
			case 5:
				document.whrite("Пятница");
				break;
			case 6:
				document.whrite(Суббота");
				break;
			case 7:
				document.whrite("Воскресенье");
				break;
			default:
				console.log("Не является днем недели");	//	"Вторник"
		}
		
	Несколько вариантов "case", использующих один код, можно группировать:
	
		let a = 2 + 2;
		switch (a) {
			case 4:
				alert('Правильно!');
				break;

			case 3: // (*) группируем оба case
			case 5:
				alert('Неправильно!');
				alert("Может вам посетить урок математики?");
				break;

			default:
				alert('Результат выглядит странновато. Честно.');
		}
		
		В данном примере оба варианта "3" и "5" выводят одно сообщение.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Циклы.						

for (<начальное значение переменной>; <условие цикла>; <выражение для конца итерации>) {
	<выражение>;
}

	Оператор цикла. Где "<начальное значение переменной>" - выражение, которое выполнится до запуска блока цикла;
	"<условие цикла>" - условие, которое должно выполняться,
	чтобы цикл продолжался; "<выражение для конца итерации>" - выражение, которое будет выполняться после каждого цикла;
	"<выражение>" - выражение, которое будет выполняться в каждом цикле.
	
	Пример использования цикла "for":
	
		for (i=1; i<=5; i++) {
			document.write(i + "<br />");
		}
	
	"<начальное значение переменной>" - является опциональным, при необходимости можно не указывать, оставив на его месте только символ точки с запятой ";",
	если необходимые значения указаны до цикла:
	
		let <переменная> = <значение>;
		for (; <условие цикла>; <выражение для конца итерации>) {
			<выражение>;
		}
		
		Например:
			
			var i = 1;
			for (; i<=5; i++) {
				document.write(i + "<br />");
			}
		
	На месте "<начальное значение переменной>" могут быть несколько значений, перечисляя после запятой:
	
		for (<выражение_1, выражение2, выражение_3, выражение_n>; <условие цикла>; <выражение для конца итерации>) {
			<выражение>;
		}
		
	"<условие цикла>" - также является опциональным, при необходимости можно не указывать, оставив на его месте только символ точки с запятой ";".
	Если его не использовать, то необходимо указать оператор "break", чтобы создать выход из цикла.
	
	"<выражение для конца итерации>" - также является опциональным, при необходимости можно не указывать.
	На его месте не будет ставиться символ точки с запятой ";", как	в случаях выше, так как это выражение является последним в скобках:
	
		for (; <условие цикла>; ) {
			<выражение>;
		}
		
	Существуют циклы для перебора объектов - "for <ключ> in <объект>", в которых при каждой итерации будет поочередно браться ключ данного объекта:
	
		let obj = {
			"a": 1,
			"b": 2,
			"e": 76
		}
		
		for (let key in obj) {
			console.log(obj[key]);	//	Выведет "1", "2", "76".
		}
		
	Существуют циклы для перебора массивов - "for <элемент> of <массив/итерируемый объект>", в которых при каждой итерации будет поочередно браться индекс данного массива:
	
		let arr = [1, 2, 76]
		
		for (let i of arr) {
			console.log(i);	//	Выведет "1", "2", "76".
		}
	
	Для превращения цикла для перебора итерируемых объектов в асинхронный цикл для перебора итерируемых объектов, нужно добавить оператор "await" после "for":
	
		for await (let <элемент> of <массив/итерируемый объект>){<выражение>}
	
	Подробнее в главе 'Тип данных - "Symbol"' в подглаве '"Symbol.asyncIterator"'.

• Если цикл содержит только одну строку, то можно обойтись без фигурных скобок:

	for (let i of arr) alert(i);

while (<условие>) {
	<выражение>;
}

	Цикл "while", повторяет блок кода (напр. "<выражение>"), пока действует условие "<условие>".
	
	Пример использования цикла "while":
	
		var i = 0;
		while (i<=10) {
			document.write(i + "<br />");
		}
		
	Фигурные скобки ("{}") не требуются для тела цикла из одной строки:
	
		let i = 3;
		while (i) alert(i--);

do {
	<выражение>;
}
while ("<условие>");

	Цикл "do while" является вариацией цикла "while". Данный цикл выполнит "<выражение>" один раз, до проверки правильности условия "<условие>", а затем цикл будет
	повторяться, пока будет выполняться условие "<условие>".
	Точка с запятой после "while" является обязательным.

break;

	Выражение, которое завершает цикл.
	
	Например:
	
		for (i=0; i<=10; i++) {
			if (i == 5) {
				break;
			}
			document.write(i + "<br />");
		}
		
		В данном примере если число "i" равняется 5, то цикл прекращается.
		
		Примечание:
		
			Выражение "return" так же нарушит цикл, вернув некоторое значение из цикла.

continue;

	Выражение, которое останавливает одну итерацию, и продолжает со следующей (перескакивает на следующий цикл).
	
	Например:
	
		for (i=0; i<=10; i++)	{
			if (i == 5) {
				continue;
			}
			document.write(i + "<br />");
		}
		
		В данном примере если число "i" равняется 5, то цикл пропускает текущую итерацию, и переходит к следующей, пропуская печать числа 5.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Метки инструкций (label). Инструкция метки (label) используется вместе с директивами (операторами) "break" или "continue" для альтернативного выхода из цикла.
Оно добавляется перед блочным выражением в качестве ссылки, которая может быть использована в дальнейшем. Например:

	let i, j;

	loop1:	for (i = 0; i < 3; i++) {	//Первый цикл, обозначенный меткой "loop1".
	   loop2:
	   for (j = 0; j < 3; j++) {	//	Второй цикл, обозначенный меткой "loop2".
		  if (i == 1 && j == 1) {
			 continue loop1;
		  }
		  console.log("i = " + i + ", j = " + j);
	   }
	}
	
	Вызов "break" или "continue" возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функции.

Функцией языка "JavaScript" является блок кода, созданный для выполнения специального задания. Есть два способа объявления/создания функции.
Первый это объявление фунции через объявление имени функции "Function Declaration":

	function <имя функции> (<принимаемые параметры/аргументы>) {
		<тело функции>;
	}
	
	"Function Declaration" можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке). Другими словами, когда движок "JavaScript"
	готовится выполнять скрипт или блок кода, прежде всего он ищет в нём "Function Declaration" и создаёт все такие функции. Можно считать этот процесс "стадией инициализации".
	И только после того, как все объявления "Function Declaration" будут обработаны, продолжится выполнение. В результате, функции, созданные, как "Function Declaration"
	могут быть вызваны раньше своих определений.
	
	В строгом режиме, когда "Function Declaration" находится в блоке "{...}", функция доступна везде внутри блока, но не снаружи него.
	
Второй это объявление фунции через функциональное выражение "Function Expression":

	let <имя переменной для функции> = function (<принимаемые параметры/аргументы>) {
		<тело функции>;
	};
	
	Важно! В конце такого способа (после "}") ставится ";", так как это все равно операция присваивания.
	
	"Function Expression" создаётся, когда выполнение доходит до него, и затем уже может использоваться.
	После того, как поток выполнения достигнет правой части выражения присваивания "let <имя переменной для функции> = function…" – с этого момента,
	функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).
	
	Так же функцию можно скопировать в другую переменную:
	
		let fn2 = fn;
		
			Здесь "fn" является функцией, и пишется без скобок, чтобы присвоить ее саму переменной "fn2", иначе бы (если со скобками) этой переменной присвоилось бы то,
			что возвращает функция "fn".
			
	• "Named Function Expression". Это термин для "Function Expression", у которого есть имя:
	
		let sayHi = function func (who) {
			alert(`Hello, ${who}`);
		};
		
	Это имя не доступно за пределами функции.	
	Данный способ используется для чтобы позволить функции ссылаться на саму себя, даже если переменная функции больше не будет доступна:

		let sayHi = function func(who) {
			if (who) {
				alert(`Hello, ${who}`);
			} else {
				func("Guest");
			}
		};

		let welcome = sayHi;
		sayHi = null;

		welcome(); // "Hello, Guest" (вложенный вызов работает).

Объявление (определение) и вызов (выполнение) функции (на примере первого способа объявления/создания функции "Function Declaration"):

	function <имя функции> (<принимаемые параметры/аргументы>) {
		<тело функции>;
	}
	
	Где "<имя функции>" - это имя создаваемой функции, которое может состоять только из допустимых символов в "JavaScript" (так же как и для переменных);
	"<принимаемые параметры/аргументы>" - это входные параметры	(аргументы) функции, которые будут использоваться в самой функции.
	В "<принимаемые параметры/аргументы>" могут быть несколько значений, перечисляясь через запятую.
	"<тело функции>" - код функции, который будет выполняться самой функцией.
	
	Примечание:
	
		Если в "<принимаемые параметры/аргументы>" будут переданы больше аргументов, чем описано в коде фунции, то они будут прикреплены к массиву с аргументами, и их можно будет использовать
		следующим образом:
		
			arguments[0], arguments[1], arguments[2], arguments[n]
			
		Если в "<принимаемые параметры/аргументы>" будут переданы меньше аргументов, чем описано в коде фунции, то пропущенные значения будут установлены как неопределенные, что означает что
		переменным не будет присвоено значение.
		
	Параметры по умолчанию. Если параметр по умолчанию не был передан, или был передан "undefined", то его значением становится "undefined". Можно задавать принимаемые параметры по умолчанию через "=". Например:
	
		function fn (name, years = 18) {
			console.log(name + " is " + years + " years old");
		}	

	Чтобы вызвать (выполнить) функцию, нужно прописать имя функции, а затем добавить в скобках входные параметры (аргуенты) функции. После вызова функции, должна стоять
	точка с запятой.
	
	Форма вызова (выполнения) функции:
	
		<имя функции>(<принимаемые параметры/аргументы>);
		
	Примеры использования фукций:
	
		Пример первый (создание и вызов функции без аргумента):
	
			function myFunction() {
				alert("Alert Box");
			}
			myFunction();
			
			Результатом данной функции будет вывод текста "Alert Box".
			
		Пример второй (создание и вызов функции с аргументом):
			
			function sayHello(name) {
				alert("Hi, " + name);
			}
			sayHello("David");
			
			Результатом данной функции будет вывод текста "Hi, David".
			
		Пример третий (создание и вызов функции с несколькими аргументоми):
		
			function personInfo(name, age) {
				document.write(name + "is" + age + "years old.");
			}
			personInfo("David", 18);
			
			Результатом данной функции будет вывод текста "David is 18 years old.".
			
Возвращение значения функции.

	Функция может иметь опциональную инструкцию (выражение) "return", она используется для возвращения значения функции. Эта функция полезна при выполнении вычислений, для
	немедленного получения результата. Когда "JavaScript" достигает инструкции "return", функция останавливает выполнение. После инструкции "return" ставится точка с запятой.
	
	Примеры использования инструкции "return":
	
		Пример первый:
	
			function myFunction(a, b) {
				return a*b;
			}
			let x = myFunction(5,6);
			
			Результатом данной функции будет возвращение значения произведения "a*b" функции "myFunction",
			затем присвоение ее значения переменной "х" (то есть "x" будет равен 30).
			
		Пример второй:
		
			function addNumbers(a, b) {
				let c = a + b;
				return c;
			}
			document.write(addNumbers(40, 2));
			
			Результатом данной функции будет возвращение значения переменной "c" функции "addNumbers", затем печать результата функции "addNumbers" (то есть печать числа 42).

	Вызовов "return" может быть несколько, а так же возможно использовать "return" и без значения, что приведёт к немедленному выходу из функции.
	Если функция не возвращает значения, это всё равно, как если бы она возвращала "undefined". Пустой "return" аналогичен "return undefined".

Обращение к имени функции без скобок вернет его исходный код. Например:

	function fn (x) {
		alert(x);
	}
	
	console.log(fn);	//	Выведет код функции.
	
• Функции шаблонизации. Можно использовать свою функцию шаблонизации для строк. Название этой функции ставится перед первой обратной кавычкой:

	let str = func`моя строка`;
	
Эта функция будет автоматически вызвана и получит в качестве аргументов строку, разбитую по вхождениям параметров "${…}" и сами эти параметры. Например:

	function f(strings, ...values) {
	  console.log(JSON.stringify(strings));	//	["Sum of "," + "," =\n ","!"]
	  console.log(JSON.stringify(strings.raw));	//	["Sum of "," + "," =\\n ","!"]
	  console.log(JSON.stringify(values));	//	[3,5,8]
	}

	let apples = 3;
	let oranges = 5;

	let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
	
	В примере выше видно, что строка разбивается по очереди на части: "кусок строки" – "параметр" – "кусок строки" – "параметр".
	Участки строки идут в первый аргумент-массив "strings".
	У этого массива есть дополнительное свойство "strings.raw". В нём находятся строки в точности как в оригинале.
	Это влияет на спец-символы, например в "strings" символ "\n" – это перевод строки, а в "strings.raw" – это именно два символа "\" и "n".
	Дальнейший список аргументов функции шаблонизации – это значения выражений в "${...}", в данном случае их три.
	
• У функций есть свойство "arguments", которое содержит все принимаемые аргументы:

	function showName() {
		console.log( arguments.length );
		console.log( arguments[0] );
		console.log( arguments[1] );

	  // Объект arguments можно перебирать
	  // for (let arg of arguments) console.log(arg);
	}
	
Свойство "arguments" у функций является перебираемым объектом и псевдомассивом, но у него нет методов обычного массива.

	showName("Hello", "World");	//	2, Hello, World

Тип свойства "arguments" является "[object Arguments]":

	function fn () { return arguments }

	let a = fn(1,2,3,4);

	Object.prototype.toString.call(a);	//	"[object Arguments]".
	
• Функция получает текущее значение внешних переменных, то есть, их последнее значение.	

• У функций (а так же методов объектов) есть встроенные свойства:

	name	-	возвращает имя фукнции. У "Named Function Expression" это имя будет именем перед скобками.
	
	length	-	возвращает количество параметров функции в её объявлении (кроме "...rest").
	
• Синтаксис "new Function" - ещё один вариант объявлять функции. Он используется крайне редко. Данный способ схож с методом "eval()", но имеет отличия.
Форма синтаксиса "new Function":

	let func = new Function(<аргумент1>, <аргумент2>, <аргументN>, <тело функции>);
	
	Аргументы также могут быть объявлены через запятую в одной строке.
	
Когда функция создаётся с использованием "new Function", в её "[[Environment]]" записывается ссылка не на внешнее лексическое окружение, в котором она была создана,
а на глобальное.
Пример использования "new Function":

	let sum = new Function('a', 'b', 'return a + b');

	console.log( sum(1, 2) );	//	3
	
• Методы преобразования объектов "[Symbol.toPrimitive]", "toString" и "valueOf" так же работают и с фунцкиями. Подробнее в главе "Преобразование типов".
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Стрелочные функции.

"функции-стрелки" или "стрелочные функции" (arrow functions), т.к. выглядит следующим образом:

	let <имя переменной для функции> = (<принимаемые параметры/аргументы>)=>{<тело функции>}
	
	Чтобы объявить стрелочную функцию, нужно указать круглые скобки "()" для входных параметров, а затем после них указать сочетание "=>", что является указанием что
	это стрелочная функция.
	
	Пример:
	
		let sum = (a, b) => {
			return a+b;
		}
		
	Если входной параметр только один, то можно обойтись без круглых скобок "()":
	
		let double = a => {
			return a*2;
		}
		
	Если нет аргументов, указываются пустые круглые скобки:
	
		let great = () => {
			console.log("Hello");
		}
		
	Если тело функции состоит только из одной строки, то можно обойтись и без фигурных скобок "{}" и директивы "return":
	
		let double = a => a*2;
		
• У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного,
до нормальной функции (не стрелочной) (до внешней нормальной фунции).
Например:

	let user = {
		firstName: "Илья",
		sayHi() {
			let arrow = () => console.log(this.firstName);
			arrow();
		}
	};
	
	user.sayHi();	//	Илья
	
• Стрелочные функции не имеют свойства "arguments". Если стрелочная функция находится внутри обычной функции, то если обратиться к "arguments" из стрелочной функции,
то получим аргументы внешней обыной функции.

• Стрелочные функции нельзя использовать как конструкторы (с ключевым словом "new"), так как у них нет собственного "this".

• У стрелочных функций нет "super". Подробнее в главе "Классы".

• Со стрелочными функциями нельзя использовать методы "bind", "call", "apply".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Самовызываемые функции (или немедленно вызываемые функции - "Immediately-Invoked Function Expression" - "IIFE").

Самовызываемые функции это функции, которые вызываются сразу же после объявления. Такие функции вызываются с помощью операторов группировки (скобки "()").

Формы синтаксиса самовызываемой функции:

	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>})();	//	Скобки вокруг функции.
	
	(function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}());	//	Скобки вокруг всего.
	
	!function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();	//	Выражение начинается с побитового оператора "NOT".
	
	+function <имя фунции (опционально)> (<принимаемые параметры/аргументы>) {<тело функции>}();	//	Выражение начинается с унарного плюса.
	
Пример самовызываемой функции:

	(function fn() { console.log("Test"); } )();	//	Test
	
	В данном примере в первых скобках находится объявление функции. Первые скобки "группируют" то, что нахоится в ней. Вторые скобки уже действуют как скобки у обычного
	вызова функции, в них даже можно передать параметры:
	
		(function fn(input) { console.log(input); } )("Test");	//	Test
		
Так же можно создать самовызываемаю функцию с помощью анонимной функции:

	(function (input) { console.log(input); } )("Test");
		
Так же можно создать самовызываемую функцию с помощью стрелочных функций:

		(input => console.log(input) )("Test");	//	Test
		
Примечание! Рекомендуется ставить точку с запятой после какого-либо выражения (на усмотрение), если после нее идет самовызываемая функция. Пример:

	let user = {
	  name: "Джон",
	  go: function() { alert(this.name) }
	}

	(user.go)()	//	Ошибка !
	
	Данный пример вызовет ошибку, так как пропущена точка с запятой поле объявления (литерала) объекта, потому что "JavaScript" попытается вызвать объект "user" ("{...}")
	как функцию с парамтрами первых скобок "(user.go)".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дебаггер. Команда "debugger" предназначена для того чтобы установить точку останова в коде, тем самым останавливая выполнение кода.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функции высшего порядка и колбэки.

Колбэки ("ClassBack") это функции, передаваемые в другую функцию (в функцию высшего порядка), в качестве аргументов, которые будут выполнены позже.
Функции высшего порядка ("Higher-order function") это функции, которые принимают колбэки, в качестве аргументов. Пример:

	function callBackYes(){
		console.log("Yes!");
	}
	
	function callBackNo(){
		console.log("No!");
	}
	
	function higherOrderFunction(input, yes, no) {
		if (input == "yes") yes();
		else if (input == "no") no();
	}
	
	higherOrderFunction("yes", callBackYes, callBackNo);
	

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Анонимные функции.

Один из способов создать анонимную функцию, это задать ее как колбэк. Например:

	function ask (question, ifYes, IfNo){
		if (confirm(question)) {
			ifYes();
		}
		else {
			IfNo();
		}
	}
	
	ask("Вы согласны?", function() { alert("Вы согласились."); },  function() { alert("Вы отменили выполнение.");
	
		В данном примере два передаваемыех колбэка в функцию "ask" являются анонимными, на в самой функции "ask" им определены имена "ifYes" и "ifNo",
		по которым они могут дальше вызываться.
		
Еще способ создать анонимную функцию, это через самовызываемую функцию:

	(function (input) { console.log(input); } )("Test");

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Области видимости переменных.

1. Глобальная область видимости переменных - область, где все переменные доступны в любом участке кода.

2. Локальная облать видимости - область, где все переменные доступны только в блоке кода, где они были созданы (например в теле функции).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объекты (ассоциативные массивы).

Объекты это "контейнеры", для хранения полей/свойств (сущностей/элементов). Один из способов создания объектов, это с помощью литерала объекта - фигурных скобок "{}".
Свойства в объете должны перечисляться с помощью запятой, а значения этим элементам присваиваются с помощью двоеточия (":"), а не равно ("=").
После фигурных скобок рекомендуется ставить точку с запятой ";".
Пример:

	let obj = {
		name: "Alex",
		age: 18
	};
	
Другой способ создания объекта это с помощью встроенного главного объекта "Object" с ключевым словом "new":

	let obj = new Object();	//	Будет создан пустой объект, как если бы он был создан таким образом: "let obj = {};".

Данный способ работает и без ключевого слова "new":

	let obj = Object();	//	Будет создан пустой объект, как если бы он был создан таким образом: "let obj = {};".

Доступ к свойствам объекта можно получить с помощью точки ".":

	let obj = {
		name: "Alex",
		age: 18
	};
	
	console.log(obj.name);	//	 Alex
	
Можно также изменять значения свойств с помощью точки ".":

	obj.name = "Bob";
	
Чтобы удалить свойство объекта, используют оператор "delete":

	delete obj.name;
	
Если имя свойства объекта состоит из нескольких слов, то его заключают в кавычки '""':

	let obj = {
		"max num": 200;
	};
	
Чтобы обратиться к таким свойствам, нужно указать из в квадратных скобках "[]":

	console.log(obj["max num"]);
	
Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

	let max = "max num";
	
	obj[max] = 200;
	
К именам свойств объекта применяются те же правила, что и к именам переменных. Если имя свойства состоит из числа, то доступ у нему нельзя будет осуществить
через точку ".", а только через квадратные скобки "[]".
	
В свойствах объекта можно указывать вычисляемые свойства с помощью квадрадных скобок "[]":

	function fn() { return "apple"; }

	let fruit = fn();
		
	let obj = {
		name: "Alex",
		age: 18,
		[fruit]: 5	//	имя свойства будет взято из переменной "fruit", и оно будет "apple".
	};
		
Так же можно присвоить значение свойству через обращение к нему:

	function fn() { return "apple"; }

	let fruit = fn();
	
	obj[fruit] = 5;
	
Так же можно использовать и более сложные выражения в квадратных скобках:

	let fruit = "apple";
	
	let obj = {
		name: "Alex",
		age: 18,
		[fruit + "Juice"]: 5	//	obj.appleJuice = 5.
	};
	
Если название свойства объекта совпадает с именем переменной, то можно не указывать значение вычисляемого свойства объекта:

	let name = "Alex";
	
	let obj = {
		name,
		age: 18
	};
	
В объектах есть свойство "__proto__", и оно всегда указывает на объект. Если нужно его переопределить, то переопределяемое значение должно быть
всегда объектом или "null". Подробнее в главе "Прототипы, наследование".

Чтобы выяснить, содержит ли определенный объект определенное свойство, существует оператор "in", который возвращает булево значение:

	let user = {
		name: "Alex"
	};
	
	console.log("name" in user);	//	true
	console.log("age" in user);	//	false
	
Для перебора всех свойств в объекте существует цикл "for in", который будет получать каждое свойство для каждной итерации цикла:

	let user = {
		name: "Alex",
		age: 18
	};

	for (let key in user) {
		console.log(user[key]);	// тело цикла выполнится для каждого свойства объетка "user".
	}
	
Важно! Порядок вывода свойств зависит от того, из каких символов состоят свойства. Если они содержат целочисленные значения (даже если в кавычках), то они будут
выводится в порядка возрастания. Чтобы этого избежать, нужно добавить символ плюса "+" перед числом ("44" => "+44"). В таком случае они будут выводиться
в порядке их объевления.

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются "по ссылке".
Примитивные типы: строки, числа, логические значения – присваиваются и копируются "по значению".
Переменная объекта хранит не сам объект, а его "адрес в памяти", другими словами "ссылку" на него:

	let user1 = {
		name: "Alex";
	};
	let user2 = user1;	//	Здесь "user2" является ссылкой на объект "user1", а не его копией.
	
	user2.name = "Bob";
	
	console.log(user1.name);	//	Bob
	
Чтобы клонировать объект, можно перебрать объект с помощью цикла "for in", и присваивать каждый ключ новому объекту.
Есть еще способ клонировать объект, это с помощью метода "assign" встроенного объекта "Object" ( "Object.assign(<целевой объект>, <объекты источники>);" ):

	let obj1 = {
		name: "Alex",
		age: 18
	};
	
	let obj2 = {};
	
	Object.assign(obj2, obj1);
	
Также можно использовать "Object.assign" для простого клонирования:

	let user = {
		name: "John",
		age: 30
	};

	let clone = Object.assign({}, user);
	
В обоих случаях, если объекты содержит вложенные объекты (объекты внутри объектов), то они не будут клонированы, вместо этого будут созданы ссылки на них.

Чтобы исправить это, мы должны в цикле клонирования делать проверку, не является ли значение "user[key]" объектом, и если это так – копируем и его структуру тоже.
Это называется "глубокое клонирование".

• Методы объекта. Методы это функции объектов. Примеры создания методов:

	1. Создание метода через "Function Expression":
	
		let user = {
			name: "Alex"
		};
		
		user.sayHi = function() {
			alert("Hi");
		}
		
	2. Создание метода через "Function Declaration":
	
		let user = {
			name: "Alex"
		};
		
		function sayHi () {
			alert("Hi");
		}
		
		user.sayHi = sayHi;
		
	3. Создание метода в литерале объекта:
	
		let user = {
			name: "Alex",
			sayHi: function () {
				alert("Hi");
			}
		};
		
	4. Упрощенное создание метода в литерале объекта:
	
		let user = {
			name: "Alex",
			sayHi() {
				alert("Hi");
			}
		};
		
• Важно ! Варианты создания методов "3" и "4"  не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов. Подробнее в главе "Классы" в подглаве про ("[[HomeObject]]").
	
Чтобы вызвать метод объекта, нужно указать имя объекта, а затем через точку (".") указать метод вместе со скобками (так как метод это функция):

	user.sayHi();	//	Hi
	
• Перебор объекта с помощью циклов. Перебрать объект можно с помощью цикла "for <ключ> in <объект>". Подробнее в главе "Циклы".

• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON" (вызов метода "stringify" у "JSON" для объекта),
подробнее в главе "Преобразование типов".

• Конструктор главного объекта "Object".

Конструктор главного объекта "Object" ("new Object(<цель/цели>)") создаёт объект-обёртку для переданного значения. Если значением является "null" или "undefined",
создаёт и возвращает пустой объект, в противном случае возвращает объект такого типа, который соответствует переданному значению.
У объектов оберток собственно есть соответствующие методы преобразования (например "toString", "valueOf", и т.д). Пример:

	let stringObjectWrapper = new Object("hello");	//	будет создан объект-обертка для строки "hello".
	
	console.log( stringObjectWrapper.toString() );	//	hello
	
	console.log( stringObjectWrapper + " John");		//	hello John
	
	let numberObjectWrapper = new Object(145);		//	будет создан объект-обертка для числа "145".
	
	console.log( numberObjectWrapper.valueOf() );	//	145
	
	console.log( numberObjectWrapper + 5 );		//	150

Если значение уже является объектом, то конструктор вернёт это значение (присвоется по ссылке):

	let obj1 = {a: 14};
	
	let obj2 = new Object(obj1);
	
	obj1 == obj2;	//		true

При вызове в не-конструкторном контексте (без "new"), "Object" ведёт себя идентично коду "new Object()".

• Дескрипторы.
• Главный объект "Object" имеет следующие методы:

	create(<цель-прото>, <объект с объектами с флагами (дескрипторами свойств) (опционально)>) – создаёт новый объект, "[[Prototype]]" которого будет "<цель-прото>".
	Вторым опциональным параметром данного метода является объект с объектами с флагами (дескрипторами свойств).
	Можно установить флаги сразу у нескольких свойств объекта. Подробнее о работе дескрипторов в методе "defineProperty()". Пример:
	
		let person = Object.create({}, {
			name: { value: "John", writable: false },
			surname: { value: "Smith", writable: false },
		});

	assign(<целевой объект>, <объекты источники>)	-	создание/(добавление в) объекта/объект "<целевой объект>" из указанных источников "<объекты источники>".
	
	is(<аргумент>, <аргумент2>)	-	сравнивание указанных значений примерно как "===".

	keys(<целевой объект>)	-	возвращает массив ключей объекта. Игнорируются символьные свойства.
	
	values(<целевой объект>)	-	возвращает массив значений объекта. Игнорируются символьные свойства.
	
	entries(<целевой объект>)	-	возвращает массив пар ключ-значение. Игнорируются символьные свойства.
	
	fromEntries(<массив>)	-	создает объект из массива пар ключ-значение.
	
	defineProperty(<целевой объект>, <имя свойства>, <объект с флагами (дескриптор свойства)>)	-	установить флаги у свойства объекта.
	"<объект с флагами (дескриптор свойства)>" содержит следующие флаги:
	
		value	-	будет содержать само значение целевого свойства.
		
		writable	-	если "true", свойство можно изменить, иначе оно только для чтения.

		enumerable	-	если "true", свойство перечисляется в циклах, в противном случае циклы его игнорируют, а так же такие свойства также не возвращаются из "Object.keys".

		configurable	-	если "true", свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя. Определение свойства как неконфигурируемого
		необратимо (нельзя изменить обратно).
		
		Если свойство существует, "defineProperty" обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами.
		Если какой-либо флаг не указан явно, ему присваивается значение "false". В строгом режиме попытка выполнить операции с объектом/свойством, запрещенные дескриптором свойства,
		приведет к ошибке.
		
		Пример:
		
			let user = {};

			Object.defineProperty(user, "name", {
				value: "John",
				writable: true,
				enumerable: true,
				configurable: true
			});
			
		Можно установить геттеры и сеттеры через метод "defineProperty". Подробнее в подглаве "Свойства - геттеры и сеттеры (свойства-аксессоры)".

	getOwnPropertyDescriptor(<целевой объект>, <имя свойства>)	-	получить объект с флагами свойства (дескриптор свойства) у объекта. Пример:
	
		let user = {
			name: "John"
		};
		
		let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

	defineProperties(<целевой объект>, <объект с объектами с флагами (дескрипторами свойств)>)	-	то же самое что и метод "defineProperty", за исключением того, что можно
	установить флаги сразу у нескольких свойств объекта.  Пример:
	
		let user = {};

		Object.defineProperties(user, {
			name: { value: "John", writable: false },
			surname: { value: "Smith", writable: false },
		});
		
	getOwnPropertyDescriptors(<целевой объект>)	-	получить все флаги всех свойств (все дескрипторы всех свойств) у объекта.
	
	preventExtensions(<целевой объект>)	-	запрещает добавлять новые свойства в объект.

	seal(<целевой объект>)	-	запрещает добавлять/удалять свойства. Устанавливает "configurable: false" для всех существующих свойств.

	freeze(<целевой объект>)	-	запрещает добавлять/удалять/изменять свойства. Устанавливает "configurable: false", "writable: false" для всех существующих свойств.

	isExtensible(<целевой объект>)	-	возвращает "false", если добавление свойств запрещено, иначе "true".
	
	isSealed(<целевой объект>)	-	возвращает "true", если добавление/удаление свойств запрещено и для всех существующих свойств установлено "configurable: false".

	isFrozen(<целевой объект>)	-	возвращает "true", если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено "configurable: false",
	"writable: false".

	getOwnPropertyNames(<целевой объект>)	-	возвращает массив со всеми свойствами (независимо от того, перечисляемые они или нет),
	найденными непосредственно в переданном объекте.
	
	isPrototypeOf(<объект>)	-	возвращает "true", если объект, у которого вызван метод есть где-то в прототипной цепочке объекта "<объект>".
	
	Остальные свойства/методы имеются в главах, содержащих в себе работу с главным объектом "Object".
	
• Свойства - геттеры и сеттеры (свойства-аксессоры). Геттеры это методы для чтения, а сеттеры для записи.

Геттеры. Геттер срабатывает при простом обращении к свойству объекта (без скобок). Геттер представляет собой функцию, возвращающую что либо (свойства/значения),
но не требующую указания круглых скобок при обращении. Чтобы создать геттер (при литеральном объявлении  объекта), нужно указать в объекте перед методом ключевое слово "get".
Пример:

	let user = {
		name: "John",
		surname: "Smith",

		get fullName() {
			return `${this.name} ${this.surname}`;	//	геттер, срабатывает при чтении "user.fullName".
		}
	};
	
	console.log(user.fullName);	//	John Smith
	
Сеттеры. Сеттер срабатывает при присваивании свойству объекта значения. Сеттер представляет собой функцию, которая принимает значения, и который может
присваивать значения целевому объекту/свойству и/или изменять его. Чтобы создать сеттер (при литеральном объявлении  объекта),
нужно указать в объекте перед методом ключевое слово "set". Новые значения, которые будут присваиваться сеттеру, будут в качестве аргументов для функции сеттера. Пример:

	let user = {
		name: "John",
		surname: "Smith",

		get fullName() {
			return `${this.name} ${this.surname}`;
		},

		set fullName(valueOne, valueTwo) {
			this.name = valueOne;
			this.surname = valueTwo;
		}
	};
	
	console.log(user.fullName);	//	"John Smith" - сработал геттер, так как простое обращение к свойству.
	
	user.fullName = "Alice Cooper";	//	сработал сеттер, так как обращение с присваиванием.
	
Дескрипторы геттеров и сеттеров. Эти дескрипторы отличаются от обычных дескрипторов свойств, они не имеют флагов "value" и "writable", но взамен предлагают функции "get" и "set".
То есть имеет флаги "get", "set", "enumerable", "configurable". Пример создания аксессора "fullName":

	let user = {
		name: "John",
		surname: "Smith"
	};

	Object.defineProperty(user, 'fullName', {
		get() {
			return `${this.name} ${this.surname}`;
		},

		set(value) {
			[this.name, this.surname] = value.split(" ");
		}
	});

	console.log(user.fullName);	//	John Smith

	for(let key in user) console.log(key);	//	"name, surname" - при переборе данного объекта в цикле, берутся значения из геттера.

Еще пример:

	let user = {};

	Object.defineProperties(user, {
		name: {
			value: "Alex",
			writable: true,
		},
		birthYear: {
			value: 1993,
			writable: true,
		},
		age: {
			get() {
				return new Date().getFullYear() - this.birthYear;
			},
			set(value) {
				this.birthYear = value;
			}
		}	
	});
	console.log(person.age);	//	27

	person.age = 1997;
	console.log(person.age);	// 23


• У объектов есть свойство "constructor", которое указывает обратно на функцию-конструктор, который его создал.

• У объектов есть ключевое слово "super". Подробнее в главе "Классы".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
◘ Массивы.

Массивы это "контейнеры", для хранения коллекции данных по индексами (которые начинаются с нуля). Элементы в массиве должны перечисляться с помощью запятой.
В массиве могут храниться элементы любого типа (числа, строки, другие массивы, объеты и т.д.). Массив является типом данных - "объект". Массивы копируются по ссылке как и объекты.
Массивы являются "перебираемыми" объектами.

Способы создания массивов:

	Через литерал массива:
	
		let arr = ["Яблоко", 'Груша', `Слива`];
		
	Через объект "Array":
	
		let arr = new Array("Яблоко", 'Груша', `Слива`);
		
		Если в качестве аргумента объекту "Array" передать один целочисленный аргумент, то он сработает как указатель на количество элементов ново создаваемого/возвращаемого
		массива:
		
			let arr = new Array(5);
			
			console.log( arr.length )	//	5
		
		Так же можно создать массив с помощью конструктора "Array" но без ключевого слова "new":
		
			let arr = Array(1,2);
		
Чаще всего используется метод литера массива.
	
Чтобы получить доступ к элементу массива нужно использовать квадратные скобки с индексом элемента (индекс элементов начинается с нуля):

	console.log(arr[0]);	//	"Яблоко"
	
Для получения доступа к длине массива есть свойство "length":

	let arr = ["Яблоко", 'Груша', `Слива`];
	
	console.log( arr.length );	//	3
	
	Свойство "length" автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.
	Например, единственный элемент, имеющий большой индекс, даёт большую длину:
	
		let fruits = [];
		fruits[123] = "Яблоко";

		console.log( fruits.length ); // 124

• Перебор массива с помощью циклов. Перебрать объект можно с помощью обычного цикла "for", а так же "for <элемент> of <массив/итерируемый объект>". Подробнее в главе "Циклы".
Технически, так как массив является объектом, можно использовать и вариант "for <ключ> in <объект>", но не рекомендуется это делать из-за проблем, которые он может вызвать.

• Правила массивов. 

Технически массивам можно присваивать свойства как и объектам, но так как массивы в своей основе являются объектами, то это не рекомендуется делать,
так как тогда движок "JavaScript" будет работать с массивом как с объектом. Движок "JavaScript" работая с нормальными массивами обрабатыват их быстро, так как он оптимизирует их,
но когда массиву будет присвоено свойство как к объекту, он перестанет их обрабатывать как массив, и это скажется на оптимизации.

Не рекомендуется создавать "дыры" в массиве, добавляя в него значения под большим индексом (например "arr[9999] = 'apple';").

• "this" в массивах. "this" работает с массивами так же как и с объектами:

	let arr = ["a", "b"];

	arr.push(function() {
		console.log( this );
	})

	arr[2](); //  "a","b",function
	
• Удаление элементов массива с помощью оператора "delete". При удалении элементов этим способом, элемент удаляется, а его место сохраняется, то есть свойство "length" массива
останется неизменным.
	
• Методы массивов:

	"pop()"	-	удаляет последний элемент массива, и возвращает его.

	"push(<элементы>)"	-	добавляет элементы в конец массива. Можно передавать больше одного элемента в метод "push". Вызов данного метода без аргументов вернет длину массива.

	"shift"	-	удаляет из массива первый элемент и возвращает его.

	"unshift(<элементы>)"	-	добавляет элементы в начало массива. Можно передавать больше одного элемента в метод "unshift". Вызов данного метода без аргументов вернет длину массива.

	"pop"/"push"	-	работают быстрее методов "shift"/"unshift".

	"toString()"	-	возвращает список элементов, разделённых запятыми.
	Массивы не имеют ни "[Symbol.toPrimitive]", ни функционирующего "valueOf", они реализуют только преобразование "toString".
	
	"splice(<позиция>, <количество (опционально)>, <новый элемент (может быть несколько)>)"	-	универсальный метод для удаления, добавления и замены элементов массива.
	Данный метод начинает с позиции "<позиция>", удаляет "<количество (опционально)>" элементов и вставляет "<новый элемент (может быть несколько)>" на их место.
	Возвращает массив из удалённых элементов. Если не задавать параметров кроме "<позиция>", то будут удалены все элементы, начиная с заданной позиции.
	Если "<количество (опционально)>" задать 0, то новые передаваемые элементы будут добавлены в массив начиная с заданной позиции. Позицию можно задать отрицательным числом,
	тогда позиция будет с конца массива.
	• Изменяет исходный массив.
	
	"slice(<позиция начала (опционально)>, <позиция конца (опционально)>)"	-	возвращает новый массив, в который копирует элементы, начиная с начальной позиции и до
	конечной позиции (не включая позицию конца). Оба индекса параметра могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
	Оба индекса опциональны. Если данному методу не задать никаких параметров, то он вернет копию массива (без глубокого копирования). Если "<позиция конца (опционально)>"
	больше чем длина массива, то эти пустые значения игнорируются.
	• Исходный массив останется неизменным.
	
	"concat(<аргумент1>, <аргумент2 (опционально)>, <аргументN (опционально)>)"	-	данный метод возвращает новый массив, копируя аргументы в массив, у которого вызван данный метод.
	Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями. Исходный массив останется неизменным.
	Если в качестве параметра передать массивоподобный объект, то метод не сработает:
	
		let arr = [1, 2];
		
		let arrayLike = {
			0: "something",
			length: 1
		}
		
		console.log ( arr.concat(arrayLike) );	//	1,2,[object Object]
		
		Чтобы метод сработал при таком аргументе, то нужно такому объекту задать специальный символ "[Symbol.isConcatSpreadable]" со значением "true":
		
			let arr = [1, 2];
		
			let arrayLike = {
				0: "something",
				1, "something else",
				[Symbol.isConcatSpreadable]: true,
				length: 2
			}
			
			console.log ( arr.concat(arrayLike) );	//	1,2,something, something else
			
		Для корректной обработки в объекте обязательно должны быть числовые свойства и "length".
		
	"forEach(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){})"	-	данный метод выполняет фукцию для каждого элемента массива.
	Принимает колбэк функцию, который в свою очередь принимает текущий элемент массива, его индекс и сам массив.
	Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
	
	"indexOf(<подстрока>, <позиция (опционально)>);", "lastIndexOf(<подстрока>, <позиция (опционально));", "includes(<подстрока>, <позиция (опционально)>);"	-	эти методы
	аналогичны методам строк, но вместо символов они работают с элементами массива. Эти методы используют строгое сравнение при выборе элементов.
	Метод "includes" отличается от двух остальных методов работой с "NaN":
	
		const arr = [NaN];
		console.log( arr.indexOf(NaN) );	//	-1 (должен быть 0, но === проверка на равенство не работает для NaN).
		console.log( arr.includes(NaN) );	//	true (верно).
	
	"find(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>){}, <thisArg (опционально)>)"	-	данный метод предназначен для поиска элемента массива с определенным условием.
	Данный массив принимает колбэк функцию, который в свою очередь принимает текущий элемент, его индекс и сам массив. Если функция возвращает "true", то выполнение функции
	останавливается, и возвращается текущий элемент. Если ничего не найдено, то возвращается "undefined". "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let users = [
			{id: 1, name: "Вася"},
			{id: 2, name: "Петя"},
			{id: 3, name: "Маша"}
		];

		let user = users.find(item => item.id == 1);

		console.log(user.name);	//	Вася
		
	"findIndex(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>{}, <thisArg (опционально)>)"	-	данный метод схож с методом "find", но возвращает индекс,
	на котором был найден элемент, а не сам элемент, и "-1", если ничего не найдено. "<thisArg (опционально)>" - явное указание "this" методу.
	
	"filter(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>{}, <thisArg (опционально)>)"	-	данный метод схож с методом "find", но в отличии от него, при нахождении множества
	элементов возвращает массив из всех подходящих элементов. "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let users = [
			{id: 1, name: "Вася"},
			{id: 2, name: "Петя"},
			{id: 3, name: "Маша"}
		];

		//	возвращает массив, состоящий из двух первых пользователей.
		let someUsers = users.filter(item => item.id < 3);

		console.log(someUsers.length);	//	2
		
	"map(function(<элемент>, <индекс (опционально)>, <сам массив (опционально)>, <thisArg (опционально)>)"	-	данный метод вызывает функцию колбэк для каждого элемента массива,
	и возвращает массив результатов выполнения этой функции. "<thisArg (опционально)>" - явное указание "this" методу. Пример:
	
		let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
		alert(lengths);	//	5,7,6
		
	"sort(<фукнция колбэк>)"	-	метод для сортировки исходного массива. Данный метод возвращает отсортированный массив, но обычно возвращаемое значение игнорируется,
	так как изменяется сам исходный массив. Данный метод принимает функцию колбэк, который в свою очередь принимает два сравниваемых элемента. По умолчанию элементы сортируются
	как строки. Функция колбэк должна вернуть положительное число, если первый элемент больше второго, отрицательное число, если второй элемент больше первого, и ноль, если равны.
	От функции сравнения требуется любое положительное число, чтобы сказать "больше", и отрицательное число, чтобы сказать "меньше".
	
	• Параметры, которые будут передаваться в колбек метода "sort", будут обратные места (например элемент, который получит "a" будет после элемента, который получит "b").
	
	Пример:
	
		function compare(a, b) {
			return a - b;
		}
		
		let arr = [ 1, 2, 15 ];

		arr.sort(compareNumeric);

		alert(arr);	//	1, 2, 15
	
		Данный метод можно записать в коротком виде с помощью стрелочных функций:
		
			arr.sort( (a, b) => a - b );
			
	"reverse()"	-	метод меняет порядок элементво в массиве на обратный.
	
	"join(<соеденитель>)"	-	данный метод делает противоположное методу "split" у строк, а именно создает строку из массива по заданному соеденителю. Если оставить место
	соединителя пустым, то будет примен соеденитель по умолчанию - символ ",". Пример:
	
		let arr = ['Вася', 'Петя', 'Маша'];

		let str1 = arr.join(';');	//	объединить массив в строку через ";".
		
		let str2 = arr.join();	//	пустой соеденитель. Будет примен соеденитель по умолчанию ",".

		console.log( str1 );	//	Вася;Петя;Маша
		console.log( str2 );	//	Вася,Петя,Маша
		
	"reduce(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>)"	-	данный
	метод перебирает массив и возвращает единое результирующее значение. "<старое значение>" равно результату предыдущего вызова этой функции
	(равен "<изначальное значение (опционально)>" при первом вызове, если таковой был передан).
	При отсутствии изначального значения в колбэке, в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
	Если массив пуст, то вызов "reduce" без начального значения выдаст ошибку.
	Пример:
	
		let arr = [1, 2, 3, 4, 5];

		let result = arr.reduce((sum, current) => sum + current, 0);

		alert(result);	//	15
		
	"reduceRight(function(<старое значение>, <текущий элемент>, <индекс элемента (опционально)>, <сам массив (опционально)>){}, <изначальное значение (опционально)>)" - данный
	метод идентичен методу выше, за исключеним что он работает спарава на лево.
	
• Методы объекта "Array":

	Array.isArray(<аргуент>)
	
		Метод для проверки, является ли аргумент массивом или нет. Данный метод возвращает булево значение.
		
	Array.from(<аргумент>, <mapFn (опционально), <thisArg (опционально)>)
	
		Данный метод принимает итерируемый объект или псевдомассив и делает из него "настоящий" массив. После этого можно использовать методы массивов у него.
		Например:
		
			let arrayLike = {
				0: "Hello",
				1: "World",
				length: 2
			};

			let arr = Array.from(arrayLike);
			alert(arr.pop()); // World (метод работает).
			
		То же самое с итерируемым объектом:
		
			let range = {
				from: 1,
				to: 5
			};

			range[Symbol.iterator] = function() {
				return {
					current: this.from,
					last: this.to,

					next() {
						if (this.current <= this.last) {
							return { done: false, value: this.current++ };
						} else {
							return { done: true };
						}
					}
				};
			};
		
			let arr = Array.from(range);
			alert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)
			
		Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив:
		
			//	"range" взят из примера выше.

			//	возводим каждое число в квадрат.

			let arr = Array.from(range, num => num * num);

			alert(arr);	//	1,4,9,16,25
			
		В отличие от метода "split" у строк, этот метод в работе опирается на итерируемость строки, и поэтому, как и "for... of ...", он корректно работает с суррогатными парами.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Ключевое слово "this".

Ключевое слово "this" указывает на контекст вызова, то есть указывает на то, где оно находится (на текущий объект).

Например:

	let user = {
	  name: "Джон",
	  age: 30,
	  sayHi() {
		alert(this.name);	//	здесь "this" - это "текущий объект"
	  }
	};

	user.sayHi(); // Джон
	
	В данном примере значение "this" – это объект "перед точкой", который использовался для вызова метода. То есть в данном примере "this.name" внутри объекта "user" это
	все равно что "user.name" (ссылка на объект "user").
	
Если будет создана ссылка на объект под новым именем, а затем где-то будет "затерто" первичное имя объека, то попытка использовать методы этого объекта, которые в свою очередь
внутри используют свойства этого объекта через прямое обращение через первичное имя объека (например: "user.name") приведет к ошибке, так как это имя объекта уже затерто.
Поэтому в методе нужно использовать ключевое слово "this", которое будет указывать на текущий объект.

Значение "this" вычисляется во время выполнения кода и зависит от контекста.
Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение "this" при разных вызовах:

	let user = { name: "Джон" };
	let admin = { name: "Админ" };

	function sayHi() {
	  alert( this.name );
	}

	//	используем одну и ту же функцию в двух объектах.
	user.f = sayHi;
	admin.f = sayHi;

	//	вызовы функции, приведённые ниже, имеют разное значение "this".
	//	"this" внутри функции является ссылкой на объект, который указан "перед точкой".
	user.f();	//	Джон  (this == user)
	admin.f();	//	Админ  (this == admin)

	admin['f']();	//	Админ (неважен способ доступа к методу - через точку или квадратные скобки).
	
Когда вызывается метод объекта, "object.method()", значением "this" во время вызова является объект перед точкой.
	
Примечание ! Вызов "this" без объекта = "undefined". В строгом режиме ('"use strict"') в коде значением "this" будет являться "undefined".
В нестрогом режиме значением "this" в таком случае будет глобальный объект ("window").

	function sayHi() {
	  alert(this);
	}

	sayHi();	//	undefined
	
Потеря значения "this". Если создать функцию через "Function Expression", беря саму функцию как метод, из какого либо объекта, который внутри себя использут "this", то созданная
функция потеряет контекст вызова "this":

	let user = {
		name: "Джон",
		hi() {
			alert(this.name);
		}
	};
	
	let hi = user.hi;	//	Создадим функцию через "Function Expression".
	hi(); // Ошибка, потому что значением "this" потеряно, и является "undefined".
	
Еще пример c самовызываемой функцией (или немедленно вызываемой функциией) (анонимной) ("Immediately-Invoked Function Expression" - "IIFE") с использованием тернарного оператора:

	let user = {
		name: "Джон",
		hi() { alert(this.name); },
		bye() { alert("Пока"); }
	};

	user.hi();	//	Джон (простой вызов метода работает хорошо)

	(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
	
	В данном примере при "истине", выполняется первая часть оператора, который возвращает (но не вызывает!) метод, который в свою очередь сразу же вызывается с помощью скобок "()"
	в конце тернарного оператора. Так как метод не вызвался сразу внутри тернарного оператора как метод объекта "user", а была возвращена его функция, то эта функция потеряла
	контекст вызова "this", так как уже не имеет отнощение к объекту "user". А затем эта функция была вызвана, и вызвала ошибку.
	
У стрелочных функций нет "this". Стрелочные функции берут контекст вызова "this" на уровени выше собственного, до нормальной функции (не стрелочной) (до внешней нормальной фунции).
Например:

	let user = {
		firstName: "Илья",
		sayHi() {
			let arrow = () => console.log(this.firstName);
			arrow();
		}
	};
	
	user.sayHi();	//	Илья
	
Контекст вызова "this" не смотрит на объявление объекта, а лишь на момент вызова:

	function makeUser() {
		return {
			name: "Джон",
			ref: this
		};
	}

	let user = makeUser();

	alert( user.ref.name );	//	Error: Cannot read property 'name' of undefined
	
	Здесь значение "this" внутри "makeUser()" является "undefined", потому что "makeUser()" вызвана как функция, не через "точку" как метод.
	Таким образом, при создании объекта "ref: this" берёт текущее значение "this" функции "makeUser()".
	
	Противоположный пример:
	
		function makeUser() {
			return {
				name: "Джон",
				ref() {
					return this;
				}
			};
		}

		let user = makeUser();

		alert( user.ref().name );	//	Джон
		
	Теперь это работает, поскольку "user.ref()" вызывается как метод, и значением "this" становится объект перед точкой ".".

• В модулях внешний "this" не определен (равен "undefined", а не "window").

• При вызове метода у объекта, "this" всегда объект перед точкой (".").

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Переадресация вызовов функций - "call", "apply". У функций есть встроенные методы "call" и "apply", которые позволяют явео передать "this" функции.
Форма синтаксиса метода "call":

	call(<контекст>, <аргуенты функции>);
	
Пример:

	let obj = {...};
	function fn(text, number){...}
	fn.call(obj, "Hello", 155);
	
Форма синтаксиса метода "apply":

	apply(<контекст>, <массив аргументов>);
	
Пример:

	let obj = {...};
	function fn(arr){...}
	fn.apply(obj, ["Hello", 155]);
	
Разницей методов "call" и "apply" является что "call" принимает аргументы через запятую, в то время как "apply" принимает массив аргументов.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Привязка контекста вызова с помощью "bind".
Форма синтаксиса "bind":

	bind(<контекст>, <аргументы функции>);
	
Результатом вызова метода "bind" является особый "экзотический объект", который затем можно вызвать как функцию.
	
Пример с обычной функцией:

	let user = {
		firstName: "Вася"
	};

	function func(phrase) {
		console.log(phrase + ', ' + this.firstName);
	}

	let funcUser = func.bind(user);	//	привязка "this" к "user".

	funcUser("Привет"); // Привет, Вася (аргумент "Привет" передан, при этом "this" = "user").
	
Пример с методом объекта:

	let user = {
		firstName: "Вася",
		say(phrase) {
			alert(`${phrase}, ${this.firstName}!`);
		}
	};

	let say = user.say.bind(user);

	say("Привет");	//	Привет, Вася (аргумент "Привет" передан в функцию "say").
	say("Пока");	//	Пока, Вася (аргумент "Пока" передан в функцию "say").
	
Частичное применение аргументов. Пример с привязкой аргументов:

	function mul(a, b) {
		return a * b;
	}

	let double = mul.bind(null, 2);

	alert( double(3) );	//	= mul(2, 3) = 6
	alert( double(4) );	//	= mul(2, 4) = 8
	alert( double(5) );	//	= mul(2, 5) = 10
	
	В данном примере создается новая функция, фиксируя некоторые из существующих параметров. Следующие аргументы передаются как есть.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Тип данных - "Symbol".

Тип "Символ" -  представляет собой уникальный идентификатор. Новые символы с помощью функции "Symbol()":

	let id = Symbol();
	
При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода. Оно не играет большой роли кроме помощи в отладке.
Это имя/описание можно передать как параметр в функцию "Symbol()":

	let id = Symbol("id");
	
Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
Например, вот два символа с одинаковым описанием – но они не равны:

	let id1 = Symbol("id");
	let id2 = Symbol("id");
	
	console.log(id1 == id2); // false
	
Примечание! Символы не преобразуются автоматически в строки.

Чтобы обратиться/вывести описание символа, у символа есть метод "decription":

	let id = Symbol("idDescription");
	console.log(id.description);	//	idDescription
	
Символы позволяют создавать "скрытые" свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы:

	let user = {
	  name: "Вася"
	};

	let id = Symbol("id");

	user[id] = 1;

	console.log( user[id] ); // мы можем получить доступ к данным по ключу-символу
	
Если мы хотим использовать символ при литеральном объявлении объекта "{}", его необходимо заключить в квадратные скобки.

	let id = Symbol("id");

	let user = {
	  name: "Вася",
	  [id]: 123	//	просто "id: 123" не сработает
	};
	
Примечание! Свойства объекта, чьи имена созданы с помощью символов не итерируются с помощью циклов "for in", а так же с помощью метода "keys"
объекта "Object" - ("Object.keys(obj)"). Метод "assign" объекта "Object" напротив имеет доступ ко всем свойствам объекта, как к остальным примитивным типам данных,
так и символьным типам.

Глобальные символы - символы с одинаковыми именами, указывающие на одинаковые сущности. Для этого существует "глобальный реестр символов".

Для чтения (или, при отсутствии - создания) символа из реестра используется метод "for" объекта "Symbol" - "Symbol.for(<имя ключа>)". Он проверяет глобальный реестр и,
при наличии в нём символа с именем "<имя ключа>", возвращает его, иначе же создаётся новый символ "Symbol(<имя ключа>)" и записывается в реестр под ключом "<имя ключа>".
Пример:

	let id = Symbol.for("id");	//	если символа не существует, он будет создан

	let idAgain = Symbol.for("id");	//	читаем его снова в другую переменную (возможно, из другого места кода)
	
	alert( id === idAgain ); // true
	
Символы, содержащиеся в реестре, называются "глобальными символами". Если вам нужен символ, доступный везде в коде – используйте "глобальные символы".

Метод "keyFor" объекта "Symbol" принимает глобальный символ и возвращает его имя - "Symbol.keyFor(<символ>)":

	//	получаем символ по имени
	let sym = Symbol.for("name");
	let sym2 = Symbol.for("id");

	//	получаем имя по символу
	alert( Symbol.keyFor(sym) );	//	name
	alert( Symbol.keyFor(sym2) );	//	id
	
Внутри метода "Symbol.keyFor" используется глобальный реестр символов для нахождения имени символа. Этот метод не будет работать для неглобальных символов.
Например:

	let globalSymbol = Symbol.for("name");
	let localSymbol = Symbol("name");

	alert( Symbol.keyFor(globalSymbol) );	//	"name" - глобальный символ
	alert( Symbol.keyFor(localSymbol) );	//	"undefined" - для неглобального символа

	alert( localSymbol.description );	//	name
	
Для любых символов доступно свойство "description".

• Системные символы. Существует множество "системных" символов, использующихся внутри самого "JavaScript", и мы можем использовать их, чтобы настраивать
различные аспекты поведения объектов. Некоторые из системных символов:

	Symbol.isConcatSpreadable
	
	Symbol.iterator
	
	Symbol.asyncIterator
	
	Symbol.toPrimitive
	
	Symbol.species
	
	Symbol.hasInstance
	
	Symbol.toStringTag
	
Примечание! Существует встроенный метод "getOwnPropertySymbols" объекта "Object" - "Object.getOwnPropertySymbols(obj)" – с его помощью можно получить все свойства объекта с
ключами-символами. Также существует метод "ownKeys" объекта "Reflect" - "Reflect.ownKeys(obj)" - который возвращает все ключи объекта, включая символьные.

• "Symbol.iterator"	-	это специальный встроенный символ, который превращает неитерируемый объект в итерируемый объект (для цикла "for ... of ...").
Чтобы сделать объект итерируемым (и позволить "for... of ..." работать с ним), нам нужно добавить в объект метод с именем "Symbol.iterator".
Когда цикл "for.. of ..." запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом "next".
Дальше цикл "for.. of ..." работает в этим объектом, каждый раз вызывая у него метод "next()".
Результат вызова "next()" должен иметь вид "{done: <булево значение>, value : <значение>}", где "done = true" означает, что итерация закончена,
в противном случае "value" содержит очередное значение. Пример:

	let range = {
		from: 1,
		to: 5
	};

	range[Symbol.iterator] = function() {	//	Вызов "for ... of ..." сначала вызывает эту функцию.

		//	Она возвращает объект итератора:
		//	Далее, "for ... of ..." работает только с этим итератором, запрашивая у него новые значения.
		return {
			current: this.from,
			last: this.to,
			
			next() {	//	"next()" вызывается на каждой итерации цикла "for ... of ...".
			//	Он должен вернуть значение в виде объекта "{done: <булево значение>, value : <значение>}".
				if (this.current <= this.last) {
					return { done: false, value: this.current++ };
				}
				else {
					return { done: true };
				}
			}
		};
	};

	for (let num of range) {
	  alert(num);	//	1, 2, 3, 4, 5
	}
	
Явный вызов итератора. Можно вызвать метод "next()" у итератора вручную:

	let str = "Hello";

	//	делает то же самое, что и "for (let char of str) { alert(char)}";
	
	let iterator = str[Symbol.iterator]();

	while (true) {
		let result = iterator.next();
		if (result.done) break;
		alert(result.value); // выводит символы один за другим
	}

• "Symbol.asyncIterator" - схож с "Symbol.iterator", за исключением что "Symbol.asyncIterator" превращает неитерируемый объект в асинхронно-итерируемый объект,
который будет перебираться циклом "for await ... of ...". Метод "next()" уже должен вернуть промис.
Для этого достаточно указать перед объявлением метода "next()" оператор "async" (так как оператор "async" автомаически возвращает промис).
Сам цикл "for await ... of ..." должен находиться в асинхронной фукнции. Пример:

	let range = {
		from: 1,
		to: 5,
		[Symbol.asyncIterator]() {
			return {
				current: this.from,
				last: this.to,
				async next() {
					await new Promise(resolve => setTimeout(resolve, 1000));	// Здесь "await" используется просто чтобы создать задержку (ничего не возвращает).

					if (this.current <= this.last) {
						return { done: false, value: this.current++ };
					} else {
						return { done: true };
					}
				}
			};
		}
	};

	(async () => {

		for await (let value of range) {
			console.log(value); // 1,2,3,4,5
		}

	})()

• Цикл "for await ... of ..." работает следующим образом. Он запускает асинхронный итератор один раз, и записывает объект который он вернул в переменную, и дальше уже работает
с этим объектом. Каждый раз цикл вызывает метод "next", который возвращает промис. Оператор "await" уже работает с этим промисом, каждый раз передавая циклу результат выполнения.

• Символы "[Symbol.species]" и "[Symbol.hasInstance]" - подробнее в главе "Классы". Символ "[Symbol.toStringTag]" - подробнее в главе "Преобразование типов",
подглава "Изменение поведения метода "toString"".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Конструкторы. Ключевое слово "new".

Обычный синтаксис литерала объекта "{...}" позволяет создать только один объект. Если необходимо создать множество однотипных объектов, таких как пользователи,
элементы меню и т.д., то можно сделать при помощи функции-конструктора и оператора "new".

• Функция-конструктор.

Функции-конструкторы являются обычными функциями. Но есть два соглашения:

	1. Имя функции-конструктора должно начинаться с большой буквы.
	
	2. Функция-конструктор должна вызываться при помощи оператора "new".
	
	Например:
	
		function User(name) {
			this.name = name;
			this.isAdmin = false;
		}

		let user = new User("Вася");

		alert(user.name);	//	Вася
		alert(user.isAdmin);	//	false
		
Когда функция вызывается как "new User(...)", происходит следующее:

	1. Создаётся новый пустой объект, и он присваивается "this".
	
	2. Выполняется код функции. Обычно он модифицирует "this", добавляет туда новые свойства.
	
	3. Возвращается значение "this".
	
	Другими словами, вызов "new User(...)" делает примерно вот что:

		function User(name) {
			//	this = {}; (неявно)

			//	добавляет свойства к this
			this.name = name;
			this.isAdmin = false;

			//	return this; (неявно)
		}
		
	То есть, результат вызова new User("Вася") – это тот же объект, что и:

		let user = {
			name: "Вася",
			isAdmin: false
		};

	Если вызвать функцию коструктор без "new", то входное значение "name" будет присвоено глобальной области видимости,
	так как оно было вызвано без "new",	а поэтому "this" не будет указывать на новосозданный объект, так как его нету,
	и поэтому "this" будет указывать на глобальную область видимости. Например:

		function Human(name) {
			this.name = name;
		}

		Human("Oleg");

		Этот вызов исполнит следующее 'this.name = "Oleg"', а так как мы находимся в глобальной области видимости,
		то "this" присвоит "name" к глобальной области видимости. Это свойство можно посмотреть просто вписав "name",
		и оно вернет нам "Oleg".

		Чтобы избежать данной проблемы, мы можем проверить куда действует "this":

			fuction Human(name) {
				if (! (this instanceof Human)){ return new Human(name);}
				this.name = name;
			}

		В данном примере мы проверяем условие, не находится ли "this" в цепочке прототипов "Human" (относится ли "this" к глобальной области видимости),
		и если его нет, то вернет правильный вызов функции "Human" с "new". А если есть (присутствует "new"), то выполняет обычный правильный вызов.
		"instanceof" проверяет, есть ли в цепочке прототипов левого аргумента, прототип правого аргумента.
		
Технически любая функция может быть использована как конструктор. То есть, каждая функция может быть вызвана при помощи оператора "new",
и выполнится алгоритм, указанный выше в примере. Заглавная буква в названии функции является всеобщим соглашением по именованию,
она как бы подсказывает разработчику, что данная функция является функцией-конструктором, и её нужно вызывать через "new".

Если в нашем коде большое количество строк, создающих один сложный объект, мы можем обернуть их в функцию-конструктор следующим образом:

	let user = new function() {
		this.name = "Вася";
		this.isAdmin = false;

		//	...другой код для создания пользователя
		//	возможна любая сложная логика и выражения
		//	локальные переменные и т. д.
	};
	
	Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создаётся и тут же вызывается.
	Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, но без возможности его повторного использования.
	
• Проверка на вызов в режиме конструктора: "new.target" (данный метод используется очень редко).

Используя специальное свойство "new.target" внутри функции, можно проверить, вызвана ли функция при помощи оператора "new" или без него.
В случае, если функция вызвана при помощи "new", то в "new.target" будет сама функция, в противном случае - "undefined".
Это можно использовать, чтобы отличить обычный вызов от вызова "в режиме конструктора". В частности, вот так можно сделать,
чтобы функцию можно было вызывать как с, так и без "new":

	function User(name) {
		if (!new.target) {	//	в случае, если вы вызвали без оператора "new".
			return new User(name);	//	...добавим оператор "new" за вас.
		}

		this.name = name;
	}

	let vasya = User("Вася");	//	переадресовывает вызовы на "new User".
	alert(vasya.name);	//	Вася
	
• Возврат значения из конструктора "return".

Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в "this", который в итоге станет результатом.
Но если "return" всё же есть, то применяется простое правило:

	1. При вызове "return" с объектом, будет возвращён объект, а не "this".

	2. При вызове "return" с примитивным значением, примитивное значение будет отброшено.
	
Другими словами, "return" с объектом возвращает объект, в любом другом случае конструктор вернёт "this".

В примере ниже "return" возвращает объект вместо "this":

	function BigUser() {

		this.name = "Вася";

		return { name: "Godzilla" };	//	<- возвращает этот объект.
	}

	alert( new BigUser().name );	//	"Godzilla" -> получили этот объект.
	
А вот пример с пустым "return" (или можно было поставить примитив после "return", неважно):

	function SmallUser() {

		this.name = "Вася";

		return;	//	<-	возвращает "this".
	}

	alert( new SmallUser().name );	//	Вася
	
Важно! Обычно у конструкторов отсутствует "return".

Если вызов конструктора идёт без аргументов, то можно не ставить скобки после "new":

	let user = new User;	//	<- без скобок.
	// то же, что и
	let user = new User();
	
• Создание методов в конструкторе. В "this" мы можем добавлять не только свойства, но и методы.

Например, в примере ниже, "new User(name)" создаёт объект с данным именем "name" и методом "sayHi":

	function User(name) {
		this.name = name;

		this.sayHi = function() {
			alert( "Меня зовут: " + this.name );
		};
	}

	let vasya = new User("Вася");

	vasya.sayHi(); // Меня зовут: Вася

	/*
	vasya = {
		name: "Вася",
		sayHi: function() { ... }
	}
	*/
	
• Использование конструкторов для "String", "Number" и "Boolean".

Можно создать примитивы "String", "Number" и "Boolean" с помощью их конструкторов. В таком случае будет возвращен объект-обертка, с соответствующим значением:

	let a = new Number(0);
	
	console.log( typeof 0 );	//	number

	console.log( typeof a );	// 	object
	
	console.log( a.valueOf() );	// 	0
	
• Стрелочные функции нельзя использовать как конструкторы (с ключевым словом "new"), так как у них нет собственного "this".

• У объектов есть свойство "constructor", которое указывает обратно на функцию-конструктор, который его создал.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объекты "Map", "Set", "WeakMap", "WeakSet".

"Map":

	"Map"	-	это коллекция ключ/значение, как и "Object". Но основное отличие в том, что "Map" позволяет использовать вместо ключа любой тип данных
	(примитив, объект, массив, функция и т.д.). "Map" является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "Map":
	
		let map = new Map([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
	
	Методы и свойства объекта "Map":
	
		set(<ключ>, <значение>)	–	записывает по ключу "<ключ>" значение "<значение>".
		
		get(<ключ>)	–	возвращает значение по ключу или "undefined", если ключ "<ключ>" отсутствует.
		
		has(<ключ>)	–	возвращает "true", если ключ "<ключ>" присутствует в коллекции, иначе "false".
		
		delete(<ключ>)	–	удаляет элемент по ключу "<ключ>".
		
		clear()	–	очищает коллекцию от всех элементов.
		
		size	–	возвращает текущее количество элементов.
		
		keys()	–	возвращает итерируемый объект по ключам.
		
		values()	–	возвращает итерируемый объект по значениям.
		
		entries()	–	возвращает итерируемый объект по парам вида "[ключ, значение]", этот вариант используется по умолчанию в цикле "for... of ...".
		
		forEach(function(<значение>, <ключ (опционально)>, <сам объект "Map" (опционально)>){})	-	метод схожий со встроенным методом массивов "Array",
		который принимает колбэк функцию, который в свою очередь принимает текущий элемент объекта "Map", его индекс и сам массив.
		
	Пример создания нового объекта "Map":
	
		let map = new Map();

		map.set("1", "str1");	//	строка в качестве ключа.
		map.set(1, "num1");	//	цифра как ключ.
		map.set(true, "bool1");	//	булево значение как ключ.

		alert(map.get(1)); 	//	"num1".
		alert(map.get("1"));	//	"str1".

		alert(map.size); // 3
		
	Можно использовать объекты в качестве ключей:
		
		let john = { name: "John" };

		// сохраним количество посещений для каждого пользователя.
		let visitsCountMap = new Map();

		// объект "john" - это ключ для значения в объекте "Map".
		visitsCountMap.set(john, 123);

		alert(visitsCountMap.get(john));	//	123
		
	• 	"Map" использует почти такое же сравнение, что и "===", с той лишь разницей, что "NaN" считается равным "NaN". Так что "NaN" также может использоваться в качестве ключа.
	
	Каждый вызов метода "set" у объекта "Map" возвращает объект "Map", так что можно объединить вызовы в цепочку:
	
		map.set("1", "str1").set(1, "num1").set(true, "bool1");
		
	Пример использования методов "keys()", "values()", "entries()":
	
		let recipeMap = new Map([
			["огурец", 500],
			["помидор", 350],
			["лук",    50]
		]);

		//	перебор по ключам (овощи).
		for (let vegetable of recipeMap.keys()) {
			alert(vegetable);	//	огурец, помидор, лук
		}

		//	перебор по значениям (числа).
		for (let amount of recipeMap.values()) {
			alert(amount);	//	500, 350, 50
		}

		// перебор по элементам в формате "[ключ, значение]".
		for (let entry of recipeMap) {	//	то же самое, что и "recipeMap.entries()".
		alert(entry); // огурец,500 (и так далее)
	
	Пример использования метода "forEach":
	
		recipeMap.forEach((value, key, map) => {
			alert(`${key}: ${value}`); // огурец: 500 и так далее.
		});
		
	У главного объекта "Object" есть метод "entries(<объект>)", который получив на вход объект, вернет его в виде массива с парами ключ-значение. Из такого массива можно создать
	объект "Map":
	
		let obj = {
			name: "John",
			age: 30
		};

		let map = new Map(Object.entries(obj));
		
	У главного объекта "Object" есть еще метод "fromEntries(<массив>)", который получив на вход масссив (вида пар ключ-значение), вернет обычный объект:
	
		let map = new Map();
		map.set('banana', 1);
		map.set('orange', 2);
		map.set('meat', 4);

		let obj = Object.fromEntries(map.entries());	//	make a plain object.

		// готово!
		// obj = { banana: 1, orange: 2, meat: 4 }

		alert(obj.orange); // 2
		
	Можно писать еще короче:
	
		let obj = Object.fromEntries(map);

"Set":

	"Set"	-	это коллекция из уникальных значений (без ключей), где каждое значение может появиться только раз. Значениями могуть быть любые данные
	(примитив, объект, массив, функция и т.д.). "Set" является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "Set":
	
		let set = new Set([<элементы (опционально)>]);
		
	Методы и свойства объекта "Set":
	
		add(<значение>)	-	добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект "set".
		
		delete(<значение>) – удаляет значение, возвращает "true" если "value" было в множестве на момент вызова, иначе "false".
		
		has(<значение>) – возвращает "true", если значение присутствует в множестве, иначе "false".
		
		clear() – удаляет все имеющиеся значения.
		
		size – возвращает количество элементов в множестве.
		
		keys()	-	возвращает перебираемый объект для значений.
		
		values()	-	то же самое, что и "keys()", присутствует для обратной совместимости с "Map".
		
		entries()	-	возвращает перебираемый объект для пар вида "[<значение>, <значение>], присутствует для обратной совместимости с "Map".
		
		forEach(function(<значение>, <значение (опционально)>, <сам объект "Set" (опционально)>){})	-	метод схож с методом "forEach" объекта "Map", отличается тем,
		что у метода "forEach" объекта "Set" дублируются аргументы "<значение>", так как он имеет только значения, и сделано оно так для обратной совместимости с
		объектом "Map".		
		
	Пример использования объекта "Set":
	
		let set = new Set();

		let john = { name: "John" };
		let pete = { name: "Pete" };
		let mary = { name: "Mary" };

		// считаем гостей, некоторые приходят несколько раз.
		set.add(john);
		set.add(pete);
		set.add(mary);
		set.add(john);
		set.add(mary);

		//	"set" хранит только 3 уникальных значения.
		alert(set.size); // 3
		
	"Set" так же как и "Map" является итерируемым объектом:
	
		let set = new Set(["апельсин", "яблоко", "банан"]);

		for (let value of set) alert(value);

		//	то же самое с "forEach":
		set.forEach((value, valueAgain, set) => {
			alert(value);
		});

• В отличие от обычных объектов "Object", в "Map" и "Set" перебор происходит в том же порядке, в каком происходило добавление элементов.

"WeakMap":

	"WeakMap"	-	это коллекция ключ/значение, как и "Map", отличиями от "Map" являются то что ключами могут быть только объекты, а не примитивы, и то что если объект,
	который является ключом в "WeakMap" будет где-то удален, то и ключ в "WeakMap" будет удален.  "WeakMap" не является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "WeakMap":
	
		let weakMap = new WeakMap([ [<ключ1>, <значение>], [<ключ2>, <значение>], [<ключN>, <значение>] ]);
		
	Методы объекта "WeakMap":
	
		set(<ключ>, <значение>)	–	записывает по ключу "<ключ>" значение "<значение>".
		
		get(<ключ>)	–	возвращает значение по ключу или "undefined", если ключ "<ключ>" отсутствует.
		
		has(<ключ>)	–	возвращает "true", если ключ "<ключ>" присутствует в коллекции, иначе "false".
		
		delete(<ключ>)	–	удаляет элемент по ключу "<ключ>".
	
	Пример использования объекта "WeakMap":
	
		let weakMap = new WeakMap();

		let obj = {};

		weakMap.set(obj, "ok");	//	работает (объект в качестве ключа).

		//	нельзя использовать строку в качестве ключа.
		weakMap.set("test", "Whoops");	//	Ошибка, потому что "test" не объект.
		
	Пример с ключом-объектом, который будет удален:
	
		let john = { name: "John" };

		let weakMap = new WeakMap();
		weakMap.set(john, "...");

		john = null;	//	перезаписываем ссылку на объект.

		//	объект john удалён из памяти!

"WeakSet":

	"WeakSet"	-	это коллекция из уникальных значений (без ключей), где каждое значение может появиться только раз. Отличием от "Set" является то, что в качестве ключей
	могут быть только объекты. "WeakSet" не является итерируемым объектом.
	
	Пример синтаксиса создания нового объекта "WeakSet":
	
		let weakSet = new WeakSet([<элементы (опционально)>]);
		
	Методы объекта "WeakSet":
	
		add(<значение>)	-	добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект "set".
		
		delete(<значение>) – удаляет значение, возвращает "true" если "value" было в множестве на момент вызова, иначе "false".
		
		has(<значение>) – возвращает "true", если значение присутствует в множестве, иначе "false".
		
	Пример использования объекта "WeakSet":
	
		let visitedSet = new WeakSet();

		let john = { name: "John" };
		let pete = { name: "Pete" };
		let mary = { name: "Mary" };

		visitedSet.add(john);	//	"John" заходил к нам.
		visitedSet.add(pete);	//	потом "Pete".
		visitedSet.add(john);	//	"John" снова.

		//	"visitedSet" сейчас содержит двух пользователей.

		//	проверка, заходил ли "John"?
		alert(visitedSet.has(john)); // true

		//	проверка, заходила ли "Mary"?
		alert(visitedSet.has(mary)); // false

		john = null;

		//	структура данных "visitedSet" будет очищена автоматически.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Деструктуризация.

Деструктуризация это синтаксис, который позволяет нам "распаковать" массивы, объекты, строки (любые перебираемые объекты) в кучу переменных/свойств.

• Деструктуризация массивов/строк. Пример синтаксиса деструктуризации массивов/строк:

	let [<переменная/свойство> = <значение по умолчанию (опционально)>, <...rest (опционально)>] = <массив/строка>;
	
В данном примере переменным задаются значения из массива/строки по очереди (на что хватит). Если в массиве/строке больше элементов,
чем присваеваемых переменных/свойств в квадратных скобках, то будут присвоены только те элементы (по порядку), что указаны в квадратных скобках.
Если в массиве/строке меньше элементов, чем присваеваемых переменных в квадратных скобках, то будут присвоены только те элементы (по порядку), которых хватит,
а тем переменным/свойствам, которым не достались значения, будут присвоены "undefined". Пример:

	let [x, y, z] = "abc";

	let arr = [1,2,3];
	
	let [a, b, c, d] = arr;
	
	console.log(a, b, c, d);	//	1, 2, 3, undefined

Ненужные элементы массива/строки для деструктурированного присваивания могут быть отброшены через пустую запятую:

	let [a, , c, d] = arr;
	
	console.log(a, c, d);	//	1, 3, undefined

Остаточные параметры "...rest". Можно указать переменную в конце литерала деструктуризации (квадратных скобок) с тремя точками с переди, и с произвольным именем,
как массив для "оставшихся" параметров/элементов:

	let [name1, name2, ...restArr] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];	//	"restArr" является массивом с двумя оставшимися элементами массива.

	Подробнее в главе "Остаточные параметры и оператор расширения ("Rest" и "Spread")".
	
Значения по умолчанию. Если в массиве/строке меньше значений, чем указанных переменных, то им будет присвоено "undefined". Можно присвоить таким переменным
значения по умолчанию:

	let [name = "Guest", surname = "Anonymous"] = ["Julius"];
	
	console.log(name);	//	"Julius" - из массива.
	console.log(surname);	//	"Anonymous" -  значение по умолчанию.
	
Значения по умолчанию в деструктуризации могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

• Деструктуризация объекта. Деструктуризация объекта такая же как и у массивов и у строк но с некоторыми отличиями. Литерал деструктуризации для объектов это фигурные
скобки. Переменные/свойства в них перечисляются произвольно (не по порядку как в массивах/строках). Имена переменных/свойств должны совпадать с именами свойств в объекте.

Пример синтаксиса деструктуризации объектов:

	let {<переменная/свойство>: <другое имя (опционально)> = <значение по умолчанию (опционально)>, <...rest (опционально)>} = <объект>;
	
Пример деструктуризации объекта:

	let options = {
		title: "Menu",
		width: 100,
		height: 200
	};

	let {width, title, height} = options;
	
При деструктуризация объекта можно указать свойству объекта другое название, для этого новое название нужно указать после двоеточия:

	let options = {
		title: "Menu",
		width: 100,
		height: 200
	};
	
	let {width: w, height: h, title} = options;
	
	console.log(w);	//	100
	
При деструктуризация объекта можно указать свойству объекта значение по умолчанию, для этого значение по умолчанию нужно указать после знака равно. Так же можно совмещать
с указанием нового названия свойства:

	let options = {
		title: "Menu"
	};

	let {width = 100, height: h = 200, title} = options;
	
Как и в случае с массивами/строками, значениями по умолчанию могут быть любые выражения или даже функции.

Остаточные параметры "...rest" при деструктуризации объекта работает так же как и у массивов/строк, за исключением того, что они будут записаны в объект, вместо массива:

	let options = {
		title: "Menu",
		height: 200,
		width: 100
	};
	
	let {title, ...rest} = options;
	
	console.log(rest.height);  // 200
	console.log(rest.width);   // 100
	
Деструктуризация работает с любым перебираемым объектом, а так же обычным объектом:
	
	let [one, two, three] = new Set([1, 2, 3]);
	
	let user = {};
	[user.name, user.surname] = "Ilya Kantor".split(' ');
	
• Чтобы указать деструктуризацию без прямой вставки "let/const/var", нужно облачить все выражение деструктуризации в скобки:

	let title, width, height;

	({title, width, height} = {title: "Menu", width: 200, height: 100});
	
• Вложенная деструктуризация. Если объект или массив содержит другие вложенные объекты или массивы, то можно деструктурировать и их. Для вложенной десруктуризации объекта
нужно указать следующий литерал деструктуризации объекта после двоеточия, а для деструктуризации массива - литерал деструктуризации массива:

	let options = {
		size: {
			width: 100,
			height: 200
		},
		items: ["Cake", "Donut"],
		extra: true
	};
	
	let {size: {width, height}, items: [item1, item2], title = "Menu"} = options;
	
• Деструктуризация для параметров функций. Пример вложенной деструктуризации для входных параметров функций, вместе с параметрами по умолчанию:

	let options = {
		title: "My menu",
		items: ["Item1", "Item2"]
	};

	function showMenu({
		title = "Untitled",
		width: w = 100,  // "width" присваивается к "w".
		height: h = 200, // "height" присваивается к "h".
		items: [item1, item2] // первый элемент "items" присваивается к "item1", второй к "item2".
	}) {
		console.log(title, w, h, item1, item2);
	}
	
	showMenu(options);	//	My menu 100 200 Item1 Item2
	
Если не будет передаваться объект в функцию как входной параметр, то можно указать пустой объет по умолчанию:

	function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
		alert( `${title} ${width} ${height}` );
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дата и время.

Встроенный объект "Date" служит для получения даты и времени. Для создания нового объекта "Date" необходимо вызвать конструктор "new Date()" с необходимыми аргументами.
Пример синтаксиса создания объекта "Date":

	let now = new Date(<аргумент/ты>);
	
Получение даты/времени прошедшего с "1 января 1970 года UTC+0" в миллисекундах. Для этого нужно в качестве аргумента передать миллисекунды, прошедшие начиная с той даты:

	let Jan01_1970 = new Date(0);
	alert( Jan01_1970 );	//	Thu Jan 01 1970 03:00:00 GMT+0300
	
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп.
Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

	let Dec31_1969 = new Date(-24 * 3600 * 1000);	//	31 декабря 1969 года

Если аргумент всего один, и это строка, то из неё "прочитывается" дата. Если конструктору "new Date()" передать дату/время в строковом формате,
то он вернет объект с указанной датой/временем в соответствующем формате. Вид синтаксиса конструктора "new Date()" принимающий дату/время в строковом формате:

	let date = new Date("<год>-<месяц>-<день (опционально)>-<часы (опционально)>-<минуты (опционально)>-<секунды (опционально)>-<миллисекунды (опционально)>");
	
	К данному синтаксису есть требования:
	
		1. Год должен состоять из четырех цифр.
		
		2. Месяц начинается с "0" (январь), по "11" (декабрь).
		
		3. Если день не задан, то он принимается за "1".
		
		4. Если параметры "часы"/"минуты"/"секунды"/"миллисекунды" отсутствуют, то на их месте будет "0".

		Пример создания даты в соответствующем формате передавая дату в строковом виде:

			let date = new Date("2017-01-26");
			console.log(date);	//	"Thu Jan 26 2017 03:00:00 GMT+0300".

Если было передано несколько аргументов, то из них будет слагаться соответствующая дата. В таком случае минимум передаваемых аргументов это 2 (год и месяц).
Пример:
		
	new Date(2011, 0, 1, 0, 0, 0, 0);	//	1 Jan 2011, 00:00:00
	new Date(2011, 0, 1);	//	то же самое, так как часы и проч. равны "0".
	
Методы объектов, созданных конструктором "Date" (в соответствии с местным часовым поясом):

	Полчучение:

		getFullYear()	-	получить год (4 цифры)
		
		getMonth()	-	получить месяц, от 0 до 11.

		getDate()	-	получить день месяца, от 1 до 31, что несколько противоречит названию метода.

		getHours(), getMinutes(), getSeconds(), getMilliseconds()	-	получить, соответственно, часы, минуты, секунды или миллисекунды.
		
		getDay()	-	вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник,
		в "JavaScript" начало недели приходится на воскресенье. Дни недели в "getDay()" также отсчитываются с нуля, что соответствует воскресенью.
		
		getUTCFullYear(), getUTCMonth(), getUTCDay()	-	возвращение даты/времени для временной зоны "UTS-0".
		
		getTime()	-	для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с "1 января 1970 года UTC+0".
		
		getTimezoneOffset()	-	возвращает разницу в минутах между местным часовым поясом и "UTC".
	
	Установка (опциональные параметры, которые не будут переданы, останутся неизменными):
	
		setFullYear(<год>, <месяц (опционально)>, <день (опционально)>)	-	установить год (остальное опционально).
		
		setMonth(<месяц>, <день (опционально)>)	-	установить месяц (остальное опционально).

		setDate(<день>)	-	установить день.

		setHours(<часы>, <минуты (опционально)>, <секунды (опционально)>, <миллисекунды (опционально)>)	-	установить часы (остальное опционально).

		setMinutes(<минуты>, <секунды (опционально)>, <миллисекунды (опционально)>)	-	установить минуты (остальное опционально).

		setSeconds(<секунды>, <миллисекунды (опционально)>)	-	установить секунды (остальное опционально).

		setMilliseconds(<миллисекунды>)	-	установить миллисекунды.

		setTime(<миллисекунды>)	-	устанавливает дату в виде целого количества миллисекунд, прошедших с "01.01.1970 UTC".
		
		toLocaleString([<локали>, [<опции (опционально)>] (опционально)])	-	подробнее в главе 'Интернационализация ("Intl")',
		в подглаве 'Методы в объектах "Date", "String", "Number"'.
		
		toLocaleDateString([<локали>, [<опции (опционально)>] (опционально)])	-	подробнее в главе 'Интернационализация ("Intl")',
		в подглаве 'Методы в объектах "Date", "String", "Number"'.
		
		toLocaleTimeString([<локали>, [<опции (опционально)>] (опционально)])	-	подробнее в главе 'Интернационализация ("Intl")',
		в подглаве 'Методы в объектах "Date", "String", "Number"'.
		
Пример установки даты/времени:

	let today = new Date();

	today.setHours(0);
	alert(today);	//	выводится сегодняшняя дата, но значение часа будет "0".

	today.setHours(0, 0, 0, 0);
	alert(today);	//	всё ещё выводится сегодняшняя дата, но время будет ровно "00:00:00".
	
• Автоисправление даты. Если при установке даты указать большее значение (например месяца), то оно автоматически будет перекинуто/распределено на
остальные значения (например год).

Если объект "Date" преобразовать в число, то получим таймстамп по аналогии с "date.getTime()":

	let date = new Date();
	alert(+date);	//	количество миллисекунд, то же самое, что "date.getTime()".
	
Подсчет разности времени:

	let start = new Date();	//	начинаем отсчёт времени.
	
	//	выполняем некоторые действия...
	
	let end = new Date(); // заканчиваем отсчёт времени.
	
	console.log(end - start);	//	49732
	
• Методы объекта "Date":

	now()	-	получение текущей метки времени (миллисекунды). Пример:
	
		console.log( Date.now() );	//	1587424408820
		
	parse(<строка>)	-	данный метод считывает дату из строки. Формат строки должен быть следующим - "YYYY-MM-DDTHH:mm:ss.sssZ", где:
	
		YYYY-MM-DD	-	год-месяц-день.
		
		"T"	-	используется в качестве разделителя.
		
		HH:mm:ss.sss	-	время: часы, минуты, секунды и миллисекунды.
		
		'Z'	-	необязательная часть, обозначает часовой пояс в формате "+-hh:mm". Если указать просто букву "Z", то получим "UTC+0".
		
		Все составляющие кроме "YYYY" являются опциональными.
		
		Пример:
		
			let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

			alert(ms);	//	"1327611110417" (таймстамп).

	

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Объект "JSON" ("JavaScript Object Notation)". Формат "JSON" оборачивает все строки в двойные кавычки, а так же имена свойств.
"JSON" поддерживает простые объекты, массивы, строки, числа, логические значения и "null".

	Методы объекта "JSON":
	
		stringify(<целевой объект>, <массив свойств или функция соответствия "function (<ключ>, <значение>)" (опционально)>, <количество пробелов, используемых для форматирования (опционально)>)
		-	метод,  для преобразования объекта в "JSON" формат.
		В данном методе, второй (опциональный) параметр принимает либо массив имен свойств, которые будут выбраны для преобразования, либо функция,
		которая принимает пары "ключ-значение",	и которая должна вернуть замененное	имя свойства, либо "undefined" - чтобы пропустить свойство. При первом вызове данной функции,
		ей передаётся специальный "объект-обёртка": '{"": <исходный объект>}'. Другими словами, первая "(<key>, <value>)" пара имеет пустой ключ, а значением является целевой объект.
		Значение "this" внутри фунции – это объект, который содержит текущее свойство.
		Третий (опциональный) параметр используется для оформления "JSON". В нем указывается количество пробелов в
		цифрах для отступов. Метод "stringify" пропускает циклические ссылки (объект содержащий объект из-вне), методы объектов,
		символьные свойства и свойства со значениями "undefined". Примеры использования метода "stringify":
		
			Пример с указанием массива имен выбираемых свойств:

				let meetup = {
					title: "Conference",
					participants: [{name: "John"}, {name: "Alice"}],
				};

				alert( JSON.stringify(meetup, ['title', 'participants']) );	//	{"title":"Conference","participants":[{},{}]}
				
			Пример с фукцией для замены имен свойств:
			
				alert( JSON.stringify(meetup, function replacer(key, value) {
					alert(`${key}: ${value}`);
					return (key == 'occupiedBy') ? undefined : value;
				}));
				
			Пример с указанием пробелов:
			
				let user = {
					name: "John",
					age: 25,
				};

				alert(JSON.stringify(user, null, 2));	//	отступ в 2 пробела.
		
		parse(<целевой "JSON" объект>, <функция соответствия "function (<ключ>, <значение>)" (опционально)>)	-	метод,  для преобразования "JSON" в объект. В данном методе,
		второй (опциональный) параметр принимает функцию, которая принимает пары "ключ-значение", и которая должна вернуть модифицированное значение,
		либо "undefined" - чтобы пропустить значение.
		Пример:
		
			let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

			let meetup = JSON.parse(str, function(key, value) {
				if (key == 'date') return new Date(value);
				return value;
			});

			alert( meetup.date.getDate() );	//	30
		
• У объектов есть встроенный метод "toJSON()", который позволяет перехватить преобразование объекта в "JSON" (вызов метода "stringify" у "JSON" для объекта)
подробнее в главе "Преобразование типов".

! Примечание. "JSON" не поддерживает комментарии.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Остаточные параметры и оператор расширения ("Rest" и "Spread").

• Оператор "Rest" собирает "оставшиеся" аргументы/параметры в массив. Он выполняется, при получении (приеме) параметров/аргументов. Указывается он через троеточие "...".
В следующем примере оператор "Rest" с именем "allArgs" собирает в себя все передаваемые функции параметры, и суммирует их:

	function sumAll(text, ...allArgs) {
		console.log(text);
		let sum = 0;
		for (let arg of allArgs) sum += arg;
		return sum;
	}
	
	sumAll("Hello", 1, 4, 1, 4, 5, 6);

Остаточные параметры должны располагаться в конце.

• Оператор расширения (разворота) "Spread" разворачивает перебираемый объект в аргументы. Он выполняется, при передаче (отправлении) перебираемого объекта.
Указывается он так же через троеточие "...". В следующем примере оператор "Spread" с именем "arr" разворачивает массив:

	let arr = [3, 5, 1];
	let arr2 = [8, 9, 15];
	let merged = [0, ...arr, 2, ...arr2];
	
	console.log(merged);	//	0,3,5,1,2,8,9,15
	
Оператор "Spread" работает так же и со строками, так как они являются перебираемыми объектами:

	let str = "Привет";

	console.log( [...str] );	//	П,р,и,в,е,т

Пример разворачивания объекта:

	let a = {q: 1, w: 2};
	
	let b = {e: 5, r: 21};
	
	let c = {...a, ...b};
	
	c.q;	//	1
	c.r;	//	21

Однако если попытаться объеденить в функции, то результат будет не ожидаемым:

	let a = {q: 1, w: 2};
	
	let b = {e: 3, t: 12}
	
	function fn (...obs) {
		return {...obs};
	}
	
	let c = fn (a,b);	//	{0: {q: 1, w: 2}, 1: {e: 3, t: 12}}
	
	Это произойдет по причине того, что при использовании "Rest" в функции, она собирает получаемые параметры в массив. А дальше идет распаковка массива в объект,
	элементы которого затем будут под теми индексами, под которыми они были когда были в массиве.

• Разница операторов "Rest" и "Spread" в том, где и как их использовать: "Rest" - при приеме параметров, "Spread"  - при передаче параметров.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Прототипы, наследование.

• Прототипное наследование. Объекты имеют специальное скрытое свойство "[[Prototype]]", которое либо равно "null", либо ссылается на другой объект.
Этот объект, на который ссылаются, называется "прототип". Объект не может наследоваться от двух других объектов.

• Прототипом объекта может являться только объект или "null".

Способы задать прототип объекту:

	1. Через свойство "__proto__". В объектах есть свойство "__proto__", и оно всегда указывает на объект.
	Свойство "__proto__" является геттером и сеттером для "[[Prototype]]". Свойство "__proto__" не может идти по кругу.
	Пример указания прототипа объекту:
	
		let animal = {
			eats: true
		};
		let rabbit = {
			jumps: true
		};

		rabbit.__proto__ = animal;	// свойство "__proto__" так же можно было указать в самом литерале объекта.
		
	Операция записи не использует прототип, кроме геттеров и сеттеров:
	
		let user = {
			name: "John",
			surname: "Smith",

			set fullName(value) {
				[this.name, this.surname] = value.split(" ");
			},

			get fullName() {
				return `${this.name} ${this.surname}`;
			}
		};

		let admin = {
			__proto__: user,
			isAdmin: true
		};

		alert(admin.fullName);	//	John Smith

		// срабатывает сеттер!
		admin.fullName = "Alice Cooper";
		alert(admin.name);	//	Alice
		alert(admin.surname);	//	Cooper
		
	Так же касается и оператора "delete":
	
		let user = {
			name: "John",
			surname: "Smith",

		};

		let admin = {
			__proto__: user,
			isAdmin: true
		};
		
		delete admin.name;	//	ничего не произойдет.

	2. Через свойство "prototype" у функции-конструктора. Если у функции-конструктора, в свойстве "prototype" содержится объект,
	оператор "new" устанавливает его в качестве "[[Prototype]]" для нового объекта. Присвоенное значение свойству "prototype" у
	функции-конструктора сработает только при его вызове с "new". Для самой функции-конструктора, "prototype" является всего лишь свойством,
	указывающий/содержащий объект, который затем станет прототипом для новосозданного объекта. Пример указания прототипа объекту из функции-конструктора:
	
		let animal = {
			eats: true
		};

		function Rabbit(name) {
			this.name = name;
		}

		Rabbit.prototype = animal;

		let rabbit = new Rabbit("White Rabbit");	// 	"rabbit.__proto__ == animal".

		alert( rabbit.eats );	//	true

	• "prototype" по умолчанию и свойство "constructor". У каждой функции по умолчанию уже есть свойство "prototype".
	По умолчанию "prototype" это объект с единственным свойством "constructor", которое ссылается обратно на функцию-конструктор:
	
		function Rabbit() {}

		console.log( Rabbit.prototype.constructor == Rabbit );	//	true

	Можно использовать свойство "constructor" существующего объекта для создания нового объекта:
	
		function Rabbit(name) {
			this.name = name;
			alert(name);
		}

		let rabbit = new Rabbit("White Rabbit");

		let rabbit2 = new rabbit.constructor("Black Rabbit");

	• У обычных объектов нет свойства "prototype", вместо этого - "__proto__".
	
	3. Через методы главного объекта "Object". Список методов:
	
		create(<цель-прото>, <дескрипторы (опционально)>) – создаёт пустой объект, "[[Prototype]]" которого будет "<цель-прото>",
		и необязательными дескрипторами свойств. Пример:

			let animal = {
			  eats: true
			};

			//	создаём новый объект "rabbit" с прототипом "animal", и дескрипторами.
			let rabbit = Object.create(animal, {
				jumps: {
					value: true
				}
			});

		getPrototypeOf(<целевой объект>) – возвращает свойство "[[Prototype]]" указанного целевого объекта.

		setPrototypeOf(<целевой объект>, <цель-прото>) – устанавливает свойство "[[Prototype]]" объекта "<целевой объект>" как "<цель прото>".
		Пример:
		
			Object.setPrototypeOf(rabbit, {});

• При вызове метода у объекта, "this" всегда объект перед точкой (".").

• Цикл "for ... in ..." проходит не только по собственным, но и по унаследованным свойствам объекта:

	let animal = {
		eats: true
	};

	let rabbit = {
		jumps: true,
		__proto__: animal
	};

	//	"Object.keys" возвращает только собственные ключи.
	console.log(Object.keys(rabbit));	//	jumps

	//	"for ... in ..." проходит и по своим, и по унаследованным ключам:
	for(let prop in rabbit) alert(prop);	//	"jumps", затем "eats".

Объекты имеют метод "hasOwnProperty(<имя проверяемого свойства>)", которое проверяет, содердит ли объект указанное свойство,
и возвращает соответствующее булевое значение:

	obj.hasOwnProperty("name");

• Чтобы проверить, является ли один объект прототипом другого объекта, существует метод "isPrototypeOf(<объект>)":

	animal.prototype.isPrototypeOf(rabbit);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Классы.
Класс – это разновидность функции ("typeof" класса это функция).
Имя класса принято писать с большой буквы.

Виды синтаксисов объявления классов:

	"Class Declaration":

		class <имя класса> {...}

	"Class Expression":
	
		let <имя класса> class {...}

Синтаксис создания класса на примере "Class Decaration":

	class <имя класса> {
	
		<свойство> = <значение>;
	
		constructor(<аргументы>) {...}
	
		<метод>(<аргументы>) {...}
	
		get something(<аргументы>) {...}
	
		set something(<аргументы>) {...}
	
		[Symbol.iterator]() {...}
	
		...
	}

	let new <имя объекта> = new <имя класса>;

Пример создания класса и объекта от него:

	class User {

		constructor(name) {
			this.name = name;
		}
		sayHi() {
			alert(this.name);
		}
	}

	//	Использование:
	let user = new User("Иван");
	user.sayHi();

Синтаксис классов отличается от литералов объектов - методы в классе не разделяются запятой.
Значения свойств (обычных свойств, не статичных) ставятся не после двоеточия (":") как в литерале объекта, а через равно "=" (потому что классы это по сути функции).
Эти свойства (обычные, не статичные) будут непосредственно у новосозданного объекта, а не у его прототипа (через оператор "new"), или конструктора:

	class User {
		name = "Аноним";
	}

Аргументы передающиеся в скобки класса попадают в конструктор класса.
Методы указанные в классе, после создания объекта (после "new"), приписываются прототипу новосозданного объекта.
Методы класса являются неперечисляемыми.
Классы всегда используют "'use strict'".

Аналогично "Named Function Expression", "Class Expression" может иметь имя:

	let User = class MyClass {...}

Пример создания простого наследования с помощью функции, без использования классов:

	function object(o) {
		function F(){}
		F.prototype = o;	// переданный параметр "o" становится прототипом для конструктора "F".
		return new F();		// при вызове "F" с "new" возвращается новый объект, прототип которого стал переданный параметр "o".
	}
	
	let parent = {a: 1};
	let child = object(parent);
	
	child.a;	//	1

• Наследование классов.
Чтобы унаследовать один класс от другого,необходимо указать ключевое слово "extends" вместе с именем наследуемого класса после объявления нового класса.
Само тело нового класса ставится после имени наследуемого класса:

	class Animal {...}
	
	class Rabbit extends Animal {...}	//	Класс "Rabbit" наследуется от класса "Animal".

После "extends" разрешены любые выражения:

	function f(phrase) {...}	// Функция, которая возвращает класс.

	class User extends f("Привет") {...}
	
	Примечание, вызов функции в таком случае должен быть с фигурными скобками.
	
• Переопределение методов и конструкторов.
У классов и объектов есть ключевое слово "super" для вызова родительского метода или конструктора:

	super.<родительский метод>()	-	вызывает родительский метод.
	
	super(<входные параметры (опционально)>)	-	вызывает родительский конструктор (работает только внутри текущего конструктора).
	
У функциий есть внутреннее специальное свойство "[[HomeObject]]". Когда функция объявлена как метод внутри класса или объекта, её свойство "[[HomeObject]]"
становится равно этому объекту. Затем "super" использует его, чтобы получить прототип родителя и его методы. Единственный случай,
когда используется "[[HomeObject]]" – это "super".

Пример использования ключевого слова "super":

	class Animal {
		...
		stop() {...}
	}
	class Rabbit extends Animal {
		stop() {
			super.stop();	//	вызываем родительский метод "stop".
			this.hide();	//	затем "hide".
		}
	}

Если в подклассе определен конcтруктор, то этот конструктор должен вызвать конструктор класса родителя. Если конструктор класса родителя принимает
входные параметры, то эти же параметры так должны быть указаны и во входных параметрах конструктора подкласса, а так же в контейнере конструктора
через "super()". Так же с помощью "super()" можно вызвать метод родительского класса. Пример:

	class Task {
		constructor (title) {
			this.title = title;
			this.done = false;
		}
		complete () {
			this.done = true;
			console.log(`Задача "${this.title}" выполнена`);
		}
	}

	class SubTask extends Task {
		constructor (title) {
			super(title);
		}
		complete () {
			super.complete();
			console.log(`Подзадача "${this.title}" выполнена`);
		}
	}

	let task = new Task("Главная задача");
	let subTask = new SubTask("Подзадача");

Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся "пустой" конструктор с методом "super":

	class Rabbit extends Animal {
		// генерируется для классов-потомков, у которых нет своего конструктора.
		constructor(...args) {
			super(...args);
		}
	}

• Свойство "[[HomeObject]]" определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как "<метод>()",
а не "<метод>: function()".
В приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет "[[HomeObject]]", и наследование не работает:

	let animal = {
		eat: function() { // намеренно пишем так, а не eat() { ...
	  }
	};

	let rabbit = {
		__proto__: animal,
		eat: function() {
			super.eat();
		}
	};

	rabbit.eat();	//	Ошибка вызова "super" (потому что нет "[[HomeObject]]").

• Переопределение конструктора. Когда запускается конструктор унаследованного класса, он не создает пустой объект и не присваивает его "this" (как это делает обычный конструктор),
а вместо этого он ожидает что это сделает конструктор родительского класса. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством
'[[ConstructorKind]]:"derived"'.
При создании собственного конструктора, надо вызвать "super", в противном случае объект для "this" не будет создан:

	class Animal {
		constructor(name) {
			this.speed = 0;
			this.name = name;
		}
	}
	
	lass Rabbit extends Animal {
		constructor(name, earLength) {
			super(name);
			this.earLength = earLength;
		}
	}
	
• У стрелочных функций нет "super". При обращении к "super" стрелочной функции он берётся из внешней обычной функции:

	class Rabbit extends Animal {
		stop() {
			setTimeout(() => super.stop(), 1000);	//	вызывает родительский "stop" после 1 секунды.
		}
	}

• Статические свойства и методы.
Статические свойства и методы используются для реализации функций принадлежащих самому классу, а не его потомкам.
Статические свойства и методы доступны только у самого класса.
Чтобы создать статическое свойство или метод, нужно указать ключевой слово "static" перед свойством/методом.
Значение "this" при вызове статического метода класса - это сам текущий класс.

Пример создания статического метода у класса:

	class Article {
		constructor(title, date) {
			this.title = title;
			this.date = date;
		}

		static createTodays() {
			return new this("Сегодняшний дайджест", new Date());	// "this" == "Atricle".
		}
	}

	let article = Article.createTodays();

	console.log( article.title );	//	"Сегодняшний дайджест".

Статические свойства являются нововведением, и могут быть не поддерживаться во всех средах.
Пример создания статического свойства у класса:

	class Article {
		static publisher = "Илья Кантор";	//	Свойства в классах объявляются через знак равно "=", а не двоеточие ":".
	}

	console.log( Article.publisher ); // "Илья Кантор".

Статические свойства и методы наследуются (через "extends").

• Приватные свойства. Чтобы создать приватное свойство в классе, нужно перед именем свойства использовать символ решетки "#":

	class CoffeeMachine {
		#waterLimit = 200;
	}

	let coffeeMachine = new CoffeeMachine();
	
	coffeeMachine.#checkWater;	//	Ошибка.

Если класс наследуется от другого класса, у которого есть приватное свойство, но наследуемый касс не будет иметь доступа к этому приватному свойству.
Примечание ! Возможность приватных свойств через "#" была добавлена в язык недавно. В движках "JavaScript" эта возможность пока не поддерживается или поддерживается частично.
Необходим полифил.

• Расширение встроенных классов.

• При расширении класса другим классом, новые объекты будут такого же типа, что и класс, от которого идет расширение нового класса. Даже новые объекты, которые будут возвращаться при
применении встроенных методов от класса, от которого идет расширение нового класса, будут такого же типа. Пример:

	// добавим один метод (можно более одного).
	class PowerArray extends Array {
	  isEmpty() {
		return this.length === 0;
	  }
	}

	let arr = new PowerArray(1, 2, 5, 10, 50);
	
	Object.prototype.toString.call(arr);	//	"[object Array]", а не "[object Object]".
	
	alert(arr.isEmpty()); // false

	let filteredArr = arr.filter(item => item >= 10);
	
	Object.prototype.toString.call(filteredArr);	//	"[object Array]", а не "[object Object]".
	
	alert(filteredArr); // 10, 50
	
	alert(filteredArr.isEmpty()); // false

Встроенные методы, такие как "filter", "map" и другие возвращают новые объекты унаследованного класса "PowerArray". Их внутренняя реализация такова, что для этого они
используют свойство "constructor". При вызове метода "arr.filter()", он внутри создаёт массив результатов, именно используя "arr.constructor", а не обычный массив.
Можно продолжать использовать методы "PowerArray" далее на результатах. Можно настроить это поведение при помощи символа "Symbol.species", который должен быть указан
в качестве специального статического геттера. Этот статический геттер должен вернуть конструктор, который будет использован в качестве конструктора для новых объектов,
которые будут создаваться уже втроенными методами. (подробнее "https://learn.javascript.ru/extend-natives"). Пример:

Пример переопределения конструктора для методов "map", "fiter" у массивов:

	class PowerArray extends Array {
		isEmpty() {
			return this.length === 0;
		}

		//	встроенные методы массива будут использовать этот метод как конструктор.
		static get [Symbol.species]() {
			return Array;
		}
	}

	let arr = new PowerArray(1, 2, 5, 10, 50);
	alert(arr.isEmpty());	//	false

	//	"filter" создаст новый массив, используя "arr.constructor[Symbol.species]" как конструктор.
	let filteredArr = arr.filter(item => item >= 10);

	//	"filteredArr" не является "PowerArray", это "Array".
	alert(filteredArr.isEmpty());	//	Error: filteredArr.isEmpty is not a function

Теперь метод "filter" возвращает "Array". Расширенная функциональность не будет передаваться далее.

Другими словами, то что возвращает "[Symbol.species]", будет установлено в качестве конструктора для создания новых объектов.
Другие коллекции, такие как "Map", "Set", работают аналогично. Они также используют "[Symbol.species]".

• Проверка класса.
Чтобы проверить, является ли класс конструктором у новосозданного объекта, есть оператор "instanceof":

	class Rabbit {}
	let rabbit = new Rabbit();

	alert( rabbit instanceof Rabbit );	//	true

Также это работает с функциями-конструкторами, и для встроенных классов, таких как "Array":

	function Rabbit() {}
	alert( new Rabbit() instanceof Rabbit );	//	true
	
	let arr = [1, 2, 3];
	alert( arr instanceof Array );	//	true
	alert( arr instanceof Object );	//	true

• Чтобы изменить поведение оператора "instanceof", можно использовать статический ("static") метод "[Symbol.hasInstance]". "[Symbol.hasInstance]" - это известный символ,
который используется как статический метод для определения является ли объект экземпляром конструктора. Перед методом соответственно ставится ключевое слово "static".
Если имеется статический метод "[Symbol.hasInstance]" у класса, то при использовании оператора "instanceof" он будет вызываться.
Статический метод "[Symbol.hasInstance]" должен вернуть либо "true", либо "false". Этот метод принимает в качестве аргумента проверяемый объект.
Пример использования статического метода "[Symbol.hasInstance]":

	//	проверка "instanceof" будет полагать, что всё со свойством "canEat" - животное "Animal".
	class Animal {
		static [Symbol.hasInstance](obj) {
			if (obj.canEat) return true;
		}
	}

	let obj = { canEat: true };
	alert(obj instanceof Animal);	//	"true": вызван "Animal[Symbol.hasInstance](obj)".

Если у класса нет статического метода "[Symbol.hasInstance]", то оператор "instanceof" будет проверять равен ли "Class.prototype" одному из прототипов в прототипной цепочке "obj".

Так же для проверки наследования прототипов, у объектов есть метод "isPrototypeOf(<объект>)":

	objA.isPrototypeOf(objB);

• В ES6 всплытие классов не происходит (как например функции).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Обработка ошибок "try/catch/finally".

Вид синтаксиса "try/catch/finally":

	try {
		<тело блока>
	} catch(<объект ошибки>) {
		<тело блока>
	} finally {
		<тело блока>
	}
	
Можно использовать "try" как с обеими "catch" и "finally", так и только с одним из них. Нельзя использовать "try" без "catch" или "finally".

Блок "catch" может принимать объект ошибки, который содержит следующие свойства:

	name	-	имя ошибки (например "ReferenceError").
	
	message	-	текстовое сообщение о деталях ошибки.
	
	stack	-	стек на момент ошибки.
	
В блоке "catch" можно обойтись без скобок, но эта возможность новая, и может не поддерживаться во всех средах.

Блок "finally" является опциональным, и выполняется в любом случае (были ошибки или нет), и даже при "return".

• Генерация собственных ошибок.
Чтобы сгенерировать собственную ошибку, нужно использовать оператор "throw". Синтаксис оператора "throw":

	throw <объект ошибки>;
	
	На месте "<объект ошибки>" может что угодно (примитив, объект и т.д.), но желательно чтобы был объект со свойствами "name", и "message".

Чтобы создать специальный объект ошибки, в "JavaScript" есть множество встроенных конструкторов для стандартных ошибок: "Error", "SyntaxError", "ReferenceError", "TypeError"
и другие. Синтаксис конструкторов ошибок:

	let <переменная объекта ошибки> = new Error(<сообщение ошибки ("message")>);
	
	let <переменная объекта ошибки> = new SyntaxError(<сообщение ошибки ("message")>);
	
	let <переменная объекта ошибки> = new ReferenceError(<сообщение ошибки ("message")>);

Для встроенных ошибок, свойство "name" – это в точности имя конструктора. А свойство "message" берётся из аргумента.

"try/catch/finally" работает синхронно. Переменные внутри "try/catch/finally" локальны.

• Глобальный "catch". У объекта "Window" есть свободное (пустое) свойство "onerror", которое может быть использовано для присваивания функции, для обработки глобальных ошибок.
Синтаксис глобального обработчика ошибки:

	window.onerror = function(<сообщение>, <"url" адрес>, <номер строки ошибки>, <номер столбца ошибки>, <объект ошибки>) {
	  <тело функции>
	};

Роль глобального обработчика "window.onerror" обычно заключается не в восстановлении выполнения скрипта – это скорее всего невозможно в случае программной ошибки,
а в отправке сообщение об ошибке разработчикам.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Промисы.

Синтаксис создания промиса:

	let promise = new Promise(function(resolve, reject) {<тело функции исполнителя (executor)>});

Функция, переданная в конструкцию "new Promise", называется исполнитель "executor". Её аргументы "resolve" и "reject" – это колбэки, которые предоставляет сам JavaScript:

	resolve(<value>)	-	если работа завершилась успешно, с результатом "value".

	reject(<error>)	-	если произошла ошибка, "error" – объект ошибки.

У объекта промис, возвращаемого конструктором "new Promise", есть внутренние (скрытые) свойства:

	state	-	("состояние") вначале "pending" ("ожидание"), потом меняется на "fulfilled" ("выполнено успешно") при вызове "resolve" или
	на "rejected" ("выполнено с ошибкой") при вызове "reject.
	
	result	-	("результат") вначале "undefined", далее изменяется на "value" при вызове "resolve(<value>)" или на "error" при вызове "reject(<error>)".

Пример конструктора "Promise" и простого исполнителя с кодом, дающим результат с задержкой (через "setTimeout"):

	let promise = new Promise(function(resolve, reject) {
		//	эта функция выполнится автоматически, при вызове "new Promise".

		//	через 1 секунду сигнализировать, что задача выполнена с результатом "done".
		setTimeout(() => resolve("done"), 1000);
	});

Пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

	let promise = new Promise(function(resolve, reject) {
		//	спустя одну секунду будет сообщено, что задача выполнена с ошибкой.
		setTimeout(() => reject(new Error("Whoops!")), 1000);
	});

Исполнитель должен вызвать что-то одно: "resolve" или "reject". Состояние промиса может быть изменено только один раз.

• Методы-потребители: "then", "catch", "finally":

	"then(<функция для "resolve">, <функция для "reject" (опционально)>)"	-	метод у промиса, который вызывается при завершении промиса (выполнен или отклонен).
	"<функция для "resolve">" выполнится когда промис выполнился успешно, и получает как аргумент результат выполнения промиса.
	"<функция для "reject">" выполнится когда промис будет выполнен с ошибкой (получит ошибку), и получает как аргумент ошибку выполнения промиса.
	Сам метод "then" так же возвращает промис (все что возвращает "then", будет обернуто в промис), так что можно вызывать методы-потребители по цепочке.
	
	Пример с успешным выполнением промиса:
	
		let promise = new Promise(function(resolve, reject) {
			setTimeout(() => resolve("done!"), 1000);
		});

		//	"resolve" запустит первую функцию, переданную в "then"".
		promise.then(
			result => alert(result),	//	выведет "done!" через одну секунду.
			error => alert(error)	//	не будет запущена.
		);
	
	Если необходимо обработать только ошибку, то в качестве первого аргумента можно передать "null", или же использовать другой метод - "catch".
	
	"catch(<функция для "reject">)"	-	метод у промиса, который вызывается при неуспешном выполнении промиса (с ошибкой). "<функция для "reject">" выполнится когда промис
	будет выполнен с ошибкой (получит ошибку), и получает как аргумент ошибку выполнения промиса.
	Сам метод "catch" так же возвращает промис, так что можно вызывать методы-потребители по цепочке.
	
	Пример с неуспешным выполнением промиса:
	
		let promise = new Promise((resolve, reject) => {
			setTimeout(() => reject(new Error("Ошибка!")), 1000);
		});

		promise.catch(alert);	//	выведет "Error: Ошибка!" спустя одну секунду.
	
	"finally(<функция по умолчанию>)"	-	метод у промиса, который вызывается при любом исходе завершения помиса (с ошибкой или без). Функция принимаемая "finally" не имеет
	аргументов. Сам метод "finally" так же возвращает промис, так что можно вызывать методы-потребители по цепочке.
	
	Пример с методом "finally":
	
		new Promise((resolve, reject) => {
			setTimeout(() => resolve("result"), 2000)
		})
			.finally(() => alert("Промис завершён"))
			.then(result => alert(result));	//	"then" обработает результат.
			
	В примере выше обработчик "finally" "пропускает" результат или ошибку дальше, к последующим обработчикам.
	
	Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий "then".

Можно вручную вернуть новый промис из метода "then", тогда дальнейшая цепочка методов-потребителей будет уже у нового промиса.

• Обработчик промисов может возвращать не только объекты-промисы, но и любые объекты, содержащие метод "then". Такие объекты называют "thenable".
"JavaScript" проверяет объект, возвращаемый из обработчика "then" - если у него имеется метод "then", который можно вызвать, то этот метод вызывается,
и в него передаются как аргументы встроенные функции "resolve" и "reject", вызов одной из которых затем ожидается.

• Вокруг функции промиса и обработчиков находится невидимый "try"/"catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.
Если внутри промиса происходит стандартная асинхронная ошибка (без "reject"), то метод "catch" его не поймает и соответственно не сможет обработать.

• Статические методы объекта "Promise":

	all([<массив промисов или перебираемый объект>])	-	принимает массив промисов (может принимать любой перебираемый объект,
	но обычно используется массив) и возвращает новый промис. Новый промис завершится, когда удачно завершится весь переданный список промисов,
	и его результатом будет массив их результатов. Пример:
	
		Promise.all([
			new Promise(resolve => setTimeout(() => resolve(1), 3000)),	//	1
			new Promise(resolve => setTimeout(() => resolve(2), 2000)),	//	2
			new Promise(resolve => setTimeout(() => resolve(3), 1000)) 	//	3
		]).then(alert);	//	результатом будет массив "[1, 2, 3]".
		
	Если один промис завершается с ошибкой, то весь "Promise.all" завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.
	Если любой из перебираемых объектов передающийся в массив аргументов "Promise.all" не является промисом, он передаётся в итоговый массив как есть.
	
	allSettled([<массив промисов или перебираемый объект>])	-	принимает массив промисов (может принимать любой перебираемый объект,
	но обычно используется массив) и возвращает новый промис. Новый промис завершится, когда завершится (при любом исходе) весь переданный список промисов,
	и его результатом будет массив их результатов. Метод "Promise.allSettled" всегда ждёт завершения всех промисов.
	В массиве результатов будет:

		{status:"fulfilled", value:<результат>}	-	для успешных завершений.
		
		{status:"rejected", reason:<ошибка>}	-	для ошибок.
	
	Данный метод является новым и может не поддерживаться во всех средах.
	
	race([<массив промисов или перебираемый объект>])	-	принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив)
	и возвращает новый промис. Новый промис завершится, когда завершится (при любом исходе) первый выполнившийся промис (самый быстрый),
	и его результатом будет результат промиса. Пример:
	
		Promise.race([
			new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
			new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
			new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
		]).then(alert);	//	1
	
	resolve(<значение>)	-	 создаёт успешно выполненный промис с результатом "<значение>" так. Данный метод делает то же самое что и:
	
		new Promise(resolve => resolve(<значение>));
	
	На практике этот метод почти никогда не используется.
	
	reject(<объект ошибки>)	-	создаёт неудачно выполненный промис с результатом "<объект ошибкм>" так. Данный метод делает то же самое что и:
	
		new Promise((resolve, reject) => reject(<объект ошибки>));
	
	На практике этот метод почти никогда не используется.

• Все действия промисов проходят через внутреннюю очередь "promise jobs", так называемую "очередь микрозадач". Таким образом, обработчики "then"/"catch"/"finally" вызываются
после выполнения текущего кода.

• "Async"/"Await".

Оператор "Async" ставится перед функцией и всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически. Пример:

	async function f() {	//	Эта функция возвратит выполненный промис с результатом "1".
		return 1;
	}

	f().then(alert);	//	1

Есть большая особенность работы оператора "async" с генераторами. Подробнее в главе "Генераторы" (в подглаве "Асинхронные генераторы").

Оператор "Await" остановит выполнение кода, и заставит интерпретатор "JavaScript" ждать до тех пор, пока промис справа от "await" не выполнится удачно.
Оператор "Await" ожидает разрешения промиса и возвращает полученное значение.
Чтобы продолжить выполнение остального кода, не имеющего отношения к этому, нужно обернуть работу с промисом в функцию и поставить перед ней оператор "Async".
Пример:

	async function f() {

		let promise = new Promise((resolve, reject) => {
			setTimeout(() => resolve("готово!"), 1000)
		});

		let result = await promise;	//	Будет ждать, пока промис не выполнится.

		console.log(result);	//	"готово!".
	}

	f();

Оператор "Await" нельзя использовать в обычных функциях (в функциях без "Async").
Оператор "Await" позволяет работать с промис–совместимыми объектами (объекты с методом "then" ("thenable")). Идея в том, что если у объекта можно вызвать метод "then", этого достаточно,
чтобы использовать его с "await". Когда "await" получает объект с "then", не являющийся промисом, "JavaScript" автоматически запускает этот метод, передавая ему аргументы – 
встроенные функции "resolve" и "reject". Затем "await" приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана.

Для объявления асинхронного метода достаточно написать "async" перед именем:

	let obj = {
		async wait() {
			return await Promise.resolve("test");
		}
	}

• Обрабтка ошибок с помощью  "try/catch/finally":

	async function f() {

		try {
			let response = await fetch('/no-user-here');
			let user = await response.json();
		} catch(err) {
			//	перехватит любую ошибку в блоке "try": и в "fetch", и в "response.json".
			console.log(err);
		}
	}

	f();

Если у нас нет "try"/"catch", асинхронная функция будет возвращать завершившийся с ошибкой промис (в состоянии "rejected").
В этом случае мы можем использовать метод "catch" промиса, чтобы обработать ошибку:

	async function f() {
		let response = await fetch('http://no-such-url');
	}

	//	"f()" вернёт промис в состоянии "rejected".
	f().catch(alert);	//	TypeError: failed to fetch

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Генераторы.

Генераторы это функции, которые вызываются итеративно.

Для создания генератора, нужно сначала создать функцию-генератор. Для создания функции-генератора нужно после ключевого слова "function" добавить символ звездочки "*".
После создания функции-генератора, нужно создать сам генератор. Пример синтаксиса создания генератора методом "Function Decaration":

	function* <имя функции-генератора>(){
		yield <возвращаемое значение>
	}
	
	let <имя генератора> = <имя функции-генератора>();

Пример создания генератора методом "Function Decaration":

	function* generateSequence() {	//	Функция генератор.
		yield 1;
		yield 2;
		yield 3;
	}
	
	let generator = generateSequence();	//	Генератор.

Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый
"генератор", для управления её выполнением.
Основным методом генератора является "next()". При вызове он запускает выполнение кода до ближайшей инструкции "yield <значение>" (значение может отсутствовать,
в этом случае оно предполагается равным "undefined"). По достижении "yield" выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код.
Результатом метода "next()" всегда является объект с двумя свойствами:

	value	-	значение из "yield".

	done	-	"true", если выполнение функции завершено, иначе "false".

Пример получения значений из генератора:

	function* generateSequence() {
		yield 1;
		yield 2;
		yield 3;
	}

	let generator = generateSequence();

	let one = generator.next().value;	//	1
	
	Повторный вызов "generator.next()" возобновит выполнение кода и вернёт результат следующего "yield".

• Генераторы являются перебираемыми объектами, так как они возвращают объект с методом "next()", который в свою очередь возвращает объект со свойствами "value" и "done". Это
значит что генераторы могут перебираться в цикле "for ... of ...":

	for(let value of generator) {
		console.log(value);
	}

Так как генераторы являются перебираемыми объектами, то можно использовать их в операторе расширения "Spread" ("..."):

	let sequence = [0, ...generateSequence()];

Можно превратить обычный объект в перебираемый, превратив пользовательский метод "[Symbol.iterator]" в метод-генератор, добавив перед ним звездочку ("*"):

	let range = {

		*[Symbol.iterator]() {	//	краткая запись для "[Symbol.iterator]: function*()".
			yield 1;
			yield 2;
			yield 5;
			yield 0;
	  }
	};

	console.log( ...range ); // 1, 2, 5, 0

• Композиция генераторов.
Если после директивы "yield" будет сторять звездочка ("*"), и после будет вызов другого генератора, то "yield*" будет делегировать выполнение текущего генератора указанному
генератору:

	function* generateSequence(start, end) {
		for (let i = start; i <= end; i++) yield i;
	}

	function* generatePasswordCodes() {

		yield* generateSequence(48, 57);	//	0..9

		yield* generateSequence(65, 90);	//	A..Z

		yield* generateSequence(97, 122);	//	a..z
	}

	let str = '';

	for(let code of generatePasswordCodes()) {
		str += String.fromCharCode(code);
	}

	console.log(str);	//	0..9A..Za..z

• Метод генератора "next" может принимать параметр, который будет обратно отослан в генератор, и будет установлен как результат текущего "yield".
Но чтобы воспользоваться этим переданным значением в генераторе, нужно присвоить текущий "yield" какой либо переменной, и переданное значение присвоится этой переменной:

	function* gen() {
	
		let result = yield "2 + 2 = ?";	// Передаём вопрос во внешний код и ожидаем ответа.

		console.log(result);
	}

	let generator = gen();

	let question = generator.next().value;	//	"yield" возвращает значение "2 + 2 = ?".

	generator.next(4);	//	передаём "4" в генератор.

• У генераторов есть метод "throw", в который можно передать объект ошибки, который затем будет присвоен текущему "yield" (через присвоение переменной как выше). Данную ошибку можно будет
обработать внутри генератора, обернув содержимое генератора в "try"/"catch".

• Асинхронные генераторы.

Для создания асинхронного генератора надо добавить оператор "async" перед объявлением функции-генератора:

	async function* generateSequence() {

		for (let i = 0; i <= 5; i++) {

			await new Promise(resolve => setTimeout(resolve, 1000));	// Здесь "await" используется просто чтобы создать задержку (ничего не возвращает).	

			yield i;
		}

	}

• Особенности работы "async" с генераторами. При использовании ключевого слова "async" с обычными функциями, результат который эти функции будут возвращать будет завернут в промис.
А при использовании ключевого слова "async" с функциями-генераторами, объект который вернет генератор, не будет завернут в промис. В промис уже будет заворачиваться объект,
который вернется при использовании метода "next", у возвращенного генератором объекта:

	let a;

	async function fn1 () { return 5; }	// обычная функция с ключевым словом "async".

	a = fn();	//	"a" = промис, с результатом "5".

	async function* fn2() {	yield 5; }	//	функция генератор с ключевым словом "async".

	a = fn2();	//	"a" = объект, с методом "next", который вернет промис с объектом с результатом "5".

Метод "next()" асинхронного генератора теперь возвращает промис как и асинхронный итератор (подробнее в главе "Тип данных - "Symbol"."). Это значит что такой генератор можно
использовать в цикле "for await ... of ..." (только сам цикл должен быть завернут в асинхронную функцию):

	(async () => {
		let generator = generateSequence();
		for await (let value of generator) {
			console.log(value); // "1", потом "2", потом "3", потом "4", потом "5".
		}
	})();

Для получения значений из асинхронного генератора вручную (через метод "next()"), нужно использовать оператор "await":

	let result;
	(async () => {
		result = await generator.next().value;
	})();

• Асинхронно перебираемые объекты. Такие объекты создаются объединением асинронного итератора и генератора:

	let range = {
		async *[Symbol.asyncIterator]() {
			let value;
			value = await new Promise(resolve => setTimeout(()=>{resolve(1)}, 1000));
			yield value;
			value = await new Promise(resolve => setTimeout(()=>{resolve(2)}, 1000));
			yield value;
			value = await new Promise(resolve => setTimeout(()=>{resolve(3)}, 1000));
			yield value;
		}
	};

	(async () => {
	  for await (let value of range) {
		console.log(value);	//	"1", потом "2", потом "3".
	  }
	})();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Прокси и Рефлект ("Proxy"/"Reflect").

• Объект Прокси "Proxy". "Proxy" - это особый "экзотический" объект, у которого нет собственных свойств или методов.
Прокси "оборачивается" вокруг другого объекта/функции/массива и т.д. и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним,
например чтение/запись свойств и другие. Синтаксис создания прокси:

	new Proxy(<цель>, {<ловушка>(<аргументы>){<тело>}});

	где "<цель>" - это объект или функция, для которого создается прокси, "<ловушка>" - это ловушка-функция, для перехвата вызовов, "<тело>" - тело ловушки.

Когда создается прокси, исходный объект в дальнейшем не используется, а используется прокси. Полезной практикой будет перезаписать исходный объект, предварительно создав для
него прокси, как в примерах ниже. При операциях над прокси, если в обработчике имеется соответствующая ловушка, то она срабатывает.
Если нет соответствующей ловушки, то операция будет произведена над оригинальным объектом/функцией. Прокси является перебираемым объектом (перебор происходит над
оригинальным объектом). При использовании прокси, "this" является сам прокси.

• Список ловушек у прокси, с помощью которых могут быть перехвачены методы/свойста целевого объекта:

	get(<цель>, <свойство>, <ресивер (опционально)>){<тело>}	-	срабатывает при чтении свойства целевого объекта ("[[Get]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться,
	"<ресивер (опционально)>" - если свойство объекта является геттером, то это объект, который будет использован как "this" при его вызове. Когда какой-то объект,
	наследуется от прокси, то этот объект будет в качестве ресивера.

	set(<цель>, <свойство>, <значение>, <ресивер (опционально)>){<тело>}	-	срабатывает при записи свойства целевого объекта ("[[Set]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться,
	"<значение>" - это значение свойства, вызов которого будет перехватываться,	"<ресивер (опционально)>" - если свойство объекта является геттером, то это объект,
	который будет использован как "this" при его вызове. Когда какой-то объект, наследуется от прокси, то этот объект будет в качестве ресивера.

	has(<цель>, <свойство>){<тело>}	-	срабатывает при использовании оператора "in" у целевого объекта ("[[HasProperty]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться.

	deleteProperty(<цель>, <свойство>){<тело>}	-	срабатывает при использовании оператора "delete" у целевого объекта ("[[Delete]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться.

	apply(<цель>, <передаваемый "this">, <массив аргументов>){<тело>}	-	срабатывает при вызове метода/функции ("[[Call]]").
	Где "<цель>" - это оригинальный метод/фунциия, которая передавалась первым аргументом в конструктор "new Proxy", "<передаваемый "this">" - это контекст "this", который будет
	передаваться, "<массив аргументов>" - это массив  аргументов, который будет передаваться в исходную функцию.
	Свойства, которые былы у целевой функции (вокруг чего была создана прокси) - можно вызвать у самой прокси (например свойство "length").

	construct(<цель>, <массив аргументов>){<тело>}	-	срабатывает при использовании оператора "new" у целевого объекта ("[[Construct]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<массив аргументов>" - это массив  аргументов,
	который будет передаваться.

	getPrototypeOf(<цель>){<тело>}	-	срабатывает при использовании "Object.getPrototypeOf" у целевого объекта ("[[GetPrototypeOf]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy".

	setPrototypeOf(<цель>){<тело>}	-	срабатывает при использовании "Object.setPrototypeOf" у целевого объекта ("[[SetPrototypeOf]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy".

	isExtensible(<цель>){<тело>}	-	срабатывает при использовании "Object.isExtensible" у целевого объекта ("[[IsExtensible]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy".

	preventExtensions(<цель>){<тело>}	-	срабатывает при использовании "Object.preventExtensions" у целевого объекта ("[[PreventExtensions]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy".

	defineProperty(<цель>, <свойство>, <дескриптор>){<тело>}	-	срабатывает при использовании "Object.defineProperty"/"Object.defineProperties" у
	целевого объекта ("[[DefineOwnProperty]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться,
	"<дескриптор>" - это передаваемый дескриптор.

	getOwnPropertyDescriptor(<цель>, <свойство>){<тело>}	-	срабатывает при использовании "Object.getOwnPropertyDescriptor"/"for ... in ..."/"Object.keys/values/entries" у целевого
	объекта ("[[GetOwnProperty]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy", "<свойство>" - это свойство, вызов которого будет перехватываться.

	ownKeys(<цель>){<тело>}	-	срабатывает при использовании "Object.getOwnPropertyNames"/"Object.getOwnPropertySymbols"/"for ... in ..."/"Object.keys/values/entries" у целевого объекта
	("[[OwnPropertyKeys]]").
	Где "<цель>" - это оригинальный объект, который передавался первым аргументом в конструктор "new Proxy".

• Обращение к методам исходного объекта, будет перехватываться ловушкой "get", так как это все равно обращение, а не запись. Подробнее внизу в примерах с внутренними слотами.

Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия (Инварианты).

• Инварианты. "JavaScript" налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек:

	1. Метод "[[Set]]" должен возвращать "true", если значение было успешно записано, иначе "false".

	2. Метод "[[Delete]]" должен возвращать "true", если значение было успешно удалено, иначе "false".

	3. Метод "[[GetPrototypeOf]]", применённый к прокси, должен возвращать то же значение, что и метод "[[GetPrototypeOf]]", применённый к оригинальному объекту.
	Другими словами, чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.

Пример создания простого прокси без ловушек (с пустым обработчиком):

	let target = {};
	let proxy = new Proxy(target, {});	//	пустой "handler".

	proxy.test = 5;	//	записываем в прокси, а тот без изменений в оригинальный объект (так как нет ловушек).
	console.log(target.test);	//	"5", свойство появилось в "target".

	console.log(proxy.test);	//	"5", также можно прочитать его из прокси.

	for(let key in proxy) console.log(key);	//	"test", итерация работает.

Так как нет ловушек, то все операции на "proxy" применяются к оригинальному объекту "target". "Proxy" – это особый, "экзотический", объект, у него нет собственных свойств.
С пустым "handler" он просто перенаправляет все операции на "target".

Пример использования прокси с ловушкой геттера:

	let numbers = [0, 1, 2];

	numbers = new Proxy(numbers, {
		get(target, prop) {
			if (prop in target) {
				return target[prop];
			} else {
				return 0;	//	значение по умолчанию.
			}
		}
	});

	console.log( numbers[1] );	//	1
	console.log( numbers[123] );	//	"0" (нет такого элемента).
	
	Обычно при чтении из массива несуществующего свойства возвращается "undefined", в данном примере обычный массив оборачивается в прокси, который перехватывает операцию чтения
	свойства из массива и возвращает "0", если такого элемента нет.

Пример использования прокси с ловушкой сеттером:

	let numbers = [];

	numbers = new Proxy(numbers, {
		set(target, prop, val) {	//	для перехвата записи свойства.
			if (typeof val == 'number') {
				target[prop] = val;
				return true;	// Правило Инварианта.
			} else {
				return false;
			}
		}
	});

	numbers.push(1);	//	добавилось успешно.
	numbers.push(2);	//	добавилось успешно.
	alert("Длина: " + numbers.length);	//	2

	numbers.push("тест");	//	"TypeError" (ловушка "set" на прокси вернула "false").

"Object.keys", цикл "for ... in ..." и большинство других методов, которые работают со списком свойств объекта, используют внутренний метод "[[OwnPropertyKeys]]"
(перехватываемый ловушкой "ownKeys") для их получения. Примеры перебора при помощи "ownKeys":

	let user = {
		name: "Вася",
		age: 30,
		_password: "***"
	};

	user = new Proxy(user, {
		ownKeys(target) {
			return Object.keys(target).filter(key => !key.startsWith('_'));	// Возвращает массив с нужными свойствами, перебор цикла идет уже по нему.
		}
	});

	//	"ownKeys" исключил "_password".
	for(let key in user) alert(key);	//	"name", затем: "age".

	// аналогичный эффект для этих методов:
	alert( Object.keys(user) );	//	"name", "age".
	alert( Object.values(user) );	//	"Вася", "30".
	
Если попробовать возвратить ключ, которого в исходном объекте на самом деле нет, то "Object.keys" его не выдаст:

	let user = { };

	user = new Proxy(user, {
		ownKeys(target) {
			return ['a', 'b', 'c'];
		}
	});

	alert( Object.keys(user) );	//	<пусто>.
	
Чтобы "Object.keys" возвращал свойство, нужно либо чтобы свойство в объекте физически было, причём с флагом "enumerable", либо перехватить вызовы "[[GetOwnProperty]]"
(это делает ловушка "getOwnPropertyDescriptor"), и там вернуть дескриптор с "enumerable: true" вручную:

	let user = {};

	user = new Proxy(user, {
		ownKeys(target) { // вызывается 1 раз для получения списка свойств
			return ['a', 'b', 'c'];
		},

		getOwnPropertyDescriptor(target, prop) { // вызывается для каждого свойства
			return {
				enumerable: true,
				configurable: true
			};
		}
	});

	alert( Object.keys(user) ); // a, b, c

Это происходит потому что, ловушка "ownKeys" вызывается один раз для проверяемого объекта, а затем проверются свойства дескриптора для каждого свойства объекта.
Если в примере выше не было бы ловушки "getOwnPropertyDescriptor" с дескрипторами который он возвращает, то это означало бы что по умолчанию у дескрипторов
возвращаемых свойств были бы значения "false" ("enumerable: false"), а соответсвенно возвращаемые значения проигнорировались бы (так как дескриптор запрещает
их перечисление).
	
Пример с ловушкой "has":

	let range = {
		start: 1,
		end: 10
	};

	range = new Proxy(range, {
		has(target, prop) {
			return prop >= target.start && prop <= target.end
		}
	});

	alert(5 in range);	//		true
	alert(50 in range);	//	false

Пример с ловушкой "apply":
	
	function fn(a, b, c){
		console.log(a, b, c);
	}
	
	let prx = new Proxy(fn, {
		apply(target, thisArg, args){	//	"thisArgs" здесь равен "undefined".
			console.log("test");
			target(...args);
		}
	});

	prx.length	//	"3" - чтение свойства "length", перенапрвляет его к целевому объекту (фунции), и показывает количество его аргументов.
	
	prx(5, 6, 7);	// "test"
					//	5 6 7

Пример с использованием ресивера приведен ниже.

• Рефлект "Reflect". "Reflect" - это встроенный объект, который предоставляет методы для перехватывания "JavaScript" операций над объектами.
"Reflect" упрощающает создание прокси, позволяя вручную использовать встроенные методы объекта (перенаправляет операцию на исходный объект).
В отличие от большинства глобальных объектов, "Reflect" - это не конструктор. Нельзя использовать его с оператором "new" или вызывать "Reflect" как функцию.
Рефлект удобен для корректного вызова методов которые используют "this".

• Рефлект полезен для использования когда какой-то объект, наследуется от прокси, чтобы установить этот объект в качестве ресивера (передачи контекста "this").

• Список методов у рефлекта, которые выполняют соответствующую операцию у исходного объекта:

	get(<цель>, <свойство>, <ресивер (опционально)>)	-	вызывает чтение свойства целевого объекта ("[[Get]]"). Где "<цель>" - это объект-цель,
	"<свойство>" - это имя читаемого свойства, "<ресивер (опционально)>" - если свойство объекта является геттером, то это объект,
	который будет использован как "this" при его вызове.

	set(<цель>, <свойство>, <значение>, <ресивер (опционально)>)	-	вызывает запись свойства целевого объекта ("[[Set]]"). Где "<цель>" - это объект-цель,
	"<свойство>" - это имя записываемого свойства, "<значение>" - это значение записываемого свойства, "<ресивер (опционально)>" - если свойство объекта является геттером,
	то это объект, который будет использован как "this" при его вызове.

	has(<цель>, <свойство>)	-	вызывает оператор "in" у целевого объекта ("[[HasProperty]]"). Где "<цель>" - это объект-цель, "<свойство>" - это проверяемое свойство.

	deleteProperty(<цель>, <свойство>)	-	вызывает оператор "delete" у целевого объекта ("[[Delete]]"). Где "<цель>" - это объект-цель, "<свойство>" - это проверяемое свойство.

	apply(<цель>, <передаваемый "this">, <массив аргументов>)	-	вызывает метод "apply" для целевого объекта ("[[Call]]").
	Где "<цель>" - это объект-цель, "<передаваемый "this">" - это контекст "this", который будет передаваться, "<массив аргументов>" - это массив  аргументов,
	который будет передаваться.

	construct(<цель>, <массив аргументов>)	-	вызывает оператор "new" у целевого объекта ("[[Construct]]").
	Где "<цель>" - это объект-цель, "<массив аргументов>" - это массив  аргументов, который будет передаваться.

	getPrototypeOf(<цель>)	-	вызывает "Object.getPrototypeOf" у целевого объекта ("[[GetPrototypeOf]]"). Где "<цель>" - это объект-цель.

	setPrototypeOf(<цель>)	-	вызывает "Object.setPrototypeOf" у целевого объекта ("[[SetPrototypeOf]]"). Где "<цель>" - это объект-цель.

	defineProperty(<цель>, <свойство>, <дескриптор>)	-	вызывает "Object.defineProperty" у	целевого объекта ("[[DefineOwnProperty]]").
	Где "<цель>" - это объект-цель, "<свойство>" - это имя свойства, которое будет присваиваться, "<дескриптор>" - это передаваемый дескриптор.

	getOwnPropertyDescriptor(<цель>, <свойство>)	-	вызывает "Object.getOwnPropertyDescriptor" у целевого объекта ("[[GetOwnProperty]]").
	Где "<цель>" - это объект-цель, "<свойство>" - это имя запрашиваемого свойства.

	ownKeys(<цель>)	-	возвращает массив с ключами целевого объекта, включая и символьные ключи ("[[OwnPropertyKeys]]"). Где "<цель>" - это объект-цель.
	
	isExtensible(<цель>)	-	вызывает "Object.isExtensible" у целевого объекта ("[[IsExtensible]]"). Где "<цель>" - это объект-цель.

	preventExtensions(<цель>)	-	вызывает "Object.preventExtensions" у целевого объекта ("[[PreventExtensions]]"). Где "<цель>" - это объект-цель.

	enumerate(<цель>)	-	(данный метод не доступен).

Пример использования метода "apply" у рефлекта:

	let a = {x: 10, rr(){return this.x*2}};
	let b = {x: 20};
	
	Reflect.apply(a.rr, b, [])	//	40

Пример использования метода "construct" у рефлекта:

	class U{
		constructor(a,b){
			this.RU = a*b;
			this.FF = a+b;
			this.TT = a/b;
		}
	}
	
	let a = Reflect.construct(U, [10,5]);	//	Все равно что "let a = new U(10,5);

Пример использования метода "get" у рефлекта, с использованием ресивера:

	let a = {
		x:12,
		get r(){
			return this.x*2;
		}
	};
	
	let b = {x: 20};
	
	Reflect.get(a, "r", b);	//	40
	
Пример использования метода "get" у рефлекта, с использованием ресивера внутри прокси:

	let user = {
		_name: "Гость",
		get name() {
			return this._name;
		}
	};
	
	let userProxy = new Proxy(user, {
		get(target, prop, receiver) { // receiver = admin
			return Reflect.get(target, prop, receiver);
		}
	});
	
	let admin = {
		__proto__: userProxy,
		_name: "Админ"
	};
	
	admin.name	// Админ

• Внутренние слоты. Многие встроенные объекты, например "Map", "Set", "Date", "Promise" и другие используют так называемые "внутренние слоты".
Например, "Map" хранит элементы во внутреннем слоте "[[MapData]]". Встроенные методы обращаются к слотам напрямую, не через "[[Get]]"/"[[Set]]".
Таким образом, прокси не может перехватить их. Подробнее "https://learn.javascript.ru/proxy#vstroennye-obekty-vnutrennie-sloty".

Если встроенный объект проксируется, то в прокси не будет этих "внутренних слотов", так что попытка вызвать на таком прокси встроенный метод приведёт к ошибке:

	let map = new Map();

	let proxy = new Proxy(map, {});

	proxy.set('test', 1);	//	ошибка.

Исправленный вариант:

	let map = new Map();

	let proxy = new Proxy(map, {
		get(target, prop) {
			let value = target[prop];
			if (typeof value == 'function') {
				return value.bind(target);
			}
			return value
		}
	});

	proxy.set('test', 1);
	console.log(proxy.get('test'));	//	1
	
	Пример выше работает следующим образом. При вызове "proxy.set('test', 1);" происходит следующее: выражение "proxy.set" обработается ловушкой "get", так как это все равно
	обращение с свойству/методу, как говорилось в правиле выше "Обращение к методам исходного объекта, будет перехватываться ловушкой "get", так как это все равно обращение,
	а не запись". Соответственно когда произойдет обращение "proxy.set", выполнится ловушка "get" и из прокси вернется функция (в коде из примера выше). Затем выполниться
	оставшаяся часть выражения "('test', 1);", что уже вызовет функцию, передав аргументы (в данном примере возвращенная функция с фиксированным контекстом, для работы
	с внутренними слотами объекта "Map").
	
	Тот же пример выше, но с использованием Рефлекта:
	
			let map = new Map();

			let proxy = new Proxy(map, {
				get(target, prop) {
					let value = Reflect.get(target, prop);
					if (typeof value == 'function') {
						return value.bind(target);
					}
					return value
				}
			});

			proxy.set('test', 1);
			console.log(proxy.get('test'));	//	1

	Пример, для лучшего понимания как работает внутренний слот у "Map":
	
		let map = new Map();
		
		let b = map.set;	//	извлекаем метод "set" у "Map";
		
		b("number", 450);	//	ошибка, так как функция пытается получить доступ к своему внутреннему свойству "this.[[MapData]]" (в "Map"), но так как "this" в данном
							//	случае равен "undefined", будет ошибка.
		
		b = b.bind(map);	//	фиксируем контекст у извлеченной на объект "Map" - "map". Можно так же было использовать 'b.apply(map, ["number", 450]);'.
		
		b("number", 450);	// то же самое, что и 'map.set("number", 450)';

Объект "Array" не использует внутренние слоты.

Приватные поля классов тоже используют внутренние слоты, и к ним тоже не удастся получить доступ просто через прокси. Нужен так же рефлект:

	class User {
	
		#name = "Гость";
		
		getName() {
			return this.#name;
		}
	}

	let user = new User();

	user = new Proxy(user, {});

	user.getName();	//	Ошибка.
	
	Решение:

		user = new Proxy(user, {
			get(t,p,r){
				return t[p].bind(t);
			}
		});

		user.getName();	//	"Гость"
	
	Тот же пример выше, но с использованием Рефлекта:
	
		user = new Proxy(user, {
			get(t,p,r){
				return Reflect.get(t,p).bind(t);
			}
		});
		
		user.getName();	//	"Гость"

• Отключаемые прокси. Отключаемый ("revocable") прокси – это прокси, который может быть отключён вызовом специальной функции. При отключении прокси отключается навсегда,
и нет способа снова включить его, так как вызов "revoke()" удаляет все внутренние ссылки на оригинальный объект из прокси, так что между ними больше нет связи,
и оригинальный объект теперь может быть очищен сборщиком мусора.

Пример синтаксиса:

	let {proxy, revoke} = Proxy.revocable(<цель>, {<ловушка>(<аргументы>){<тело>}});
	
Вызов возвращает объект с "proxy" и функцией "revoke", которая отключает его, поэтому в примере синтаксиса использована деструктуризация.

Пример:

	let a = {x: 12};
	
	let {proxy, revoke} = Proxy.revocable(a, {});
	
	proxy.x;	//	12
	
	revoke();
	
	proxy.x;	//	Ошибка, прокси отлючен.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Побитовые операторы. Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.

Побитовые операторы работают следующим образом:

	1. Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.

	2. Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п.
	Оператор применяется к каждой паре бит, давая соответствующий бит результата.
	
	3. Получившаяся в результате последовательность бит интерпретируется как обычное число.

Список побитовых операторов:

	&	-	(И)	-	выполняет операцию "И" над каждой парой бит. Результат "a & b" равен единице только когда оба бита "a" и "b" равны единице. Пример:
	
		let a = 9;	//		9  == "00000000000000000000000000001001".
		let b = 14;	//		14 == "00000000000000000000000000001110".
		let c = a&b;	//	8  == "00000000000000000000000000001000".
	
	|	-	(ИЛИ)	-	выполняет операцию "ИЛИ" над каждой парой бит. Результат "a | b" равен 1, если хотя бы один бит из "a","b" равен 1. Пример:
	
		let a = 9;	//		9  == "00000000000000000000000000001001".
		let b = 14;	//		14 == "00000000000000000000000000001110".
		let c = a&b;	//	15 == "00000000000000000000000000001111".
	
	^	-	(Исключающее ИЛИ)	-	выполняет операцию "Исключающее ИЛИ" над каждой парой бит. "a Исключающее ИЛИ b" равно 1, если только "a=1" или только "b=1",
	но не оба одновременно "a=b=1". Пример:
	
		let a = 9;	//		9  == "00000000000000000000000000001001".
		let b = 14;	//		14 == "00000000000000000000000000001110".
		let c = a&b;	//	 7 == "00000000000000000000000000000111".
		
		• Исключающее "или" можно использовать для шифрования, так как эта операция полностью обратима.
		Двойное применение исключающего "ИЛИ" с тем же аргументом даёт исходное число.
	
	~	-	(НЕ)	-	производит операцию "НЕ" над каждым битом, заменяя его на обратный ему. Из-за внутреннего представления отрицательных чисел получается так,
	что "~a == -(a+1)". Пример:
	
		let a = 9;	//		  9 == "00000000000000000000000000001001".
		let b = ~a;	//		-10 == "11111111111111111111111111110110". Все равно что "-(9+1)".
		let c = ~3;	//		-4
	
	<<	-	(Битовый сдвиг влево)	-	операторы битового сдвига принимают два операнда. Первый – это число для сдвига, а второй – количество битов,
	которые нужно сдвинуть в первом операнде. Оператор "<<" сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.
	Из-за внутреннего представления чисел получается так, что "a << b == a * (2^b)". Пример:
	
		let a = 9;	//		9  == "00000000000000000000000000001001".
		let b = a << 2;	//	36 == "00000000000000000000000000100100".
		
		console.log(3 << 1)	//	 6, умножение на 2.
		console.log(3 << 2)	//	12, умножение на 2 два раза.
		console.log(3 << 3)	//	24, умножение на 2 три раза.
	
	>>	-	(Правый битовый сдвиг, переносящий знак)	-	этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия крайнего-левого бита.
	Знак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый бит имеет то же значение, что и исходном числе.
	Из-за внутреннего представления чисел получается так, что "a >> b == a / (2^b)". Пример:
	
		let a = -9;	//		-9  == "11111111111111111111111111110111".
		let b = a >> 2;	//	-3 ==  "11111111111111111111111111111101".
		
		console.log(100 >> 1);	//	50, деление на 2.
		console.log(100 >> 2);	//	25, деление на 2 два раза.
		console.log(100 >> 3);	//	12, деление на 2 три раза, целая часть от результата.
	
	>>>	-	(Правый сдвиг с заполнением нулями)	-	этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.
	Знаковый бит становится равным 0, поэтому результат всегда положителен. Для неотрицательных чисел правый сдвиг с заполнением нулями ">>>" и правый сдвиг с переносом знака ">>"
	дадут одинаковый результат, т.к в обоих случаях слева добавятся нули. Пример:
	
		let a = -9;	//					 -9  == "11111111111111111111111111110111".
		let b = a >>> 2;	//	 1073741821 ==  "00111111111111111111111111111101".

• У побитовых операторов низкий приоритет, меньше чем у операторов сравниваний, и меньше чем у остальной арифметики.
Например, в сравнении "a == b^0" будет сначала выполнено сравнение "a == b", а уже затем операция "^0", как будто стоят скобки "(a == b)^0". Чтобы гарантировать желаемый порядок,
нужно ставить скобки: "a == (b^0)".

Примеры применения побитовых операторов:

	Округление:
	
		console.log( ~~12.345 );	//	12
		console.log( 12.345 ^ 0 );	//	12
		console.log( 12.3 * 14.5 ^ 0);	//	178, так как "12.3 умножить на 14.5 и округлить".
	
	Проверка на "−1":
	
		let n = -1;

		if (~n) { // не сработает, т.к. "~n = -(-1+1) = 0"
		  ...
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Интернационализация ("Intl").

Объекты-конструкторы "Intl":

	Intl.Collator([<локали>, [<опции (опционально)>] (опционально)])	-	строки. Умеет правильно сравнивать и сортировать строки. Локаль может быть одна, или массив локалей,
	в порядке предпочтения. Методы/свойства:
	
		compare(<строка1>, <строка2>);	-	сравнивание двух строк.

	Intl.DateTimeFormat([<локали>, [<опции (опционально)>]])	-	умеет форматировать дату и время в соответствии с нужным языком. Методы/свойства:
	
		format(<объект даты>);	-	форматирование указанного объекта даты в соответствии с опциями.

	Intl.NumberFormat([<локали>, [<опции (опционально)>] (опционально)])	-	умеет форматировать числа в соответствии с нужным языком. Методы/свойства:
	
		format(<число>);	-	форматирование указанного числа в соответствии с опциями.

Новые объекты-конструкторы "Intl" создаются с использованием ключевого слова "new".

• Строки, "Intl.Collator".

Пример синтаксиса создания и использования объекта "Collator" с методом "compare":

	let collator = new Intl.Collator([<локали>, [<опции (опционально)>] (опционально)]);
	
	let result = collator.compare(<строка1>, <строка2>);

Как видно из примера выше, для использования объекта "Collator" для сравнения двух строк, используется его метод "compare".

Результат метода "compare" имеет значение "1" (больше), "0" (равно) или "-1" (меньше).

• Локаль. Все методы принимают локаль в виде строки или массива, содержащего несколько локалей в порядке предпочтения. Если локаль не указана или "undefined" – берётся локаль
по умолчанию, установленная в окружении (браузере). Локаль описывается из трёх компонентов, которые разделяются дефисом:

	1. Код языка.
	
	2. Код способа записи.
	
	3. Код страны.

Примеры локали:

	zh-Hans-CN – китайский язык ("zh"), записываемый упрощённой иероглифической письменностью ("Hans"), используемый в Китае (все три локали).

	ru – русский язык, без уточнений (одна локаль - первая).
	
	en-GB – английский язык, используемый в Англии ("GB") (две локали - первая и третья).
	
	en-US – английский язык, используемый в США ("US") (две локали - первая и третья).

Расширения локалей. Через суффикс "-u-" можно указать расширения локалей. Например:

	"th-TH-u-nu-thai"	-	тайский язык ("th"), используемый в Таиланде ("TH"), с записью чисел тайскими буквами.

Стандарт, который описывает локали – "RFC 5464" - "http://tools.ietf.org/html/rfc5646",
языки описаны в "IANA language registry" - "http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry".

• Опции (свойства) объекта "Collator" (объект с дополнительными настройками):

	localeMatcher	-	алгоритм выбора подходящей локали. Это вспомогательная настройка, которую тоже можно везде указать,
	она определяет способ подбора локали, если желаемая недоступна. Значения:
	
		"lookup"	-	означает простейший порядок поиска путём обрезания суффикса.
		Например для локали "zh-Hans-CN" оборезка в случае недоступности таковой прозойдет следующим образом:

			"zh-Hans-CN"	->	"zh-Hans"	->	"zh"	->	"локаль по умолчанию".
		
		"best fit"	-	использует встроенные алгоритмы и предпочтения браузера (или другого окружения) для выбора подходящей локали (по умолчанию).
	
		Если локалей несколько, например '["zh-Hans-CN", "ru-RU"]' то "localeMatcher" пытается подобрать наиболее подходящую локаль для первой из
		списка (китайская), если не получается – переходит ко второй (русской) и так далее. Если ни одной не нашёл, например на компьютере не совсем
		поддерживается ни китайский ни русский, то используется локаль по умолчанию. Как правило, "best fit" является здесь наилучшим выбором.

	usage	-	цель сравнения:
	
		"sort"	-	сортировка (по умолчанию).

		"search"	-	поиск.

	sensitivity	-	чувствительность: какие различия в символах учитывать, а какие – нет, варианты:

		"base"	-	учитывать только разные символы, без диакритических знаков и регистра, например: "а ̸= б", "е = ё", "а = А".
		
		"accent"	-	учитывать символы и диакритические знаки, например: "а ̸= б", "е ̸= ё", "а = А".
		
		"case"	-	учитывать символы и регистр, например: "а ̸= б", "е = ё", "а ̸= А".
		
		"variant"	-	учитывать всё: символ, диакритические знаки, регистр, например: "а ̸= б", "е ̸= ё", "а ̸= А", используется по умолчанию.
		
		"ignorePunctuation"	-	игнорировать знаки пунктуации: "true"/"false", по умолчанию "false".

	numeric	-	использовать ли численное сравнение:
	
		"true"	-	при использовании будет "12 > 2".
		
		"false"	-	при использовании будет "12 < 2".

	caseFirst	-	в сортировке должны идти первыми прописные или строчные буквы, варианты:
	
		"upper"	-	прописные;
		
		"lower"	-	строчные или "false" (стандартное для локали, также	является значением по умолчанию). Не поддерживается "IE11".

	В подавляющем большинстве случаев подходят стандартные параметры, то есть "options" указывать не нужно.

Пример использования объекта "Collator":

	var collator = new Intl.Collator();

	console.log( "ёжик" > "яблоко" );	//	"true" ("ёжик" больше, что неверно).
	
	console.log( collator.compare("ёжик", "яблоко") );	//	"-1" ("ёжик" меньше, верно).

Выше были использованы полностью стандартные настройки. Они различают регистр символа, но это различие можно убрать, если настроить чувствительность "sensitivity":

	var collator = new Intl.Collator();
	
	console.log( collator.compare("ЁжиК", "ёжик") );	//	"1" - разные.

	var collator = new Intl.Collator(undefined, {
	  sensitivity: "accent"
	});
	
	console.log( collator.compare("ЁжиК", "ёжик") );	//	"0", одинаковые.

• Даты, "Intl.DateTimeFormat".

Пример синтаксиса создания и использования объекта "DateTimeFormat" с методом "format":

	let formatter = new Intl.DateTimeFormat([<локали>, [<опции (опционально)>] (опционально)]);
	
	let result = formatter.format(<объект даты>);

• Локаль. Локаль - то же самое, то и в объекте "Collator".

• Опции (свойства) объекта "DateTimeFormat" (объект с дополнительными настройками):

	localeMatcher	-	то же что и у объекта "Collator".
	
	formatMatcher	-	алгоритм подбора формата:

		"basic"
		
		"best fit"	-	(по умолчанию).

	hour12	-	включать ли время в 12-часовом формате:
	
		"true"	-	12-часовой формат.
		
		"false"	-	24-часовой формат.

	timeZone	-	временная зона, например:
	
		"Europe"
		
		"Moscow"
		
		"UTC"	-	(по умолчанию).

	weekday	-	день недели:
	
		"narrow"
		
		"short"
		
		"long"

	era	-	эра:
	
		"narrow"
		
		"short"
		
		"long"

	year	-	год:
	
		"2-digit"
		
		"numeric"	-	(по умолчанию).

	month	-	месяц:
	
		"2-digit"
		
		"numeric"	-	(по умолчанию).

		"narrow"
		
		"short"
		
		"long"

	day	-	день:
	
		"2-digit"
		
		"numeric"	-	(по умолчанию).

	hour	-	час:

		"2-digit"

		"numeric"

	minute	-	минуты:

		"2-digit"
		
		"numeric"

	second	-	секунды:
	
		"2-digit"
		
		"numeric"

	timeZoneName	-	название таймзоны (нет в "IE11"):
	
		"short"
		
		"long"

• Все локали обязаны поддерживать следующие наборы настроек:

	>	"weekday", "year", "month", "day", "hour", "minute", "second".

	>	"weekday", "year", "month", "day".

	>	"year", "month", "day".

	>	"year", "month".

	>	"month", "day".

	>	"hour", "minute", "second".

Если указанный формат не поддерживается, то настройка "formatMatcher" задаёт алгоритм подбора наиболее близкого формата: "basic" – по стандартным правилам,
и "best fit" – по умолчанию, на усмотрение окружения (браузера).

• В результате форматирования даты, будет возвращена строка состоящая из тех элементов, чьи настройки были определены в объекте настроек объекта "DateTimeFormat". Элементы,
чьи настройки не были определены, не будут в этой строке. Например если определить настройки для форматирования часов, то строка будет состоять из часов, и не будет иметь
день, месяц и т.д., так как их настройки не были определены.

Примеры использования объекта "DateTimeFormat":

	1. Без указания опций:

		let date = new Date(2014, 11, 31, 12, 30, 0);

		let formatter = new Intl.DateTimeFormat("ru");
		
		console.log( formatter.format(date) );	//	31.12.2014

		let formatter = new Intl.DateTimeFormat("en-US");
		
		console.log( formatter.format(date) );	//	12/31/2014
	
	2. С опциями (дата):
	
		let date = new Date(2014, 11, 31, 12, 30, 0);

		let formatter = new Intl.DateTimeFormat("ru", {
		  weekday: "long",
		  year: "numeric",
		  month: "long",
		  day: "numeric"
		});

		console.log( formatter.format(date) );	//	"среда, 31 декабря 2014 г" - как указано в правиле выше, строка содержит элементы, чьи настройки были предварительно указаны.
	
	3. С опциями (время):
	
		let date = new Date(2014, 11, 31, 12, 30, 0);

		let formatter = new Intl.DateTimeFormat("ru", {
		  hour: "numeric",
		  minute: "numeric",
		  second: "numeric"
		});

		console.log( formatter.format(date) );	//	"12:30:00"	-	как указано в правиле выше, строка содержит элементы, чьи настройки были предварительно указаны.

• Числа, "Intl.NumberFormat".

Пример синтаксиса создания и использования объекта "NumberFormat" с методом "format":

	let formatter = new Intl.NumberFormat([<локали>, [<опции (опционально)>] (опционально)]);
	
	let result = formatter.format(<число>);

• Локаль. Локаль - то же самое, то и в объекте "Collator".

• Опции (свойства) объекта "NumberFormat" (объект с дополнительными настройками):

	localeMatcher	-	то же что и у объекта "Collator".

	style	-	стиль форматирования:
	
		"decimal"	-	(по умолчанию).
		
		"percent"
		
		"currency"

	currency	-	алфавитный код валюты (см. список кодов валюты, например "USD").

	currencyDisplay	-	показывать валюту в виде кода, локализованного символа или локализованного названия:
	
		"code"
		
		"symbol"	-	(по умолчанию).
		
		"name"

	useGrouping	-	разделять ли цифры на группы:
	
		"true"	-	(по умолчанию).
		
		"false"

	minimumIntegerDigits	-	минимальное количество цифр целой части от "1" до "21" (по умолчанию "21").

	minimumFractionDigits	-	минимальное количество десятичных цифр от "0" до "20". По умолчанию  для чисел и процентов = "0", для валюты зависит от кода.

	maximumFractionDigits	-	максимальное количество десятичных цифр от "minimumFractionDigits" до "20".	По умолчанию для чисел = "max(minimumFractionDigits, 3"),
	для процентов = "0", для валюты зависит от кода.

	minimumSignificantDigits	-	минимальное количество значимых цифр от "1" до "21" (по умолчанию "1").

	maximumSignificantDigits	-	максимальное количество значимых цифр от "minimumSignificantDigits" до "21" (по умолчанию "minimumSignificantDigits").

Примеры использования объекта "NumberFormat":

	1. Без указания опций:
	
		let formatter = new Intl.NumberFormat("ru");

		console.log( formatter.format(1234567890.123) );	//	1 234 567 890,123
	
	2. С ограничением значимых цифр (важны только первые 3):
	
		let formatter = new Intl.NumberFormat("ru", {
		  maximumSignificantDigits: 3
		});

		console.log( formatter.format(1234567890.123) );	//	1 230 000 000
	
	3. С опциями для валюты:
	
		let formatter = new Intl.NumberFormat("ru", {
		  style: "currency",
		  currency: "GBP"
		});

		console.log( formatter.format(1234.5) );	//	1 234,5 £
	
	4. С двумя цифрами после запятой:
	
		let formatter = new Intl.NumberFormat("ru", {
		  style: "currency",
		  currency: "GBP",
		  minimumFractionDigits: 2
		});

		console.log( formatter.format(1234.5) );	//	1 234,50 £

• Методы в объектах "Date", "String", "Number".

• Сравнения в строках. У прототипа объекта "String" есть метод "localeCompare", который работает так же как и конструктор объекта "Intl.Collator":

	String.prototype.localeCompare(<строка>, [<локали>, [<опции (опционально)>] (опционально)]);

	Пример:

		let str = "ёжик";

		console.log( str.localeCompare("яблоко", "ru") );	//	-1

• Сравнения в датах. У прототипа объекта "Date" есть методы:

	toLocaleString([<локали>, [<опции (опционально)>] (опционально)])	-	работает так же как и конструктор объекта "Intl.DateTimeFormat".
	
	toLocaleDateString([<локали>, [<опции (опционально)>] (опционально)])	-	то же что и метод "toLocaleString" выше, но опции по умолчанию включают в себя год, месяц,
	день
	
	toLocaleTimeString([<локали>, [<опции (опционально)>] (опционально)])	-	то же что и метод "toLocaleString" выше, но опции по умолчанию включают в себя часы, минуты,
	секунды.

	Пример:

		let date = new Date(2014, 11, 31, 12, 00);

		console.log( date.toLocaleString("ru", { year: 'numeric', month: 'long' }) );	//	Декабрь 2014

• Сравнения в числах. У прототипа объекта "Number" есть метод "toLocaleString", который работает так же как и конструктор объекта "Intl.NumberFormat":
	
	Number.prototype.toLocaleString([<локали>, [<опции (опционально)>] (опционально)]);

	Пример:
	
		let number = 1234567890.123;
		
		console.log(number.toLocaleString("ru", { maximumSignificantDigits: 3 }));	//	1 230 000 000

Все эти методы при запуске создают соответствующий объект объекта "Intl" и передают ему опции, можно рассматривать их как укороченные варианты вызова.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Модули.

Чтобы добавить модуль на страницу, браузеру нужно явно указать на то, что это является модулем, указав у тега "<script>" в атрибуте "type" - "module":

	<script type="module" src="...">...</script>

Общий синтаксис экспортирования и импортирования:

	export {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу>}	//	экспортирование.

	import {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу>} from "<ссылка из атрибута "src" тега "<script>">";	//	импортирование.

Директива "export" экспортирует функции/объекты/классы/примитивы и т.д., что указаны после нее. Директива "import" импортирует функции/объекты/классы/примитивы и т.д.
из файла/модуля по ссылке, которая указывается после директивы "from". Если экспортируются не один, а несколько элементов, то они перечисляются после запятой
в фигурных скобках ("{}"). Импортирование производится только в фигурных скобках (за исключением импорта по умолчанию).
После директивы "export" может стоять объявление "let"/"var"/"const"/"function" и т.д. Директива "export" может писаться как отдельно от объявления,
так и с. Ключевое слово "as" является опциональным, и устанавливает пользовательское имя элементу (например новое имя для импортируемой функции).

Пример:

	// Работа в файле "sayHi.js".

	export function sayHi(user) {	//	/
		console.log(`Hello, ${user}!`);
	}
	
	// Работа в файле "main.js".
	
	import {sayHi} from './sayHi.js';

	console.log(sayHi);
	sayHi('John');	//	Hello, John!

Пример простого подключения модуля (его код запустится), без присваивания ее переменной:

	// Работа в файле "alert.js".
	
	alert("Модуль выполнен!");
	
	// Работа в файле "one.js".

	import `./alert.js`; // Модуль выполнен!

Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз.
Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам:

	// Работа в файле "admin.js".
	export let admin = {
		name: "John"
	};

	// Работа в файле "one.js".
	import {admin} from './admin.js';
	admin.name = "Pete";

	// Работа в файле "two.js".
	import {admin} from './admin.js';
	alert(admin.name);	//	Pete
	
	Оба файла, "one.js" и "two.js", импортируют один и тот же объект, Изменения, сделанные в "one.js", будут видны в "two.js".

Импортирование "как" ("as"):

	import {sayHi as hi, sayBye as bye} from './say.js';

	hi('John');	//	Hello, John!
	bye('John');	//	Bye, John!

• Если необходимо импортировать много элементов, то можно импортировать все экспортируемое содержимое модуля сразу в виде объекта,
используя символ звездочки "*". В таком случае используется ключевое слово "as":

	import * as say from 'moduleOne.js';	//	Импортируем все экспортируемое содержимое в объект "say".

	say.sayHi('John');
	say.sayBye('John');

• Экспорт/Импорт по умолчанию. При экспорте по умолчанию используется ключевое слово "default" перед экспортируемым элементом.
В модуле может быть не более одного выражения "default". При импорте по умолчанию, импортируемый элемент указывается без фигурных скобок.
Пример экспорта/импорта по умолчанию:

	// Работа в файле "user.js".

	export default class User {
		constructor(name) {
			this.name = name;
		}
	}
	
	// Работа в файле "main.js".
	
	import User from './user.js';	//	не "{User}", а просто "User".
	new User('John');

Так как в файле может быть максимум один export "default", то экспортируемая сущность может и не иметь имя.

	// Работа в файле "one.js".

	export default class {	//	у класса нет имени.
		constructor() { ... }
	}

	// Работа в файле "two.js".
	
	export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];	//	экспортируем значение, не создавая переменную.
	
	// Работа в файле "three.js".
	
	export default function(user) {	//	у функции нет имени.
		alert(`Hello, ${user}!`);
	}

Имя "default". В некоторых ситуациях для обозначения экспорта по умолчанию в качестве имени используется "default".
Например, чтобы экспортировать функцию отдельно от её объявления:

	function sayHi(user) {
		alert(`Hello, ${user}!`);
	}

	export {sayHi as default};	//	то же самое, как если бы мы добавили "export default" перед функцией.

Если экспорируется всё как объект ("import *"), тогда его свойство "default" это как раз и будет экспортом по умолчанию:

	import * as user from './user.js';

	let User = user.default;	//	экспорт по умолчанию.
	new User('John');

Технически в одном модуле может быть как экспорт по умолчанию, так и именованные экспорты, но на практике обычно их не смешивают.
То есть, в модуле находятся либо именованные экспорты, либо один экспорт по умолчанию.

• Реэкспорт. Для реэкспорта элементов из другого файла, используется следующий синтаксис:

	export {<функции/объекты/классы/примитивы и т.д.>} from "<ссылка из атрибута "src" тега "<script>">"

Реэкспорт так же можно комбинировать с экспортированием по умолчанию и/или ключевым словом "as":

	export {<функции/объекты/классы/примитивы и т.д.> as <пользовательское имя элементу> } from "<ссылка из атрибута "src" тега "<script>">"

Правила реэкспорта:

	1. При реэкспорте по умолчанию, должны использоваться фигурные скобки.
	
	2. При реэкспорте всего модуля (через "*"), реэкспортируются только именованные элементы.

Пример реэкспорта:

	export {login, logout} from './helpers.js';		//	импортировать "login"/"logout" и тут же экспортировать.

	export {default as User} from './user.js';	//	импортировать экспорт по умолчанию как "User" и тут же экспортировать (обязательно используются фигурные скобки).

• Динамический импорт. Для создания динамического импорта используется выражение "import()", который возвращает промис, результатом которого становится объект модуля.
Его синтаксис:

	import(<модуль>)
		.then((<объект модуля>)=><объект модуля>)
		.catch((<объект ошибки>)=><объект ошибки>);

Пример использования динамического импорта:

	let modulePath = prompt("Какой модуль загружать?");

	import(modulePath)
		.then(obj => obj)
		.catch(err => err);

• Динамический импорт работает в обычных скриптах, он не требует указания 'script type="module"'.

• Общие правила модулей:

	1. Работа с модулями (обычными, не динамическими) проходит на верхнем уровне (не работает на уровне блоков "{}" (например в конструкции "if")).

	2. Импортированные модули работают в строгом режиме. Модули имеют локальную область видимости.

	3. В модулях внешний "this" не определен (равен "undefined", а не "window").

	4. Модули имеют объект "Import.meta", который содержит информацию о текущем модуле.
	
	5. Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом "defer".
	
	6. Атрибут "async" тега "<script>" работает во встроенных скриптах типа модули 'type="module"'.
	
	7. Внешние скрипты с одинаковым атрибутом "src" запускаются только один раз.
	
	8. Внешний скрипт, который загружается с другого домена, требует указания заголовков "CORS".
	
	9. Старые браузеры не понимают атрибут 'type="module"', для них скрипт дублируется и ставится атрибут "nomodule".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Устаревшая конструкция "with".

Конструкция "with" позволяет использовать в качестве области видимости для переменных произвольный объект. В современном "JavaScript от этой конструкции отказались.
С "use strict" она не работает, но её ещё можно найти в старом коде.

Синтаксис конструкции "with":

	with(<объект>) {<тело>}

	Любое обращение к переменной внутри "with" сначала ищет её среди свойств "<объект>", а только потом – вне "with".

Пример использования конструктора "with":

	var a = 5;

	var obj = {
		a: 10
	};

	with(obj) {
		alert( a );	//	10,	из "obj".
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Регулярные выражения "RegEx".


Метод "replace(<регулярное выражение>, <заменяемая строка>|<заменяющая функция>)".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ DOM. Структура.

• Структура наследования классов "DOM":

	Object	-	главный объект.

		EventTarget	-	это корневой "абстрактный" класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все "DOM"-узлы поддерживают так
		называемые "события".
		
			Node	-	также является "абстрактным" классом, и служит основой для "DOM"-узлов. Он обеспечивает базовую функциональность: "parentNode", "nextSibling",
			"childNodes" и т.д. (это геттеры). Объекты класса "Node" никогда не создаются.
			
				Text	-	текстовые узлы.
				
				Comment	-	узлы комментарии.
				
				Element	-	это базовый класс для "DOM"-элементов. Он обеспечивает навигацию на уровне элементов: "nextElementSibling", "children" и методы поиска:
				"getElementsByTagName", "querySelector". Браузер поддерживает не только "HTML", но также "XML" и "SVG". Класс "Element" служит базой для следующих классов:
				"SVGElement", "XMLElement" и "HTMLElement".
				
					HTMLElement	-	является базовым классом для всех остальных "HTML"-элементов. От него наследуют конкретные элементы:
					
						HTMLInputElement	-	класс для тега "<input>".
						
						HTMLBodyElement	-	класс для тега "<body>".
						
						HTMLAnchorElement	-	класс для тега "<a>".
						
						.
						
						.
						
						.
					
					SVGElement	-	это базовый класс для "SVG"-элементов.
					
					.
					
					.
					
					.
Подробнее в папке "Структура  наследования классов DOM".

• Основные типы узлов:

	document	-	"входная точка" в DOM.
	
	узлы-элементы	-	"HTML"-теги, основные строительные блоки.

	текстовые узлы	-	содержат текст.

	комментарии	-	иногда в них можно включить информацию, которая не будет показана, но доступна в "DOM" для чтения "JS".

Кроме обращения к конструктору "DOM" узла, есть еще способ получить тип "DOM" узла - свойство "nodeType". Основные значения свойства "nodeType":

	1	-	узел элемент.
	
	3	-	узел текст.
	
	9	-	объект документа.

Пример:

	document.body.nodeType	//	"1"	=>	элемент.
	
	document.body.firstChild.nodeType	//	"3"	=>	текст.
	
	document.nodeType	//	"9"	=>	объект документа.

• Получение имени тега и имени узла. Для этого есть свойства:

	<node>.nodeName	-	получить имя узла (любого узла).
	
	<node>.tagName	-	получить имя узла (узла-элемента - тега).

• Структура навигации в "DOM":

	document
	
		document.documentElement	-	<html>
		
			document.head	-	<head>
		
			document.body	-	<body>
			
				<parentNode>
				
					<childNode>

• "document.body" может быть равен "null", если документ еще не загружен.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ DOM. Свойства узлов - создание, вставка, удаление. 

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

• Свойства/методы узлов, а так же соответствующих объектов/конструкторов.

Создание узлов:

	Создание узлов-элементов:
	
		document.createElement(<тег>)	-	создание "<тег>" узла-элемента.
	
	Создание текстовых узлов:
	
		document.createTextNode(<текст>)	-	создание "<текст>" текстового узла.

Получение узлов по родственным связям:
Свойства у узлов для получения элементов или узлов:

	<node>.childNodes	-	получение объекта-коллекции с потомками (включая текстовые узлы).
	
	<node>.firstChild	-	получение первого потомка (включая текстовые узлы).
	
	<node>.lastChild	-	получение последнего потомка (включая текстовые узлы).
	
	<node>.nextSibling	-	получение следующего потомка у родителя (включая текстовые узлы).
	
	<node>.previousSibling	-	получение предыдущего потомка у родителя (включая текстовые узлы).
	
	<node>.parentNode	-	получение узла-родителя (включая текстовые узлы).
	
	<node>.children	-	получение объекта-коллекции с потомками, которые являются узлами-элементами.
	
	<node>.firstElementChild	-	получение первого потомка узла-элемента.
	
	<node>.lastElementChild	-	получение последнего потомка узла-элемента.
	
	<node>.nextElementSibling 	-	получение следующего потомка узла-элемента у родителя.
	
	<node>.previousElementSibling	-	получение предыдущего потомка узла-элемента у родителя.
	
	<node>.parentElement	-	получение родителя, являющимся узлом-элементом.
	
	<node>.closest("<CSS селектор>")	-	возвращает первый элемент родитель, соответствующий данному "CSS"-селектору.
	• Проход начинается с самого себя, а затем по родителям.
	
	<node>.contains(<DOM элемент/узел>)	-	возвращает булево значение, если указанный в параментрах элемент находится в самом элементе.

• Эти свойства являются только для чтения (нельзя перезаписать содержимое).
Объект, который вернет метод "childNodes" не является массивом, а перебираемым объектом-коллекцией.
Почти все объекты-коллекции являются живыми - отражают текущее состояние страницы (при добалении нового элемента на страницу, оно так же окажется и в коллекции.
Объекты-коллекции перебираются с помощью цикла "for ... of ...".

Получение узлов напрямую.
Можно получить элемент, обратившись к имени глобальной переменной без его объявления (указанный в атрибуте "id" тега), но только при вложенном коде ("Embedded"). Пример:

	<div id="elem"></div>

	<script>
	  elem.style.background = 'red';
	</script>

	Такое обращение не рекомендуется, так как используюьтся глобальные переменные.

Свойства/методы для получения/обращения узлов напрямую:

	document.getElementById("<id>")	-	получение элемента по "id".
	
	<node>.getElementsByTagName("<имя тега>")	-	ищет элементы с данным тегом и возвращает их живую коллекцию. Передав "*" вместо тега, можно получить всех потомков.
	
	<node>.getElementsByClassName("<имя класса>")	-	возвращает элементы, которые имеют данный "CSS"-класс. Возвращает живую коллекцию.
	
	document.getElementsByName("<имя>")	-	возвращает элементы с заданным атрибутом "имя". Возвращает живую коллекцию.
	
	<node>.querySelectorAll("<CSS селектор>")	-	возвращает все элементы внутри "<node>", удовлетворяющие данному "CSS"-селектору. Можно использовать даже псевдоклассы.
	Возвращает статическую коллекцию.
	
	<node>.querySelector("<CSS селектор>")	-	возвращает первый элемент, соответствующий данному "CSS"-селектору.
	
	<node>.matches("<CSS селектор>")	-	возвращает булево значение, если элемент удовлетворяет данному "CSS"-селектору.

	Для получения доступа к элементу, который выбран в панели разработчика, во вкладке "Elements", в консоли нужно указать "$0".
	Чтобы выбрать элемент уже в панели разработчика, во вкладке "Elements" через консоль, то нужно выполнить команду "inspect(<узел/элемент>)".

Свойства-методы для получения/установки/вставки/удаления содержимого элементов:
	
	<node>.append(<узлы или строки>)	-	добавляет узлы или строки в конец узла. Текст вставляется как текст, а не узел.
	
	<node>.prepend(<узлы или строки>)	-	добавляет узлы или строки в начало узла. Текст вставляется как текст, а не узел.
	
	<node>.before(<узлы или строки>)	-	добавляет узлы или строки до самого узла. Текст вставляется как текст, а не узел.
	
	<node>.after(<узлы или строки>)	-	добавляет узлы или строки после самого узла. Текст вставляется как текст, а не узел.
	
	<node>.replaceWith(<узлы или строки>)	-	заменяет узел заданными узлами или строками. Текст вставляется как текст, а не узел.
	
	<node>.clone(<boolean>)	-	клонирование узла. При булевом значении "true", узел будет клонирован полностью, включая дочерние элементы и атрибуты.
	При булевом значении "false" - без дочерних элементов.
	
	<node>.remove()	-	удаление узла.
	
	<node>.innerHTML	-	свойство для получения а так же для установки содержимого элемента. При установке данное свойство полностью переписыват содержимое элемента.
	При получении возвращаются все узлы (даже текстовые и комментарии), виде строки в одной строке.
	• Если "innerHTML" вставляет в документ тег <script> – он становится частью HTML, но не запускается.
	
	<node>.outerHTML	-	то же самое что и "innerHTML", но запись/получение происходит вместе с элементом, на котором было вызвано свойство.
	• Еще важным отличием является то, что в отличии от "innerHTML", "outerHTML" не изменяет содежимое переменной, в которой находится элемент. То есть если была объявлена
	переменная с элементом, то при использовании свойства "outerHTML" на этом элемента для записи, изменится документ, но содержимое переменной останется прежним.
	
	<node>.insertAdjacentHTML("<способ>", "<HTML строка>")	-	свойство для добавления "<HTML строки>" заданным способом. Способы:
	
		"beforebegin"	-	вставить "HTML" непосредственно перед узлом.

		"afterbegin" – вставить "HTML" в начало узла.

		"beforeend" – вставить "HTML" в конец узла.

		"afterend" – вставить "HTML" непосредственно после узла.
	
	<node>.insertAdjacentText("<способ>", "<текст>")	-	то же самое что и "insertAdjacentHTML", но вставляет текст.
	
	<node>.insertAdjacentElement("<способ>", <элемент>)	-	то же самое что и "insertAdjacentHTML", но вставляет элемент.

	<node>.textContent	-	чтение/запись только текста внутри элементов, за вычетом всех тегов.
	
	<node>.appendChild(<node>)	-	добавляет узел в конец дочерних узлов.
	
	<node>.insertBefore(<node>, <next sibling>)	-	добавляет узел перед указанным узлом.
	
	<node>.replaceChild(<node>,  <old child)	-	заменяет старый узел,но новый.
	
	<node>.removeChild(<node>)	-	удаляет узел.

	document.write("<HTML>")	-	вставляет в документ "HTML" текст, с полной заменой. Данный метод работает до полной загрузки страницы.

	<node-text>.data	-	получение/запись содержимого текстового узла.
	
	<node-text>.nodeValue	-	получение.запись содержимого текстового узла.

	• Все методы вставки удаляют елементы со старых мест.

	Конструктор создания "DOM" узлов, который послужит обёрткой для передачи списков узлов. После вставки, такой узел исчезает. Пример синтаксиса:

		let fragment = new DocumentFragment();

Работа с атрибутами. Имена атрибутов регистронезависимы. Значения атрибутов всегда являются строками. Методы:

	<node>.<пользовательский атрибут>	-	получение/запись значения пользовательского атрибута.

	<node>.hasAttribute(<атрибут>)	-	проверяет наличие атрибута.

	<node>.getAttribute(<атрибут>)	-	получает значение атрибута.

	<node>.setAttribute(<атрибут>, <значение>)	-	устанавливает значение атрибута.

	<node>.removeAttribute(<атрибут>)	–	удаляет атрибут.
	
	<node>.attributes	-	коллекция всех атрибутов.
	
	<node>.dataset.<пользовательский атрибут>	-	получение/запись значения пользовательского атрибута.
	
	Изменение значения атрибута "value" изменит и свойство "value", а изменение свойства "value" не изменит значение атрибута "value".

Работа со стилями:

	<node>.className	-	добавление нового класса элементу, с полной заменой.
	
	<node>.classList	-	возвращает перебираемый объект, содержащий список всех классов элемента. Методы:
	
		<node>.classList.add("<класс>")	-	добавление указанного класса.
		
		<node>.classList.remove("<класс>")	-	удаление указанного класса.
		
		<node>.classList.toggle("<класс>")	-	если указанного класса нет, то добавить. Иначе удалить.
		
		<node>.classList.contains("<класс>")	-	возвращает булево значение при наличии указанного класса у элемента.
	
	<node>.style	-	объект со всеми стилями. Свойства соответствуют свойствам "CSS". Для установки конкретного свойства стилю, оно указывается после "style.".
	Для установки множества стилей элементу, есть свойство "cssText":
	
		<node>.style.cssText	-	свойство для установки/получения всех стилей элементу, переданного в виде строки. Использование полностью заменяет уже существующие стили.
	
	Для получения стилей у определенного элемента, у объекта "Window" есть метод "getComputedStyle":

		getComputedStyle(<элемент>, "<псевдоэлемент>")	-	получение объекта, со свойствами-стилями указанного элемента. Если передан псевдоэлемент, то возвращается объект
		со свойствами-стилями этого псевдоэлемента.

Метрики (размеры, прокрутка):

	<node>.offsetParent	-	получение родителя элемента, относительно которого позиционирован элемент. Существует несколько ситуаций, когда "offsetParent" равно "null":
	
		1. Для скрытых элементов (с "CSS"-свойством "display:none" или когда его нет в документе).
		
		2. Для элементов "<body>" и "<html>".
		
		3. Для элементов с "position:fixed".
	
	<node>.offsetLeft	-	получение левого отступа элемента от родителя (число), относительно которого позиционирован элемент.
	
	<node>.offsetTop	-	получение верхнего отступа элемента от родителя (число), относительно которого позиционирован элемент.
	
	<node>.offsetWidth	-	получение полной внешней ширины элемента в числах (только видимой части).
	
	<node>.offsetHeight	-	получение полной внешней высоты элемента в числах (только видимой части).
	
	<node>.clientLeft	-	получение ширины левой стороны элемента включая полосы прокрутки в числах.
	
	<node>.clientTop	-	получение ширины верхней стороны элемента включая полосы прокрутки в числах.
	
	<node>.clientWidth	-	получение внутренней ширины элемента (только видимой части) без полос прокруток в числах.
	
	<node>.clientHeight	-	получение внутренней высоты элемента (только видимой части) без полос прокруток в числах.
	
	<node>.scrollWidth	-	получение полной внутренней ширины элемента (включая невидимую часть) в числах.
	
	<node>.scrollHeight	-	получение полной внутренней высоты элемента (включая невидимую часть) в числах.
	
	<node>.scrollLeft	-	получение невидимой ширины элемента в числах. Другими словами это на сколько элемент уже прокручен. Данное свойство так же можно изменить.
	Изменение приведет к прокрутке на заданную величину.
	
	<node>.scrollTop	-	получение невидимой высоты элемента в числах.  Другими словами это на сколько элемент уже прокручен. Данное свойство так же можно изменить.
	Изменение приведет к прокрутке на заданную величину.
	
	window.pageXOffset	-	получение числа горизонтальной прокрутки всей страницы.
	
	window.pageYOffset	-	получение числа вертикальной прокрутки всей страницы.
	
	window.scrollX	-	получение числа горизонтальной прокрутки всей страницы.
	
	window.scrollY	-	получение числа вертикальной прокрутки всей страницы.
	
	window.scrollTo(<pageX>,<pageY>)	-	прокручивает страницу абсолютно на заданные позиции "x" и "y".
	
	window.scrollBy(<x>,<y>)	-	прокручивает страницу относительно текущего положения на заданные велиины "x" и "y".
	
	<node>.scrollIntoView(<bool>)	-	прокручивает страницу до заданного элемента. Принимает булево значение. Если передан "true" (по умолчанию), то страница прокрутится
	к элементу так, что его верхняя сторона окажется на равне в верхней стороной страницы. Если передан "false", то то страница прокрутится к элементу так, что его нижняя
	сторона окажется на равне в нижней стороной страницы.
	
	window.innerWidth	-	ширина видимой части документа включая полосы прокрутки в числах.
	
	window.innerHeight	-	высота видимой части документа включая полосы прокрутки в числах.
	
	• Метрики для не показываемых элементов равны нулю.

Координаты.

	<node>.getBoundingClientRect()	-	получение объекта встроенного класса "DOMRect", со свойствами координат и метрик элемента в контексте окна для минимального по размеру
	прямоугольника,	который заключает в себе элемент. Свойства:
	
		x	-	соответствующая координата начала прямоугольника относительно окна.
		
		y	-	соответствующая координата начала прямоугольника относительно окна.
		
		width	-	ширина прямоугольника (может быть отрицательным).
		
		height	-	высота прямоугольника (может быть отрицательным).
		
		top	-	"y" координата верхней части границы прямоугольника.
		
		bottom	-	"y" координата нижней части границы прямоугольника.
		
		right	-	"x" координата правой части границы прямоугольника.
		
		left	-	"x" координата левой части границы прямоугольника.
	
	document.elementFromPoint(<x>,<y>)	-	возвращает самый глубоко вложенный элемент в окне, находящийся по координатам "x", "y".
	• Для координат за пределами окна метод "elementFromPoint" возвращает "null".

Навигация по таблице ("<table>"):

	<node>.rows	-	коллекция строк "<tr>" таблицы.
	
		<node>.cells	-	коллекция "<td>" и "<th>" ячеек.
		
			<node>.cellIndex	-	номер ячейки в строке.
		
		<node>.sectionRowIndex	-	номер строки "<tr>" в текущей секции "<thead>"/"<tbody>"/"<tfoot>".
		
		<node>.rowIndex	-	номер строки "<tr>" в таблице (включая все строки таблицы).
		
	<node>.caption	-	ссылки на тег "<caption>".
	
	<node>.tHead	-	ссылки на тег "<thead>".
	
	<node>.tFoot	-	ссылки на тег "<tfoot>".
	
	<node>.tBodies	-	коллекция элементов таблицы "<tbody>".

Прочие свойства и методы.

	<node>.hidden	-	получение/запись содержимого атрибута "hidden" в виде булевого значения.
	
	<node>.value	-	получение значения для тегов "<input>", "<select>" и "<textarea>" ("HTMLInputElement", "HTMLSelectElement"). Изменение значения атрибута "value"
	изменит и свойство "value", а изменение свойства "value" не изменит значение атрибута "value".
	
	<node>.href	-	полный адрес ссылки "href" для тега "<a>". При обращении к атрибуту "href", вернется относительный адрес.
	
	<node>.id	-	значение атрибута "id".
	
	<node>.dispatchEvent(<объект события>)	-	вызов пользовательского события на элементе.
	
	<node>.setPointerCapture(<pointerId>)	-	привязывает события с данным "pointerId" к указанному элементу. После такого вызова все события указателя с таким "pointerId"
	будут иметь "<node>" в качестве целевого элемента (как будто произошли над ним), вне зависимости от того, где в документе они произошли. Эта привязка отменяется:

		1. Автоматически, при возникновении события "pointerup" или "pointercancel".
		
		2. Автоматически, если "<node>" удаляется из документа.
		
		3. При вызове "<node>releasePointerCapture(<pointerId>)".
	
	<node>releasePointerCapture(<pointerId>)	-	отменяет действие "<node>.dispatchEvent(<объект события>)".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ События.

• Виды событий и своства/методы объекта "event":

	Общие свойства/методы объекта "event":
	
		type	-	тип события.
		
		currentTarget	-	элемент, на котором сработал обработчик. Значение – обычно такое же, как и у "this", но если обработчик является функцией-стрелкой или при помощи
		"bind" привязан другой объект в качестве "this", то можно получить элемент из "event.currentTarget".
		
		eventPhase	-	на какой фазе он сработал (погружение = 1, фаза цели = 2, всплытие = 3).
		
		stopPropagation()	-	прекращение всплытия/погружения события, выполняя обработчик события только на текущем элементе.
	
		stopImmediatePropagation()	-	прекращение всплытия/погружения события и прекращение выполнения обработчика даже на текущем элементе.
		
		preventDefault()	-	отменяет действие браузера по умолчанию.
		
		defaultPrevented	-	свойство, которое будет содержать булево значение в зависимости от того, было ли предотвращено действие браузера по умолчанию у
		дочерних элементов или нет.
		
		isTrusted	-	свойство содержащее булево значение в соответствии с тем, было ли событие пользовательски сгенерированным или нет.
		
		detail	-	свойство с объектом с произвольной информацией пользовательского события созданного с помощью конструктора "CustomEvent".
		
		shiftKey	-	содержит булево значение, в зависимости от того, была ли нажата клавища "Shift", или нет.

		altKey	-	содержит булево значение, в зависимости от того, была ли нажата клавища "Alt" (или "Opt" для Mac), или нет.

		ctrlKey	-	содержит булево значение, в зависимости от того, была ли нажата клавища "Ctrl", или нет.

		metaKey	-	содержит булево значение, в зависимости от того, была ли нажата клавища "Cmd" для Mac, или нет.

	События мыши:

		click	-	клик на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
		
		dblclick	-	двойной клик.

		contextmenu	-	клик на элемент правой кнопкой мыши.

		mouseover	-	наведение мыши на элемент. Данное событие всплывает. При данном событии считаются переходы на дочерние элементы.
		При данном событии у объекта "event" будут свойства "target", и "relatedTarget".
		
		mouseout	-	прекращение наведения мыши на элемент. Данное событие всплывает. При данном событии считаются переходы на дочерние элементы.
		При данном событии у объекта "event" будут свойства "target", и "relatedTarget".
		
		mouseenter	-	наведение мыши на элемент. Данное событие не всплывает. При данном событии переходы на дочерние элементы не считаются.
		При данном событии у объекта "event" будут свойства "target", и "relatedTarget".
		
		mouseleave	-	прекращение наведения мыши на элемент. Данное событие не всплывает. При данном событии переходы на дочерние элементы не считаются.
		При данном событии у объекта "event" будут свойства "target", и "relatedTarget".

		mousedown	-	нажатие кнопки мыши на элемент. Для этого события у объекта "event" будет свойтсво "which", с индексом нажатой кнопки.
		
		mouseup	-	отжатие кнопки мыши на элементе. Для этого события у объекта "event" так же будет свойтсво "which".

		mousemove	-	при движении мыши.
		
		contextmenu	-	правый клик мыши.
		
		Свойства/методы объекта "event" соответствующих событий:
		
			target	-	элемент, на котором произошло событие. Значения свойства зависят от типа события:
				
					mouseover/mouseenter	-	это элемент, на который курсор перешёл.
				
					mouseout/mouseleave		-	это элемент, с которого курсор ушёл.
					
					mousemove	-	элемент на который перешел курсор.
			
			relatedTarget	-	свойство для событий мыши "mouseover", "mouseout", "mouseenter", "mouseleave".  Значения свойства зависят типа события:
	
				mouseover/mouseenter	-	это элемент, с которого курсор ушел.
				
				mouseout/mouseleave		-	это элемент, на который курсор перешел.
				
				Свойство "relatedTarget" может быть "null", если указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера.
				Или же, наоборот, ушёл за пределы окна.
				
			clientX	-	"X" координата курсора в момент клика относительно окна, для событий мыши.
	
			clientY	-	"Y" координата курсора в момент клика относительно окна, для событий мыши.
			
			pageX	-	"X" координата курсора в момент клика относительно документа, для событий мыши.
			
			pageY	-	"Y" координата курсора в момент клика относительно документа, для событий мыши.
			
			screenX	-	"X" координата курсора в момент клика относительно экрана, для событий мыши.
			
			screenY	-	"Y" координата курсора в момент клика относительно экрана, для событий мыши.
			
			which	-	свойство которое содержит индекс нажатой кнопки мыши при событиях "mousedown", и "mouseup":
	
				1	-	левая кнопка мыши.
					
				2	-	средняя кнопка мыши.
				
				3	-	правая кнопка мыши.
	События указателя:
	
		pointerdown	-	аналогичен "mousedown".
		
		pointerup	-	аналогичен "mouseup".
		
		pointermove	-	аналогичен "mousemove".
		
		pointerover	-	аналогичен "mouseover".
		
		pointerout	-	аналогичен "mouseout".
		
		pointerenter	-	аналогичен "mouseenter".
		
		pointerleave	-	аналогичен "mouseleave".
		
		pointercancel	-	cобытие происходит, когда текущее действие с указателем по какой-то причине прерывается, и события указателя больше не генерируются.
		К таким причинам можно отнести:

			1. Указывающее устройство было физически выключено.
			
			2. Изменилась ориентация устройства (перевернули планшет).
			
			3. Браузер решил сам обработать действие, считая его жестом мыши, масштабированием и т.п.
		
		gotpointercapture	-	срабатывает, когда элемент использует метод "setPointerCapture" для включения захвата.
		
		lostpointercapture	-	срабатывает при освобождении от захвата метода "setPointerCapture" элемента явно с помощью "releasePointerCapture" или автоматически,
		когда происходит событие "pointerup"/"pointercancel".
		
		Свойства/методы объекта "event" соответствующих событий (те же что и у событий мыши, плюс дополнительные):
		
			pointerId	-	уникальный идентификатор указателя, вызвавшего событие.

			pointerType	-	тип указывающего устройства. Должен быть строкой с одним из значений:
			
				"mouse"
				
				"pen"
				
				"touch"

			isPrimary	-	равно "true" для основного указателя (первый палец в мульти-тач).

			width	-	ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно "1".
			
			height	-	высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно "1".
			
			pressure	-	степень давления указателя в диапазоне от "0" до "1". Для устройств, которые не поддерживают давление, принимает значение "0.5" (нажато) либо "0".
			
			tangentialPressure	-	нормализованное тангенциальное давление.
			
			tiltX
			tiltY
			twist	-	специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности.

	События на формах:

		submit	-	при отправке формы "<form>".
		
		focus	-	при активации поля "<input>".

	События клавиатуры:

		keydown	-	при нажатии клавищи.
		
		keyup	-	при отжатии клавищи.
		
		keypress	-	при нажатии и отжатии клавищи (устаревшее событие).
		
		keyCode	-	код клавищи (устаревшее событие).
		
		charCode	-	код клавищи по юникоду (устаревшее событие).
		
		Свойства/методы объекта "event" соответствующих событий:
		
			key	-	символ нажатой клавищи (включая регистр).
			
			code	-	идентификатор клавиши. Например "KeyZ" для клавищи "z" (регист не важен).
	
			repeat	-	свойство для клавищных событий "keydown" и "keyup", которое содержит булево значение, в соответствии тому, следует ли повторять событие при
			удержании клавищи.

	События документа:

		DOMContentLoaded	-	при полной загрузке "HTML", с построении "DOM" (работает только при использовании "addEventListener").
		
		scroll	-	событие прокрутки страцницы или элемента.

	События стилей:

		transitioned	-	при завершении анимации (работает только при использовании "addEventListener").
	
	События фокуса:
	
		focus	-	элемент в фокусе. Событие не всплывает.
		
		blur	-	элемент потерял фокус. Событие не всплывает
		
		focusin	-	элемент собирается быть в фокусе. Событие всплывает.
		
		focusout	-	элемент собирается потерять фокус. Событие всплывает.
	
	События перетаскивания:
	
		dragstart	-	при начале перетаскивания элемента или выделенного текста. Событие всплывает.
		
		drag	-	во время перетаскивания элемента или выделенного текста (событие будет провоцироваться продолжительно все время удерживания клавищи	мыши, до отпускания). Событие всплывает.
		
		dragend	-	при окончании перетаскивания элемента или выделенного текста (при отпускании клавищи мыши). Событие всплывает.
		
		dragenter	-	при наведении (вхождении) перемещаемого элемента или выделенного текста на элемент, на котором стоит данное событие. Событие всплывает.
		
		dragexit	-	Событие всплывает.
		
		dragleave	-	при прекращении наведения (вхождении) перемещаемого элемента или выделенного текста на элемент, на котором стоит данное событие. Событие всплывает.
		
		dragover	-	при продолжительном наведении элемента или выделенного текста на элемент, на котором стоит данное событие (каждые 50 миллисекунды когда курсор не перемещается
		быстрее чем в переделах 1-5 миллисекунды. Событие всплывает.
		
		drop	-	при "бросании" перетаскиваемого элемента на элемент, на котором стоит данное событие. Событие всплывает.
	
	Прочее:
	
		oncopy	-	срабатывает при копировании "Ctrl+C".

• Обработчики событий.

• Обработчики свойства "DOM" объекта. Синтаксис:
	
	<тег on<событие>="<обработчик>">
	
	или
	
	<node>.on<событие>	=	<обработчик>;

Такие обработчики начинаются с ключевого слова "on" и самого события. Такой обработчик находится у самого "DOM" элемента в свойствах. Способы объявления таких обработчиков:

	Через атрибут:
	
		<input value="Нажми меня" onclick="alert('Клик!')" type="button">
	
	Через свойство:
	
		<input id="elem" type="button" value="Нажми меня!">
		
		let elem = document.querySelector("#id");
		
		elem.onclick = function() {
			alert('Спасибо');
		};

При добавлении обработчика через атрибут, обязательно указывать скобки, так как создается функция с телом из значения атрибута.
При добавлении обработчика через атрибут, обработчику можно передать "this", что будет являться самим элементом, нод которы произошло событие:

	<button onclick="alert(this.innerHTML)">Нажми меня</button>

Можно назначить только один обработчик свойства "DOM" с конкретным событием.

• Обработчики "addEventListener".

Такие обработчики в отличии от предыдущих позволяют добавлять множество обработчиков на определенное событие. Так же такие в таких обработчиках само событие указывается как есть,
без приставки "on". Синтаксис:

	<node>.addEventListener(<событие>, <обработчик>[, <опции>])	-	где:
	
		"<событие>" - это имя события, "<обработчик>" - это функция обработчик или объект обработчик. Если на месте "<обработчик>" указан объект, то в нем должен быть метод "handleEvent":
	
			elem.addEventListener('click', {
				handleEvent(event) {
					alert(event.type + " на " + event.currentTarget);
				}
			});	
	
		"<обработчик>" - это обработчик или ссылка на него, "<опции>" это объект с	дополнительными свойствами:
		
			once	-	если "true", тогда обработчик будет автоматически удалён после выполнения.
			
			capture	-	фаза, на которой должен сработать обработчик, подробнее в подглаве "Всплытие и погружение". При использовании данного свойства можно не указывать
			свойство "capture", а сразу использовать его значения. Значения:
			
				false	-	событие будет поймано при всплытии (по умолчанию).
				
				true	-	событие будет перехвачено при погружении.
			
			passive	-	если "true", то указывает, что обработчик не собирается вызывать "preventDefault()".

• Удаление определенного обработчика события:

	<node>.removeEventListener(<событие>, <обработчик>[, <опции>]);

• Удаление обработчика события требует указания того же обработчика (ссылку на обработчик), и тех же дополнительных опций. Удалить обработчик без ссылки не удастся.

• Обработчику можно передать объект события, который будет содержать свойства события:

	Использование через атрибут:
	
		HTML:
		
			<div onclick="fn (event.type)"></div>
		
		JavaScript:
		
			fuction fn (type) {console.log(type) }
		
		Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: "function(event) { fn(event.type) }".
		То есть, её первый аргумент называется "event", а тело взято из атрибута.
	
	Использование через свойство:
	
		<div id="el">
		
		let el = document.querySelector("#el");
		
		el.onclick = function(event) {
			console.log(event.clientX)
		};
	
	Использование через "addEventListener":
	
		<div id="el">
		
		let el = document.querySelector("#el");
		
		el.addEventListener("click", function(event) {
			console.log(event.clientX);
		});

• Не важно, как обработчик объявляется (только обработчики через свойства элемента, и "addEventListener") – он получает объект события первым аргументом.
Этот объект содержит подробности о том, что произошло.

• Всплытие и погружение.

Есть три фазы цикла события:

	1. Первая - погружение - событие идет сверху вниз (от самого верхнего родителя до цели).
	
	2. Вторая фаза события это когда событие достигло целевого элемента.
	
	3. Третья фаза события это всплытие - событие идет снизу вверх (от цели до самого верхнего родителя).

• Всплытие.

Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
Всплытие начинается с элемента, на котором произошло событие и идет вверх постепенно до тега "<html>".
Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через "event.target". Отличия "this" от "event.target":

	event.target	-	это "целевой" элемент, на котором собственно и произошло событие, в процессе всплытия он неизменен.
	
	this	-	это "текущий" элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

• Почти все события всплывают, кроме события "focus".

Всплытие идёт с "целевого" элемента прямо наверх. По умолчанию событие будет всплывать до элемента "<html>" ("document.documentElement"), а затем до объекта "document",
а иногда даже до "window", вызывая все обработчики на своём пути.

• Прекращение всплытия.

Любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Примеры остановки всплытия:

	<body onclick="alert(`сюда всплытие не дойдёт`)">
		<button onclick="event.stopPropagation()">Кликни меня</button>
	</body>

А с помощью "event.stopImmediatePropagation()" можно прекратить всплытие/погружение события и прекратить выполнение обработчика даже на текущем элементе.

• Погружение.

Погружение начинается с тега "<html>", дальше "<body>", а дальше по порядку.

Чтобы поймать событие на стадии погружения, нужно в "addEventListener" использовать свойство "capture" в третьем агрументе:

	elem.addEventListener(<событие>,<обработчик>, {capture: true});
	
или короткий вариант - сразу указать значения свойства "capture", без самого объекта:
	
	elem.addEventListener(<событие>,<обработчик>, true);

Пример перехвата события погружения:

	let a = document.quertSelector("#parent");
	a.addEventListener('click', e=>{
		console.log("big");
		e.stopPropagation();
	}, true)


	let b = document.quertSelector("#child");
	b.addEventListener('click', e=>{
		console.log("small")
	});

В данном примере не удастся выполнить обработчик события нажатия мыши на дочернем элементе.

• Существует свойство "event.eventPhase", содержащее номер фазы, на которой событие было поймано.

• Итого. Сначала событие двигается вниз от корня документа к "event.target", по пути вызывая обработчики, поставленные через "addEventListener"(<событие>, <обработчик>, true)",
где "true" – это сокращение для "{capture: true}". Далее обработчики вызываются на целевом элементе. Далее событие двигается от "event.target" вверх к корню документа,
по пути вызывая обработчики, поставленные через "on<event>" и "addEventListener" без третьего аргумента или с третьим аргументом равным "false".

• Делегирование событий.

• Если у родителя есть много дочерних элементов, то вместо того чтобы добавлять обработчики каждому дочернему элементу, можно добавить один родителю, который получит элемент,
на котором произошло событие через свойство "event.target".
У такого метода есть недостаток - будут обработаны события даже у элементов внутри дочерних элеметов родителя, на котором стоит обработчик, и объектом "event.target" станет
этот элемент. Для решения данной проблемы можно воспользоваться методом "closest(<CSS селектор>)" у элемента, на котором произошло событие, с селектором по искомому элементу.

• Действия браузера по умолчанию.

Некоторые действия браузера по умолчанию:

	mousedown	-	начинает выделять текст (если двигать мышкой).
	
	click	-	'<input type="checkbox">' - ставит или убирает галочку в "input".

	submit	-	при нажатии на '<input type="submit">' или при нажатии клавиши 'Enter' в форме данные отправляются на сервер.

	keydown	-	при нажатии клавиши в поле ввода появляется символ.

	contextmenu	-	при правом клике показывается контекстное меню браузера.
	
	А так же переход по ссылкам и т.д.

• Отмена действий браузера по умолчанию. Способы:

	1. Через метод "preventDefault" объекта "event":
	
		<a href="/" onclick="event.preventDefault()">здесь</a>
	
	2. Через возвращение "false" в обработчике свойства "DOM" объекта:
	
		<a href="/" onclick="return false">Нажми здесь</a>
	
	3. <node>.addEventListener('click', e=>e.preventDefault())

Обычно значение, которое возвращает обработчик события, игнорируется кроме "return false".

Необязательная опция "passive" обработчика "addEventListener" сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных
устройствах, таких как "touchstart" и "touchmove", чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия
по умолчанию, например, к прокрутке.

• Обработка действий браузера по умолчанию на родительских элементах. Чтобы проигнорировать действия браузера по умолчанию на родительских элементах, эсли это действие отменятеся
в дочерних элементах, можно использовать "event.stopPropagation" на дочерних элементах. Но есть вариант получще - использовать свойство "event.defaultPrevented" на родительском
элементе, которое получит булево значение в зависимости от того было ли отменено действие по умолчанию на дочерних элементах или нет:

	child.oncontextmenu = function(event) {
		event.preventDefault();
		alert("Контекстное меню кнопки");
	};

	parent.oncontextmenu = function(event) {
		if (event.defaultPrevented) return;

		event.preventDefault();
		alert("Контекстное меню документа");
	};

Еще примеры отмены действия браузера по умолчанию:

	1. С "return false":

		<script>
			function handler() {
				alert("...");
				return false;
			}
		</script>

		<a href="http://w3.org" onclick="return handler()">w3.org</a>
	
	2. С "event.preventDefault()":
	
		<script>
			function handler(event) {
				alert("...");
				event.preventDefault();
			}
		</script>

		<a href="http://w3.org" onclick="handler(event)">w3.org</a>
	
	3. С "addEventListener" и "event.preventDefault":
	
		child.addEventListener("mousedown", event=> {
			event.preventDefault();
		});
		
		parent.addEventListener("mousedown", event=>{
			console.log(event.defaultPrevented);	//	true;
		});

• Генерация пользовательских событий.

• Можно не только назначать обработчики, но и генерировать события из "JavaScript" кода.

Конструктор событий "Event". Синтаксис создания пользовательского события:

	let event = new Event(<пользовательский тип>[, <объект опций>])	-	где "<пользовательский тип>" - это строковое имя пользовательского события,
	"<объект опций>" - это объект, состоящий из следующих свойств:
	
		bubbles	-	если "true", тогда событие всплывает, иначе нет (по умолчанию "false").
		
		cancelable	-	если "true", тогда можно отменить действие по умолчанию (по умолчанию "false").

		composed	-	если "true", тогда событие будет всплывать наружу за пределы "Shadow DOM" (по умолчанию "false").

Чтобы задействовать новосозданное пользовательское событие, нужно вызвать метод "dispatchEvent(<объект события>)" на элементе:

	let myEvent = new Event("click");
	
	<node>.dispatchEvent(myEvent);

• Чтобы выяснить является ли событие пользовательски сгенерированным или нет, у события есть свойство "isTrusted".

• При успешном задействии пользоватльского события, будет возвращено "true", а при неудачном (если на элементе стоит "addEventListener" с "event.preventDefault"),
то будет возвращено "false".

Чтобы перехватить пользовательское событие, нужно указать имя пользовательского события в "addEventListener".
Перехватить пользовательские события можно только с помощью "addEventListener", а не с помощью свойства "DOM" элемента или его атрибута.

Чтобы пользовательское событие всплыло, нужно обязательно указать свойство "bubbles" со значением "true".

Пример создания и перехвата пользовательского события с всплытием:

	<h1 id="elem">Привет из кода!</h1>

	<script>

		document.addEventListener("hello", function(event) {
			console.log("Привет от " + event.target.tagName);	//	Привет от H1
			console.log(event.isTrusted);	//	false
		});

		let event = new Event("hello", {bubbles: true});
		elem.dispatchEvent(event);

	</script>

• Для некоторых конкретных типов событий есть свои специфические конструкторы. Список некоторых из них:

	CustomEvent	-	конструктор новых пользовательских типов событий.

	FocusEvent	-	конструктор пользовательского события фокуса на элементе.

	MouseEvent	-	конструктор пользовательского события мыши.

	WheelEvent	-	конструктор пользовательского события скролла мыши.

	KeyboardEvent	-	конструктор пользовательского события клавищ клавиатуры.

• Специфические конструкторы позволяют указать свойства для данного типа события.
Например, "clientX"/"clientY" для события мыши:

	let event = new MouseEvent("click", {
		bubbles: true,
		cancelable: true,
		clientX: 100,
		clientY: 100
	});

Такую операцию нелья было провернуть на событии конструктора "Event".

Для генерации событий совершенно новых пользовательских типов событий, есть специальный конструктор "CustomEvent". У второго аргумента-объекта
есть дополнительное свойство "detail", в котором можно указывать информацию для передачи в событие. Свойство "detail" может содержать любые данные:

	<node>.addEventListener("hello", function(event) {
		alert(event.detail.name);
	});

	<node>.dispatchEvent(new CustomEvent("hello", {
		detail: { name: "Вася" },
		cancelable: true
	}));

• Использование "event.preventDefault" для пользовательски сгенерированных событий. Для таких событий, чтобы сработал "event.preventDefault", нужно
в объекте свойств пользовательского события указать свойство "cancelable" со значением "true":

	element.addEventListener("hello", function(event) {
		console.log(event.detail.name);						//	customName
		console.log(event.isTrustable);						//	false
		event.preventDefault();
	});
	
	element.dispatchEvent(new CustomEvent("hello", {
		bubbles: true,
		cancelable: true,
		detail: {name: "customName"}
	}));													//	false

• Модификаторы: "shift", "alt", "ctrl" и "meta".
При проверке нажатия клавищи "Ctrl", нужно еще и проверить нажатие клавищи "Cmd" (для Mac), так как у Mac вместо "Cmd" используется клавища "Cmd":

	if (event.ctrlKey || event.metaKey){}

• Движение мыши "mouseover"/"mouseout", "mouseenter"/"mouseleave".

События "mouseover" и "mouseout" всплывают. То есть если на родителе стоит обработчик события, и курсор перейдет на родитель, затем на дочерний элемент,
то целью события станет сначала родитель, затем снова родитель (так как идет всплытие), затем дочерний элемент. В таких событиях считываются переоды на
дочерние элементы (каждый раз будет сгенерировано соответствующее событие при переходах/уходах на дочерние элементы). В событиях "mouseenter" и "mouseleave"
такого не происходит. В них переходы на дочерние элементы не считаются и события не всплывают.

• События указателя.
События указателя расширяют события мыши. Можно заменить "mouse" на "pointer" в названиях событий и код продолжит работать для мыши,
при этом получив лучшую поддержку других типов устройств.

• При обработке переносов и сложных касаний, которые браузер может попытаться обработать сам. Для предотвращения этого, нужно отменять действие брауера и ставить
"touch-events: none" в CSS для элементов, с которыми идет взаимодействие.

• Захват указателя. При событии "pointerup", привязка метода "setPointerCapture" автоматически будет удалена. Пример:

	element.onpointerdown = function(event) {
	  thumb.setPointerCapture(event.pointerId);		//	все события указателя перенаправить на "element" (пока не произойдёт 'pointerup').
	};

	element.onpointermove = function(event) {
		//	все события указателя перенаправить на этот элемент (пока не произойдёт 'pointerup').
	};



https://learn.javascript.ru/form-elements











-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	










	
	
	
	
	
































































-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Список Методов/Функций "JavaScript" (Общее).


alert(<передаваемое содержимое>);

	Выведет окно с передаваемым ему содержимым при этом останавливая выполнение скрипта до тех пор пока не будет нажата кнопка "OK" (или "ЗАКРЫТЬ").
	Например:
	
		alert("Hello");

prompt(<текст для отображения в окне>, <содержимое по умолчанию (опционально)>);

	Отобразит модальное окно с переданным текстом, полем для ввода текста и кнопками "OK/Отмена". В поле для ввода можно указать значение по умолчанию.
	Данная функция вернет содержимое поля для ввода, если оно было заполнено, а если будет отменено, то вернет "null".
	Например:
	
		prompt("Укажите свой возраст", "18");
	
	Примечание:	Второй параметр является необязательным, но если не указать его, то "Internet Explorer" установит значение "undefined" в поле для ввода.
	
confirm(<вопрос>);

	Функция "confirm" отображает модальное окно с текстом вопроса и двумя кнопками "OK" и "Отмена". Данная функция вернет "true", если нажата кнопка "OK".
	В других случаях – "false".
	
	Например:
	
		confirm("Вам больше 18?");

isNaN(<аргумент>);

	Для проверки является ли аргумент "NaN".

isFinite(<аргумент>);

	Для проверки является ли аргуент конечным числом, т.е. не "NaN"/"Infinity"/"-Infinity".
	Есть большая разница между методом "isFinite(<аргумент>)" объекта "Number" и глобальным методом "isFinite(<аргумент>)".
	Метод объекта "Number" "isFinite(<аргумент>)" проверяет является ли аргумент конечным числом, без принудительной конвертации в числовой тип.
	Глобальный метод "isFinite(<аргумент>)" может конвертировать в числовой тип все, кроме "NaN"/"Infinity"/"-Infinity", а затем проверить является ли аргуент конечным числом.

setTimeout(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);

	Позволяет вызвать функцию один раз через определённый интервал времени. Аргументы, передаваемые в функцию не поддерживается в "IE9-".
	"setTimeout" с нулевой задержкой начинает выполняться только после выполнения текущего кода.
	
	Пример:
	
		function sayHi(phrase, who) {
			alert( phrase + ', ' + who );
		}

		setTimeout(sayHi, 1000, "Привет", "Джон");

	Рекурсивный "setTimeout":
	
		let timerId = setTimeout(function tick() {
			alert('tick');
			timerId = setTimeout(tick, 2000);
		}, 2000);

	"setTimeout" принадлежит объекту "Window", то есть контекст вызова "this" внутри функции вызываемой с помощью "setTimeout"
	будет указывать на объект "Window". "setTimeout" является элементом браузерного "API".

clearTimeout(<идентификатор "setTimeOut">);

	Отмена заданного интервала через идентификатор.
	
	Пример:
	
		let timerId = setTimeout(...);
		clearTimeout(timerId);

	"clearTimeout" является элементом браузерного "API".

setInterval(<функция или строка кода>, <задержка в миллисекундах (опционально)>, <аргументы (опционально)>);

	Позволяет вызывать функцию много раз через определённый интервал времени. В большинстве браузеров, включая "Chrome" и "Firefox",
	внутренний счётчик продолжает тикать во время показа "alert"/"confirm"/"prompt".
	Рекурсивный "setTimeout" позволяет задать задержку между выполнениями более точно, чем "setInterval".
	
	"setInterval" принадлежит объекту "Window", то есть контекст вызова "this" внутри функции вызываемой с помощью "setInterval"
	будет указывать на объект "Window".
	
	"setInterval" является элементом браузерного "API".

clearInterval(<идентификатор "setInterval">);

	Отмена заданного интервала через идентификатор.
	
	Пример:
	
		let intervalId = seInterval(...);
		clearInterval(intervalId);

	"setInterval" является элементом браузерного "API".

• "Eval" выполнение строки кода. "eval" выполняет строку кода и возвращает результат последней инструкции.
Встроенная функция "eval" позволяет выполнять строку кода. В строгом режиме у "eval" имеется своё лексическое окружение.
Поэтому функции и переменные, объявленные внутри "eval", нельзя увидеть снаружи.

	Синтаксис:

		eval(<исполняемый код>);

	Пример:

		eval("console.log('Test')");	//	Test
	
	Код в "eval" выполняется в текущем лексическом окружении, поэтому ему доступны внешние переменные:
	
		let a = 1;

		function f() {
			let a = 2;
			eval('console.log(a)'); // 2
		}

		f();
	
	Если код внутри "eval" не использует внешние переменные, то лучше вызывать его так – "window.eval(<исполняемый код>)".

• Методы и свойства объекта "Math":

	Math.floor();

		Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
		
	Math.ceil();

		Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
		
	Math.round();

		Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
		
	Math.trunc();
	
		Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
		Не поддерживается в "Internet Explorer".
		
	Math.random();
	
		Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1).
		
	Math.max(<аргументы>);
	Math.min(<аргументы>);
	
		Возвращает наибольшее/наименьшее число из перечисленных аргументов.
		
	Math.pow(<число>, <степень>);
	
		Возвращает число, возведённое в степень.

getEventListerners(<элемент>);

	Метод "getEventListerners" является частью браузерного "API", работая только в консоли, и не работает если он используется в файле "js".
	Удаление "EventListener", если не известны функции, переданные в него. Например:

		let keyJListener = getEventListeners(document).keypress[2];		// Key "J" listener definer
		let keyKListener = getEventListeners(document).keypress[1];		// Key "K" listener definer

		document.removeEventListener("keypress", keyJListener.listener, keyJListener.useCapture);	// Key "J" listener remover
		document.removeEventListener("keypress", keyKListener.listener, keyKListener.useCapture);	// Key "K" listener remover

		В данном примере удаляются "EventListener" для нажатия клавищ "J" и "K" на сайте "9gag.com". Данный пример работает только если
		этот код будет вставлен непосредственно в консоль отадки браузера, и не будет работать если будет вставлен в файл скрипта "js".

		Подробнее об источнике:

			"https://stackoverflow.com/questions/26845535/removeeventlistener-without-knowing-the-function"

			Содержание источника:

				"getEventListeners(window)" will return a map of events and their registered event listeners.

				So for "DOMContentLoaded" event for example you can have many event listeners.
				If you know the index of the listener you want to remove (or if there exists only one), you can do:

					var eventlistener = getEventListeners(window)["DOMContentLoaded"][index];

					window.removeEventListener("DOMContentLoaded", eventlistener.listener, eventlistener.useCapture);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

• Window

	unhandledrejection














































































