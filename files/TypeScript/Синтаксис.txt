-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Установка и настройка.

Для установки "TypeScript" нужно ввести команду:

	npm i -D typescript

Далее будут доступны команды консоли через префикс "tsc":

	tsc -v
	
		Вывести версию "TypeScript".
	
	tsc --init
	
		Проинициализировать конфигурационный файл "tsconfig.json".
		
	tsc --watch
	
		Компилировать при каждом изменении файлов в директории проекта.

• Настройка конфигурационного файла "tsconfig.json". Свойства:

	compilerOptions
	
		Поле, которое находится в конфигурационном файле по умолчанию. Значением является объект где настраивается компилятор "TypeScript".
		
		Некторые свойства поля "compilerOptions":
	
			outDir
			
				Директория, куда будет складываться компиляция (обычно "./dist"). При использовании "Webpack" нет необходимости в данной настройке.
				
			rootDir
			
				Директория проетка (откуда будут браться файлы для компиляции (обычно "./src")). При использовании "Webpack" нет необходимости в данной настройке.
			
			target
			
				Версия "Javascript", в которую будет компилироваться "TypeScript". По умолчанию "es6".
			
			sourceMap
			
				Включение соурсмэпов. При использовании соурсмапов "Webpack" рекомендутеся пользоваться данной функцией. Значением является булево значение.
				
			noEmitOnError
			
				Опция для настройки компиляции в случае синтаксической ошибки (например не компилировать код при наличии ошибок в коде). Значением является булево значение.
				Данной опции по умолчанию нет в конфигурационном файле.
			
			noImplicitAny
			
				Запрещение неявного использования типа "any". По умолчанию включена. Значением является булево значение.
			
			noUnusedLocals
			
				Запрещение неиспользованных локальных переменных. Значением является булево значение.
				
			noUnusedParameters
			
				Запрещение неиспользованных параметров функций. Значением является булево значение.
	
	exclude
	
		Можно добавить дополнительное поле "exclude", значением которого будет массив в котором будут перечислены пути для исключения компиляции. По умолчанию
		папка "node_modules" игнорирутеся.
	
	include
	
		Можно добавить дополнительное поле "include", значением которого будет массив в котором будут перечислены пути для включения в компиляцию.
		
	files
	
		Можно добавить дополнительное поле "files", значением которого будет массив в котором будут перечислены конкретные файлы для включения в компиляцию.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа с "Webpack".

Для работы с "Webpack" помимо установки самого "TypeScript" ("npm i -D typescript") понадобится еще и лоадер для "Webpack", который называется "ts-loder":

	npm i -D ts-loader

Далее после установки нужно добавить лоадер в список лоадеров "Webpack", чтобы этот лоадер следил за файлами "TypeScript" и компилировал их:

	module.exports = {
		module: {
			rules: [
				{
					test: /\.ts$/,
					exclude: /node_modules/,
					use: 'ts-loader'
				}
			]
		}
	}

Соответственно входным файлом нужно указать входной файл "TypeScript", а выходным файлом файл "Javascript":

	module.exports = {
		entry: './src/index.ts',
		output: {
			path: './dist',
			filename: 'bundle.js',
		}
	}

Так же нужно добавить расширения файлов скриптов по умолчанию, для работы импортов без добавления расширения в конце имени импортируемого файла:

	module.exports = {
		resolve: {
			extensions: ['.ts', '.js']
		},
	}


• Если используется транспилятор "Babel", то нет необходимости в установке "TypeScript", можно пользоваться соответствующмим пресетом в "Babel".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Ипортирование.

При импортирование сущностей (наприммер картинок), нужно пользоваться функцией "require", так как простое импортирование через "import" не будет работать.
Данное правило не качается модулей.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Базовые типы данных.

Базовые типы данных указываются через двоеточие после имени переменной. Типы данных:

	null
	
	undefined

	string
	
	boolean
	
	number
	
	any
	
		Данный тип данных определяет что типом может быть любой тип данных.
	
	void
	
		Отсутствующий тип. Данный тип обычно указывается у функций, которые ничего не возвращают.
	
	never

		Данный тип указывается у функций, которые могут вернуть ошибку или постоянно находятся в процессе.
		
	unknown
	
		Неизвестный тип данных, который мможет быть получен например от промисов.
		
	object
	
		Тип объект.
	
	Function
	
		Тип функция.
	
Примеры:

	const name: string = "Alex";
	
	const n: number = 123;
	
	const bool: boolean = false;

• Типом может быть любая сущность (примитивы, объекты, типы юнионы, интерфейсы, функции, классы, таплы, енамы и т.д.).

• Конкретизированные типы.

	Типом может быть какая либо конкретная сущность. Например если указать конкретный тип (напримет примитив строку "hello"), то тип может быть равен только этому значению.
	И так же в остальных типах.

• Так же типом можно указать имя класса, который будет означать что сущность является типом этого класса.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Пользовательские типы данных.

• Можно создать пользовательские типы данных, через ключевое слово "type":

	type Login = string;
	
• Множественные типы данных (юнионы). Можно перечислить несколько типов данных через символ "|":

	type ID = string | number;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Операторы:

	keyof
	
		Данный оператор типизирует сущность на основе ключей его аргумента. То есть сущность типизированная с помошью данного оператора, может иметь только значения, которые равны
		именам ключей объекта (или интерфейса), указанного в качестве аргрумента. Приммер:
		
			interface Person {
				name: string;
				age: number;
			}
			
			type PersonKeys = keyof Person;		//	 Значениями типа могут быть только строки "name" и "age".
			
			const key1: PersonKeys = 'name';
			const key2: PersonKeys = 'age';
			const key3: PersonKeys = 'color';	// Ошибка, нет такого ключа в типе "PersonKeys".
			
	type
	
		Подробнее в глвае "Пользовательские типы данных".
	
	Exclude<Type, ExcludedUnion>
	
		Исключительное объявление типов. На месте "Type" будут типы которые будут включены, а на месте "ExcludedUnion" будут типы, которые будут исключены из "Type".
		Сами типы в обоих аргументах перечисляется через символ "|".
		Пример:
		
			type T0 = Exclude<"a" | "b" | "c", "a">;	//	Здесь 'T0' будет иметь типы "a", "b", "c", но из этих типо будет исключен тип "a", то есть в результате 'T0' будет иметь только типы "b", "c".
		
		Еще пример с использованием интерфейса и оператора "keyof":
		
			interface User {
				_id: string;
				name: string;
				age: number;
				createdAt: Date;
			}
			
			type T0 = Exclude<keyof User, "_id" | "createdAt">;	// Будет иметь только типы "name" и "age".
	
	Pick<Type, IncludedUnion>
	
		То же самое что и "Exclude<Type, ExcludedUnion>", но действует наоборот. То есть будут выбраны только те типы, указанные в аргументе "IncludedUnion".
	
	Partial<Type>
	
		Частичное использование типа (интерфейса). Подробнее в главе "Дженерики" в подглаве "Дженерики функций".
	
	Required<Type>
	
		Установка типа, все поля которого становятся обязательными (даже опчиональные, указанные через оператор "?").
		
	Record<Keys, Type>
	
		Установка типа, с набором свойств из типа указанного на месте "Keys", которые должны будут соответствовать типу (интерфейсу) указанного на месте "Type".
		То есть если к примеру использовать данную утилиту в отношении к объекту, то у объекта должны будут иметься свойства, указанные в типе "Keys", и эти свойства
		должны будут соответствовать типу (интерфесу) указанного в "Type".
	
	Readonly<Type>
	
		Установка типа как типа только для чтения. Пример:
		
			const cars: Readonly<Array<string>> = ['Ford', 'Audi']
			cars.shift();	//	Вызовет ошибку, так как метод "shift" меняет исходный массив, а оператор "Readonly" запретил изменения этого типа.

			interface Car {
				model: string
				year: number
			}
			
			const ford: Readonly<Car> = {
				model: 'Ford',
				year: 2020
			}
			
			ford.model = 'Ferrari';		// Вызовет ошибку, так как меняется свойство объекта, а оператор "Readonly" запретил изменения этого типа.
		
	|
	
		Оператор перечисления типов (например в юнионах).
	
	&
	
		Оператор объединения дженериков. Подробнее в главе "Дженерики".
	
	?
	
		Оператор "?" ставится после имени переменной, если эта переменная опциональная. Так же этот оператор ставится после имени переменной, когда идет обращение к свойству или
		к методу.
		
		Пример с опциональным аргументом функции:
		
			function concat(a: number, b?: string): string {
				if(!b) return a.toString();

				return a.toString() + b;
			}

			const a = concat(1, 'hello');	//	1hello
			
			const b = concat(1);	// 1
			
		Пример с вызовом метода опциональной переменной:
		
			class Categories {
				goToCategories(): void {
					this.currentCategory?.hide();		// Здаесь вызов метода "hide" произойдет при наличии самого объекта "currentCategory".
				}
			}
	
	!
	
		Устранение "null" и "undefined" постфиксом "!" ("Non-null Assertion Operator"). Данный оператор ставится после имени переменной, чтобы убрать у него типы "null" и "undefined".
		К примеру получение "HTML" элемента посредством квери селектора, вернет тип "Element | null". У такого элемента нельзя будет обращаться к свойствам или методам
		без проверки истинности на "null" или "undefined". Добавив оператор "!" после выбираемой сущности, можно убрать тип "null" или "undefined" из его списка типов:
		
			const test = document.querySelector('as');	//	У "test" будет тип "Element | null".

			test.remove();	//	 вызовет ошибку, так как "test" может быть "null".
			
			Исправить это можно добавив оператор в конце селектора или после имени переменной, когда идет обращение к его свойству или методу:
			
				const test = document.querySelector('as')!;  // Теперь у "test" будет только тип "Element".

				test.remove();	// Оператор "!" можно было добавить после имени переменной ("test!.remove()").
		
		Пользоваться данным оператором не рекомендуется, так как не использование проверок на истинность сущности может привести к ошибкам во время выполнения кода.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Таплы (Tuples).

Таплы типизируют массив. Типизация массива будет в таком порядке, в каком она указана в тапле.

Есть два вариаанта создания таплов:

	1. Указанием сразу после имени переменной:
	
		const arr1: [string, number, string] = ['a', 1, 's'];
	
	2. Через "type":
	
		type ARR = [string, number, string];

		const arr: ARR = ['a', 1, 's'];
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типизирование массивов.

Массивы можно типизировать следующими способами:

	1. Через явное указание типа у литерала массива:
	
		const arr1: string[] = ['a', 'b', 'c'];
		
		const arr2: number[] = [1, 2, 3];
		
		const arr3: boolean[] = [true, false];
		
	2. Через пользовательские типы данных:
	
		type Name = string;
		
		const names: Name[] = ['Alex', 'Nick', 'John'];

	3. Через дженерики (подробнее в главе "Дженерики"):
	
		const arr1: Array<string> = ['a', 'b', 'c'];
		
		const arr2: Array<number> = [1, 2, 3];
		
		const arr3: Array<boolean> = [true, false];

	4. Через Таплы (Tuple) (подробнее в главе "Таплы (Tuples)"):
	
		const person: [string, number] = ['Alex', 12345];

• Можно типизировать массив с несколькими типами, указав типы в клуглых скобках:

	const arr: (string | number | boolean)[] = [1,2, '1', true];

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типизирование функций.

При типизировании функций, типизируются передаваемые аргументы, а так же то, что возвращает эта функция. Значение, которая возвращается функцией типизируется добавлением типа
после двоеточия после круглых скобок функции:

	function sum(arg1: number, arg2: number): number {
		return arg1+agr2;
	}

• Если функция ничего не возвращает, то указывается тип "void":

	function greet(name: string): void {
		console.log(name);
	}

• Если функция возвращает ошибку, или постоянно находится в процессе, то указывается тип "never":

	function fn(): never {
		throw new Error();
	}

• Можно указать пользовательский тип (как интерфейс), который будет возвращаеть функция (например объект):

	function sum(a: number, b: number): {a: number, b: number, sum: number} {
		return {a, b, sum: a+b}
	}

• Типизирование стрелочных функций. Синтаксис таков: после иммени фукнции стивится двоеточие, после него скобки. В этих скобках типиизируются входные аргументы, если они есть.
Затем ствится "=>" и после него указывается возаразщаемый функцией тип. Пример:

	const fn:(name: string) => string = (name) => {
		return 'hello' + name;
	}

• Один из способов типизации функций через интерфейсы:

	interface FN {
		(n: number): boolean;
	}
	
	const fn: FF = function (n) {
		console.log(n);
		return true;
	};

• Перегрузки функций. Функция может быть типизирована под разные вариаанты вызова.
Для этого функция пишется и типизируется для конкретного случая как обычная функция, но без тела функции (без фигурных скобок).
Вариантов типизации вызова одной функции может быть много (больше одного). В конце перечисления перегрузок, должна быть типизация вызова функции, но уже с телом функции.
Пример:

	function makeDate(timestamp: number): Date;
	function makeDate(m: number, d: number, y: number): Date;
	function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
	  if (d !== undefined && y !== undefined) {
		return new Date(y, mOrTimestamp, d);
	  } else {
		return new Date(mOrTimestamp);
	  }
	}
	const d1 = makeDate(12345678);
	const d2 = makeDate(5, 5, 5);
	const d3 = makeDate(1, 3);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Типизирование объектов.

Объекты можно типизировать простым способом через литерал объекта:

	const obj: {a: number, b: string} = {a: 12, b: '12');

Так же можно объекты можно типизировать через оператор "type", через интерфейсы, и через дженерики. Подробнее в соответствующих главах.

• Объектам при инициализации автоматически присваивается тип, который равен самому себе.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Интерфейсы.

Интерфейсы нужны для типизации объектов и классов (и функций).

Интерфейсы объявляются через ключевое слово "interface", затем пишется имя интерфейса (принято с заглавной буквы), затем идет сам интерфейс в фигурных скобках (без присваивания "=").
В самом интерфейсе могут пыть перечислены поля объекта, и его типы. У этих полей могут быть модификаторы.
Сами поля перечисляются через точку с запятой ";", а не с запятой, как в объектах.

• Модификаторы полей интерфеса:

	readonly
	
		Поле только для чтения.

Пример:

	interface Rect {
		readonly id: string;
	}

Поля интерфейса так же могут быть объектами, которые так же типизируются:

	interface Rect {
		size: {
			width: number;
			height: number;
		}
	}

• Динамические поля. У объектов можно установить динамическую типизацию полей, если типы ключей и значений одинаковы. Для этого используется литерао массива, в которомм указывается
ключевое слово с произвольнымм именем (напрмимер "key") для ключа, затем после него идет тип этого ключа через двоеточие. На месте "key" может быть что угодно (наприммер "propertyName",
или любое другое, желательно осмысленное значение). После литерала массива идет тип значения ключа через двоеточие:

	interface Obj {
		[key: string]: string;
	}

• Опциональные поля.

Чтобы добавить необязательное (опциональное) поле, после имени поля нужно поставить знак вопроса:

	interface Rect {
		color?: string;
	}

• Методы в интерфейсах.

Есть два пособа типизировать методы в интерфейсе:

	1. Простой, использующий синтаксис типизации обычных функций:

		interface A {
			greet(name: string): string;
		}
	
	2. С использованием синтаксиса типизации стрелочных функции:

		interface A {
			greet: (name: string) => string;
		}

• Наследование интерфейсов.

	Можно создавать новые интерфейсы, которые будут наследовать старые. Делается это через ключевое слово "extends":

		interface Rect {
			id: string;
			size: {
				width: number;
				height: number;
			}
		}
		
		interface RectWithArea extends Rect {
			getArea: () => number;
		}

• Один из способов типизации функций через интерфейсы:

	interface FN {
		(n: number): boolean;
	}
	
	const fn: FF = function (n) {
		console.log(n);
		return true;
	};

• Имплементация интерфейсов у классов.

	После создания интерфейса для класса, его дальше можно использовать через ключевое слово "implements":

		interface IClock {
			time: Date;
			setTime(date: Date): void;
		}
		
		class Clock implements IClock {
		
			time: Date = new Date();
			
			setTime(date: Date): void {
				
			};
		
		}
	
	• Можно имплементировать класс от нескольких интерфейсов. Перечисляться интерфесы будут через запятую:
	
		class MyClass implements InterfaceOne, InterfaceTwo {
			...
		}

	Это не обязательно, так как сам класс уже является типом.

• Дженерики интерфейсов. Подробнее в главе "Дженерики" в подглаве "Дженерики интерфейсов".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Енамы (Enums).

Енамы это структуры данных, для упрощения пользования именованных констант. Позволяет определить набор именнованных констант, которые описывают определенные состояния.

Объявляются енамы через ключевое слово "enum", затем идет имя енама (принято с заглавной буквы), после чего идет литерал объекта (без присваивания "=").
Свойства внутри енама перечисляются через запятую, а значения присваиваются через знак равно "=".

Есть два способа пользования енамами:

	1. Простой способ, по ключу и индексу. Если обратиться к ключу енама, то будет возвращен индекс ключа (индексы начинаются с 0). Если обратиться к индексу енама,
	то будет возвращен его ключ:
	
		enum Membership {
			Simple,
			Standard,
			Premium
		}
		
		const membership = Membership.Standard;	//	1
		const membershipReverse = Membership[0];	//	'Simple'.
	
	2. Способ с использованием ключа и значения. Если обратиться к ключу енама, то будет возвращено его значение. Если обратиться к значению енама,
	то будет возвращен его ключ:
	
		enum Seasons {
			Winter = 'Cold',
			Summer = 'Hot',
		}
		
		const winter = Seasons.Winter;	//	'Cold'.
		const cold = Seasons['Cold'];	//	'Winter'.

• При транспиляции кода в "Javascript", енамы превращаются в функции, которые возвращают объект. Чтобы при транспиляции енамы превратились в перемменные (константы), нужно перед
"enum" добавить "const":

	const enum Seasons {
		Winter = 'Cold',
		Summer = 'Hot',
	}
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Классы.

• Типизация свойств инстанса класса.

• Модификаторы свойств класса:

	static	-	статическое свойство или метод, который доступен только самому классу, а не его потомкам. К этим свойствам/методоам может быть получен доступ изнутри самого класса,
	они наследуются другими классами.

	public	-	публичный (по умолчанию). Наследуются другими классами и инстансами.

	protected	-	видны только внутри класса, и наследуются другими классамми. Не доступен инстансам.

	private	-	видны только внутри данного класса, и не наследуются другими классами. Не доступен инстансам.

	readonly - только для чтения. Свойство с данным модификатором можно перезаписать только в самом конструкторе.

Типизация свойств инстанса класса а так же установка его модификатора происходит в начале литерала класса, когда как сами свойства создаются и присваиваются в конструкторе
(кроме свойств которые пишутся вне конструктора):

	class Cat {
		readonly type: string;
		readonly legs: number = 4;
		
		constructor(animalType: string) {
			this.type = animalType;
		}
	}

• Если входные параметры конструктора класса далее будут свойствами инстанса этого класса, то есть упрощенный способ типизации этих свойств - можно этии свойства типизировать сразу
в конструкторе. Для этого достаточно добавить свойству модификатор:

	Запись:

		class Animal {
			constructor(readonly type: string) {
			}
		}
	
	идентична записи:
	
		class Animal {
			type: string;
			constructor(type: string) {
				this.type = type;
			}
		}
	
• Типизация методов. Типизация методов в классах ничем не отличается от типизации методов обычных объектов, за исключением того, что можно добавить модификаторы, а так же
то что методы могут быть аксессорами (геттеры и сеттеры).

• Абстрактные классы и абстрактные свойства/методы.

	Абстрактные классы, это базовые классы, чтобы от них наследовались другие классы. Инстансов таких абстрактных классов создавать нельзя, они нужны только для того чтобы от
	них	наследовать другие классы. Абстрактные классы это по сути интерфейсы того, как должны выглядеть классы потомки.
	
	Абстрактные методы/свойства в абстрактном классе, это методы/свойства, которые обязательно должны быть реализованы в классах потомках.
	В абстактных классах ммогут быть и обычные (не абстактные) методы/свойства, которые нужны для реализации внутреннего функционала абстактного класса, и они не обязательны
	к реализации в классах потоммках.

	• Отличия от интерфейсов.
	
	Абстрактные классы и интрефейсы схожи.
	Абстрактные классы доступны во время выполнения кода, а интерфейсы только по время компиляции.

	Подробнее "https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Дженерики.

Дженерики, это подстраивающиеся типы данных. Тип данных, который будет указан в дженерике, будет означать что объект будет состоять из элементов указанного типа данных в дженерике.

Дженерики используются на основе уже существующих объектов, или можно создать свой. Сам тип указывается в треугольных скобках "<>", который идет после имени объекта (класса или
функции). Примеры использования дженерика на основе существующего класса:

	const arr1: Array<string> = ['a', 'b', 'c'];
	
	const arr2: Array<number> = ['a', 'b', 'c'];

Дженерик "Array<string>" означает что типизируется инстанс класса "Array", то есть массив, и он будет состоять из строк.

Пример дженерика на основе промиса:

	const promise = new Promise<string>(resolve => {
		setTimeOut(() => resolve("Promise Resolved"), 2000);
	});
	
	promise.then(response => console.log(response));	//	 "response" будет типа "string".
	
	В данном примере дженерик "<string>" будет подставлен в промис, и выполненный проммис будет типа "string". Если в данном примере не был бы указан дженерик, то
	тип выполненного промиса был бы "unknown".
	
	Есть альтернативный вид записи дженерика в примере выше, где дженерик указывается после имени переменной, а не после самого объекта "Promise":
	
		const promise: Promise<string> = new Promise (resolve => {
			setTimeOut(() => resolve("Promise Resolved"), 2000);
		});
		
		promise.then(response => console.log(response));	//	 "response" будет типа "string".

• Дженерики функций.

	Если необходимо динамически типизировать сущность возвращаемую функцией на основе типа принимаемых параметров, то можно воспользоваться дженерикамии функций.
	
	До круглых скобок функции указывается пользовательский дженерик внутри треугольных скобок "<>" (например "<Type>"), который будет означать что функция работает с этим типом.
	Этот тип в дальнейшем будет равен типу принимаемого аргрумента, который записан с виде дженерика. Другими словами эта запись служит как переменная, и примет значение типа,
	которая далее будет указана в типе входных параметров, и далее будет означать что функция работает с этим типом. Дженерик указанный до круглых скобок функции будет автоматически
	подстраиваться под тип передаваемых аргументов (к примеру функция принимает массив со строками (тип "sting[]")), и у этого аргумента будет дженерик "Type[]"
	("[]" - означает что это массив состоящий из таких типов) (который в данном примере будет равен типу массива со строками "string[]"),
	на основе чего подстроится дженерик самой функции, который был указан в треугольных скобках после имени фукнции ("<Type>"), и будет означать что (в данном примере)
	функция работает с типом "string[]". Далее таким же образом подстроится и тип возвращаемого значения на основе типа принимаемого значения.
	
	Не обязательно писать "Type", вместо него может быть любое имя дженерика (например короткая запись в виде символа "Т"), главное чтобы запись дженерика была одинакова везде
	(после имени функции, в типе принимаемых аргументов, в типе возращаемой сущности).
	
	Пример дженерика функции:
	
		const arrOfStrings: string[] = ['a', 'b', 'c'];
		
		const arrOfNumbers: number[] = [1, 2, 3];
	
		function reverse<T>(array: T[]): T[] {		// "array: T[]" в круглых скобках функции означает что тип принимаемого значения будет подставлен в дженерик "T[]", и чему дальше будет равен дженерик во всей функции.
													//	Дженерик "<T>" после имени функции примет значение дженерика "T" входного аргумента "array", этим же значением будет и значение "T[]" на выходе функции.
		
			return array.reverse();
		
		}
		
		reverse(arrOfStrings);	//	Возвращаемый тип будет "string[]", так как этот же тип был получен на входе функци, и на основе чего подстроилась вся функция.
		
		reverse(arrOfNumbers);	//	Возвращаемый тип будет "number[]", так как этот же тип был получен на входе функци, и на основе чего подстроилась вся функция.
	
	• Можно вручную передать конкретный тип (интерфейс) дженерику функции во время его вызова для лучшей работы типизации:
	
		interface MyInterface {
			name: string;
			color: string;
		}
		
		function MyFn<T>(obj: T): T {
			...
		}
		
		const myObj: MyInterface = {
			name: "Alex",
			color: 'red',
		};
		
		myFn<MyInterface>(myObj);
	
	Пример дженерика стрелочной функции:
	
		const fn = <T>(data: T[]): T[] => data;
	
	• Дженериков может быть несколько, они будут перечисляться в треугольных скобках через запятую. Это будет означать что функция работает с указаннымии типамии. На выходе функции
	дженерики можно объеденить с помощью оператора "&", что будет означать что тип возвращаемой сущности функцией будет комбинацией типов указанных дженериков.
	
	Пример:
	
		const a = {ff: 12};

		const b = {cc: 12};

		function fn<T, R>(c: T, d: R): T & R {			// Оператор "&" объединяет дженерики на выходе фукнции, после чего тип возвращаемой сущности функцией будет иметь тип объедииненный из двух дженериков "T" и "R".
		  return Object.assign({}, c, d);
		}
		
		const e = fn(a, b);		//	"TypeScript" теперь будет подсказывать что объекту "e" доступны методы "ff" и "cc".
	
	• Ограничение типов дженериков. Можно ограничить типы дженериков, наследуя дженерик от определенного типа (или нескольких типов) оператором "extends":
	
		const a = {ff: 12};

		const b = {cc: 12};
		
		const a2: string = 'aaa';

		const b2: string = 'bbb';

		function fn<T extends object, R extends object>(c: T, d: R): T & R {		// Запись "T extends object" означает что тип дженерика "T" должен быть типом "object" (должен наследоваться от типа "object").
		  return Object.assign({}, c, d);
		}
		
		const e = fn(a, b);		//	"TypeScript" теперь будет подсказывать что объекту "e" доступны методы "ff" и "cc".
		const f = fn(a2, b2)	//	Вызовет ошибку, так как типы передаваемых аргументов не являются типами "object" (типы не наследуются от типа "object").
	
	• Ограничение типов дженериков на основании ключей объекта. Можно ограничить тип дженерика, на основании ключей, которые будут каком либо объекте или же в другом дженерике.
	Сделать это можно с помошью комбинации операторов "extends" и "keyof":
	
		function fn<T extends object, R extends keyof T>(obj: T, key: R) {		// Дженерик "R" будет зависеть (наследоваться) от ключей типа дженерика "T".
		  return obj[key];
		}
		
		const person = {
			name: 'Alex',
			age: '24'
		}
		
		const result1 = fn(person, 'name');
		const result2 = fn(person, 'age');
		const result3 = fn(person, 'height');	// "TypeScript" на этапе написания кода будет выдавать ошибку о том, что поля "height" нет в типе "preson".
	
	• Частичное использование типов (интерфейсов).
	
	Для частичного использования типов (интерфейсов), можно воспользоваться утилитой "Partial", после чего ставится тип (имя интерфеса), который и будет использоваться частично.
	
	Например типизация объекта от интерфейса, но объект временно будет пустым (не будут реализованы поля из интерфейса), и чтобы "TypeScript" не выдал ошибку о том что объект
	не соответствует указанному интерфейсу, этот интерфейс стоит указать после утилиты "Partial":
	
		interface Car {
			model: string;
			yeat: number;
		}
		
		function createAndValidateCar(model: string, year: number): Car {
			const car: Partial<Car> = {}	//	Так как объект "car" изначально пустой, и чтобы "TypeScript" не выдал ошибку, используется утилита "Partial", который указыват что типы следующего интерфейса ("Car") реализованы частично (или не реализованы).

			if (model.length > 3) {
				car.model = model;
			}

			if (year > 2000) {
				car.year = year;
			}

			return car as Car;	// Здесь необходимо приведение типа через "as". потому что функция "createAndValidateCar" возвращает тип "Car", а внутри она реализована частично.
		}

• Дженерики у классов.

	Дженерики у классов во многом схожи с дженерикамии функций. Дженерик класса указывается после имени класса, а использование как входного параметра, и использование как типа
	выходного параметра происходит в его методах или конструкторе:
	
		class Collection<T> {
		
			constructor(private _items: T[] = []) {}
			
			add(item: T) {
				this._items.push(item);
			}
			
			get items(): T[] {
				return this._items;
			}
			
			remove(item: T) {
				this._items = this._items.filter(el => el !== item);
			}
		}
		
		const collection = new Collection(['a', 'b', 'c']);

• Дженерики интерфейсов.
	
	Дженерики интерфейсов во многом схожи с дженерикамии функций.
	Можно более гибко настроить интерфейсы, добавив в них дженерики. Для этого после имени интерфейса добавляются треугольные скобки "<>", и в них добавляется имя дженерика или
	дженериков. Затем этот дженерик используется внутри интерфейса. Затем когда этот интерфейс будет использоваться, ему передастся тип, который затем подстроится на место
	дженерика:
	
		interface IUser<T> {	//	Тип, который будет подставлен на место дженерика ("T") после имени интерфейса, будет подставлен на место дженерика ("T") внутри интерфейса.
			name: string;
			data: T;			// Сюда будет подставлен тип, который будет добавлен после имени интерфейса.
		}
		
		const user1: IUser<{meta: string}> = {
			name: 'Alex',
			data: {
				meta: 'Meta data',
			}
		};
		
		const user2: IUser<string[]> = {
			name: 'Alex',
			data: ['foo', 'bar', 'baz'],
		};
	
	Таким же образом можно добавить несколько дженериков.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Декораторы.

Дектораторы нужны для перехвата создания классов, для перехвата вызова функций, для перехвата обращения к свойствам класса или объекта, для перехвата вызова методов или аксессоров.

Подробнее "https://www.typescriptlang.org/docs/handbook/decorators.html".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Пространства имен (неймспейсы ("Namespaces")).

Пространства имен нужны для создания изолированных пространст имен переменных.

Данная возмможность устарела, и рекомендуется пользоваться модулями.

Один из приммеров создания пространств имен, это объединение типов и интерфейсов, которые относятся к одной сущности.

Например если в классе используются типы, которые созданы снаружи класса через "type", а так же если в этом классе используются интерфейсы, то эти типы и интерфесы можно вынести
в отдельный файл и завернуть в неймспейс. Далее этот класс тоже нужно завернуть в такой же неймспейс (имена дожны совпадать). В файле с неймспейсом с типами и интерфейсами
типы и интерфейсы экспортируются внутри этого неймспейса, а в файле с неймспейсом с классом, где нужны эти типы и интерфесы, этот неймспейс ипортируется референсом.

Неймспейс создается с поммощью ключевого слова "namespace", затем идет имя этого неймспейса, затем литерал объекта (без присваивания "="), где собственно и будет содержание
этого неймспейса.

В Файле где будет импортироваться (референситься) неймспейс, он импортируется следующим образом: В начале документа добавляется комментарий, но с тремя слешами "///",
после чего в этой же строке пишется самостоятельный (самозакрывающийся) тег "reference", где будет атрибут "path", значением которого будет путь к файлу с неймспейсом,
который нужно импортировать. Пример:

	<reference path="form-namespace.ts" />

Пример использования неймспейса для объединения типов и интерфейсов, которые относятся к одной сущности:

	Файл с неймспейсом с типами и интерфейсами:
	
		namespace Form {
			export type FormType = 'inline' | 'block'
				export type FormState = 'active' | 'disabled'

				export interface FormInfo {
					type: FormType
					state: FormState
				}
		}
		
	Файл с неймспейсом с классом, где понадобится неймспейс с типами и интерфейсамии для этого класса:
	
		
		/// <reference path="form-namespace.ts" />

		namespace Form {
			class MyForm {
				private type: FormType = 'inline'
				private state: FormState = 'active'

				constructor(public email: string) {}

				getInfo(): FormInfo {
					return {
						type: this.type,
						state: this.state
					}
				}
			}
		}

Подробнее "https://www.typescriptlang.org/docs/handbook/namespaces.html".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Приведение типов.

Можно привести какую либо сущность к определенному типу.

Делается это двумя способами:

	1. Через ключевое слово "as". Оно указывается после сущности, и после него идет приводимый тип:
	
		const obj = {} as Rect	// "Rect" - заранее имеющийся интерфейс.
	
	2. Через дженерик:
	
		const obj = <Rect>{}	// "Rect" - заранее имеющийся интерфейс.

• Приведенным типом можно вопользоваться двумя способамии:

	1. Через переменную:

		const elem = document.getElementById('foo');

		elem.addEventListener('test', function (e) {
			const target = e.target as Element;
			console.log(target.id); // 'foo'
		}, false);

		elem.dispatchEvent(new Event('test'));
		
	2. Сразу, указав приведение в круглых скобках:
	
		const elem = document.getElementById('foo');

		elem.addEventListener('test', function (e) {
			const id = (e.target as Element).id;
			console.log(id); // 'foo'
		}, false);

		elem.dispatchEvent(new Event('test'));

• Приведение типов может пригодиться в случаях когда "TypeScript" выдает ошибку что какого либа свойства или метода нет у той или иной сущности.
Для этого можно привести этот тип к типу сущности, в котором имеются нужные свойства или методы.

• Привести типы можно только от типов "unknown" или "any" или типов, которые наследуются от приводимого типа (например приведение к типу "HTMLElement" от типа "Element").
• Любой тип можно привести к типам "unknown" или "any". Чтобы привести тип к неприводимому типу, можно привести этот тип сначала к типам "unknown" или "any", затем к
желаемому типу.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Ошибки и их значения (перевод).

Подробнее "https://github.com/microsoft/TypeScript/blob/main/lib/ru/diagnosticMessages.generated.json".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Примеры типизаций.

• Типизации объектов:

	Пример 1:
	
		type Email = string | undefined;
		
		type OrderTouple = [string, number, boolean];
	
		interface Obj {

			color?: string;
			
			id: string;
			
			age: number;
			
			sayHi1(name: string): string;
			
			sayHi2: (name: string) => string;
			
			email: Email;
			
			order: OrderTouple;
		}

	Пример 2:
	
		interface Obj {
			[key: string]: string;
		}
	
	Пример 3:
	
		type Obj = {
			_id: number,
			name: string
		}

		const obj: Obj = {
			_id: 1,
			name: '1',
		}

• Типизация функций:

	Пример 1:
	
		function sum(n1: number, n2: number): number {
			return n1+n2;
		}
	
	Пример 2:
	
		interface FN {
			(n1: number, n2: number): number;
		}
		
		const fn: FN = function (n1, n2) {
			return n1+n2;
		}

	Пример 3:
	
		const fn:(name: string) => string = (name) => {
			return 'hello' + name;
		}























































	

