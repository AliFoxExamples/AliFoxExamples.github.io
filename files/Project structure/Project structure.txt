https://refactoring.guru/ru/design-patterns/catalog
https://designpatternsphp.readthedocs.io/ru/latest/README.html

Паттерны:

	Creational

		Пораждающие паттерны. Паттерны использующиеся при создании сущностей. Позволяет управлять моментом создания сущностей и управлять этим процессом.

		Входящие паттерны:

			Factory

				Паттерн позволяющий создавать интерфейсы для создания сущностей в супер классах, позволяя подклассам выбирать тип сущностей, которые будут созданы.

			Prototype

				Паттерн использующийся при создании новых объектов на основе другого (прототипа).

			Singleton

				Когда единый экземпляр одной сущности используется по всему проекту (то есть не используется несколько экземпляров одной сущности). Например база данных.

	Structural

		Структурные паттерны. Паттерны в которых рассматривается вопрос о том, как из сущностей образуются более крупные структуры.

		Входящие паттерны:

			Adapter

				Паттерн позоволяющий адаптировать использование разных несовместимих сущностей между собой (создания адаптера между ними).
				Например адаптация старого функционала под новый, не меняя старый, а адаптируя его.

			Decorator

				Паттерн позоволяющий добавлять новый функционал к уже сущесвующим сущностям, не меняя их, а создавая обертку.

			Facade

				Паттерн позоволяющий упрощать взаимодействие с сущностью (упрощать его интерфейс). Другими словами это структурный паттерн проектирования,
				который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

			Proxy

				Паттерн позоволяющий перехватывать доступ/обращение к сущности, создав вокруг него обертку, для большего контроля над сущностью и обогащения его функционала.
				
			Flyweight
			
				Паттерн "Приспособленец" или "Легковес" применяющийся при уменьшении использования памяти путем переиспользования одной сущности, которая требуется в других сущностях, чтобы не пересоздавать
				по экземпляру этой сущности каждый раз при необходимости. Данный паттерн используется при кешировании.

	Behavioural

		Поведенческие паттерны. Паттерны использующиеся при взаимоотношениях между сущностямии.

		Входящие паттерны:

			Chain of Responsibility
			
				Паттерн использующийся при создании цепочки ответственности вызовов.
				Например когда функция/метод/класс не справляется с задачей (не соответствует ее ответственности), то она вызывает другую, передав ей тело запроса.
				Другимми словамии это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков.
				Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
			
			Command
			
				Паттерн "Команда" позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот объект запроса на действие и называется командой.
				При этом объекты, инициирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.
				Команды могут использовать параметры, которые передают ассоциированную с командой информацию. Кроме того, команды могут ставиться в очередь и также могут быть отменены.
				Другими словамии это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов,
				ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
				
				Характерным примером этого паттерна является технология "Redux".
				
			Iterator
			
				Добавить коллекции объектов функционал последовательного доступа к содержащимся в ней экземплярам объектов без реализации этого функционала в самой коллекции.

			Mediator
			
				Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
			
			Observer
			
				Наблюдатель - это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах
				Другими словами для реализации публикации/подписки на поведение объекта, всякий раз, когда объект «Subject» меняет свое состояние, прикрепленные объекты «Observers» будут уведомлены.
				Паттерн используется, чтобы сократить количество связанных напрямую объектов и вместо этого использует слабую связь (loose coupling).
				
				Данный паттерн используется в библиотеке "RxJs" и "Angular".
			
			State
			
				Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.
				Другимии словами инкапсулирует изменение поведения одних и тех же методов в зависимости от состояния объекта. Этот паттерн поможет изящным способом изменить поведение объекта во время
				выполнения не прибегая к большим монолитным условным операторам.
			
			Strategy
			
				Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс,
				после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
			
			Template
			
				Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы.
				Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

Solid.

	S
	
		

Имена директорий проекта:

	utils

		Обычно используется для фунций-утилит (парсеры, валидаторы и т.п.).

	public

		Используется для статичных файлов, имена которых обычно не меняются (например "favicon.ico" и т.д.).

	dist

		"Distribution"	-	папка с собранным проектом.
	
	shared