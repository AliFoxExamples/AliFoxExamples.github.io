◘ Данный документ написан при версии "Webpack" '5.65.0'.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Установка "Webpack".

	npm install -D webpack webpack-cli

		"webpack"		-	корневой функционал "webpack".
		
		"webpack-cli"	-	функционал команд, которые будут доступны в консоли.
		
		"-D" 			-	флаг, который указывает на то что это зависимость только для разработки.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ При использовании сборщика "webpack", выходной файл скрипта автоматически будет собран так, что в нем будут соблюдены все зависимости. Для этого в разных скриптовых файлах нужно
воспользоваться импортированием/экспортированием. Больше не нужно будет следить за порядком очереди тегов "script" в "HTML", так как сборщик соберет единый выходной скриптовой
файл соблюдая все зависимости всех связанных между собой скриптовых файлов. При использовании в скриптах ("js", "ts") файлов-ассетов из директорий разработки, их необходимо
импортировать, для того, чтобы сборщик правильно собрал проект с соблюдением всех зависимостей (путей к файлам).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Консольные команды "webpack".

Использование команд "webpack" в консоли начинается с префикса "webpack". Пример:

	webpack

Консольные команды могут писаться с флагами:

	webpack --mode development

Консольные команды так же можно использовать через поле "scripts" файла "package.json".

Список консольных команд:

	webpack
	
		Построить билд на основе текущих конфигураций.

Список флагов:

	--mode
	
		Указать способ сборки. Способы сборки:

			production	-	сборка в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется.

			development	-	сборка в режиме "development". Собранный код в данном режиме не минифицирован.
		
		Способ сборки можно так же настроить в файле конфигурации "Webpack" в объекте "mode" объекта "module.exports".

		Пример использования:

			webpack --mode development

	--watch
		
		Следить за изменениями файлов, и запускать сборку при изменении файлов.  При "--watch" страница обновляться не будет, а так же сборка будет проводиться полностью,
		а не в оперативную память. Пример использования:

			webpack --mode development --watch

	--config
	
		Использование пользовательского конфигурационного файла. Пример:
		
			webpack --config webpack.development.js
		
		Есть другой способ использования разных конфигурационных файлов, подробнее в главе "Использование нескольких файлов конфигураций".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функция упрощения создания путей "path".

При настройке конфигурации "Webpack", при добавлении путей файлов, ассетов и т.д. можно воспользоваться функцией "path" у "Node",
которая упростит создание путей.

Для начала нужно испортировать функцию "path" в начале конфигурационного файла "webpack.config.js":

	const path = require("path");

Создание пути осущетсвляется вызовом этой функции добавление в качестве аргументов куски путей, которые нужно соеденить. Во время использования данной функции может использоваться
системная переменна "__dirname" у "Node", которая указывает на текущую директорию с проектом.

Пример использования функции упрощения создания путей "path", с директорией проекта "C:\Temp":

	path.resolve(__dirname, 'dist')		//	результатом вызова данной функции будет "C:\Temp\dist".

Пример использования функции упрощения создания путей "path" в конфигурации "webpack.config.js":

	const path = require('path');
	module.exports = {
		entry: {
			main: path.resolve(__dirname, 'src/app.js'),
		},
		output: {
			path: path.resolve(__dirname, 'dist'),
			filename: '[name].[contenthash].js',
		},
	},

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Настройка файла конфигурации "webpack", который называется "webpack.config.js".

• Настройка файла конфигурации "webpack.config.js". По умолчанию "webpack" сразу ищет наличие данного файла, и настраивает конфигурции согласно его содержимому.
Сам "webpack.config.js" является инструментом сборки, и не будет относиться к самому проекту.
Можно менять название "webpack.config.js" на произвольное, после чего вручную указывать на конфигурацию в "package.json" (подробнее в главе "Использование нескольких файлов конфигураций").
Некоторые пункты настроек можно даже не указывать, так как "webpack" будет по умолчанию работать и без ниих (например "entry" и т.д.), но лучше настроить полностью.
Если не создавать конфигурацию "webpack.config.js", то "webpack" будет искать входной файл "index.js" по пути "src".

• Примечание. Если у конфигурации имеется другое имя (не "webpack.config.js"), и оно запускалось через скрипты в конфгурационном файле проекта "package.json" с добавлением флага "--config",
то простой вызов "npx webpack" через консоль вызовет ошибку, так как "NodeJS" не найдет файл конфигурации "Webpack" по умолчанию ("webpack.config.js").

Настройка файла конфигурации "webpack.config.js" начинается с прописывания свойств объекту конфигурации "exports" объекта "module" ("module.exports"):

	// файл "webpack.config.js".

	module.exports = {
		// свойства.
	}

Вместо объекта в "module.exports = {}" можно экспортировать функцию, которая вернет объект конфигурации, для его более гибкой настроки.

Свойства объекта "exports":

	mode

		Указывает сборщику "webpack", в каком режиме делать сборку. Значение пишется в строковом виде. Значения:

			production
			
				Делать сборку в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется (минифицируется "HTML" и "javascript", но не "css").

			development
			
				Делать сборку в режиме "development". Собранный код в данном режиме не минифицирован.

		Пример:

			module.exports = {
				mode: 'development',
			}
			
		Можно динамично настроить режим сборки через системное свойство "process.env.NODE_ENV" у "Node":
		
			mode: process.env.NODE_ENV === "production" ? "production" : "development",
		
		Дальше чтобы уже установить конкретный режим сборки, нужно в пользовательских скриптах в "package.json" присвоить переменной среды "NODE_ENV" необходимое значение:
		
			// файл "package.json"
			
			{
				"name": "webpack-project",
				"version": "1.0.0",
				"description": "",
				"scripts": {
					"dev": "set NODE_ENV=development && webpack",
					"build": "set NODE_ENV=production && webpack"
				},
			}
		
		• Примечание: При использовании команды "set NODE_ENV=<режим сборки>", если после этой команды идет пробел (при использовании нескольких комманд, до оператора "&&"),
		то этот пробел добавится к значению "NODE_ENV".
		Например в скрипте
		
			"dev": "set NODE_ENV=development && webpack",
		
		значение "NODE_ENV" в итоге будет равно "development " (с пробелом). Для использовании данного значения режима сборки, на строке нужно вызвать метод "trim()":
		
			const actualEnv = (process.env.NODE_ENV).trim();
		
		Для кроссплатформенной работы можно установить пакет "cross-env", который будет гарантированно устанавливать среду разработки автоматически для текущей операционной системы. Установка:
		
			npm i -D cross-env
			
		Использование:
		
			// файл "package.json"
			
			{
				"name": "webpack-project",
				"version": "1.0.0",
				"description": "",
				"scripts": {
					"dev": "cross-env NODE_ENV=development webpack",
					"build": "cross-env NODE_ENV=production webpack"
				},
			}
			
	entry

		Указывает сборщику ("webpack") откуда начать сборку. Значением данного свойства может быть простой путь входного файла в текстовом формате,
		или объект с детальной настройкой входного файла или нескольких файлов.	Свойствами объекта с детальной настройкой будут имена, которые будут использоваться в "output"
		для подстановки в паттерны для имен выходных файлов. Значениям этих свойств может быть простой путь в текстовом формате, или массив с путями в тестовом формате,
		или же объект для более развернутой настройки конкретного входного имени.

		Если будет использоваться объект с путями, то имена свойств будут произвольными (для главного пути рекомендуется использовать имя "main"), а значениями этих свойств будут
		пути этих файлов в строковом формате.
		
		Если в "entry" используется простой текстовый путь, а в "output" используются паттерны имен, то на место паттера "[name]" встанет имя "main" по умолчанию.
		
		Если входных файлов несколько, а в "output" не используются паттерны для имен, то сборка не соберется, и даст ошибку в консоль, так как "webpack" попытается собрать все воедино.
		
		Варианты написания свойства "entry":

			Простой текстовый путь:
			
				module.exports = {
					entry: './src/index.js',
				}
				
			Пример с использованием нескольких входных путей:

				module.exports = {
					entry: {
						main: './src/index.js',
						analitics: './src/analitics.js',
					}
				}
			
			Пример с использованием массива с несколькими входными путями, и с несколькими файлами у одного из них:
			
				module.exports = {
					entry: {
						main: ['@babel/polyphill', './src/index.js'],		// В данной точке входа используются оба файла '@babel/polyphill' и './src/index.js'.
						analitics: './src/analitics.js',
					}
				}
			
			Пример с использованием массива с несколькими входными путями, и с несколькими файлами у одного из них, и детальной настройкой одного из них:
			
				module.exports = {
					entry: {
						main: ['@babel/polyphill', './src/index.js'],
						analitics: {
							filename: './src/analitics.js',
							import: './catalog.js',
							dependOn: 'shared',
							chunkLoading: false,
						},
					}
				}
		
		Подробнее "https://webpack.js.org/configuration/entry-context/#entry".
			
	output

		Значением данного свойства будет объект со свойствами результата сборки. Свойства объекта "output":

			filename

				Значением данного свойства будет имя собраного "js" файла в строковом формате, другими словами указывает сборщику ("webpack") как назвать выходной файл скриптов.
				Обычно этот файл принято называть "bundle.js". Файлов будет столько, сколько указано входных файлов в свойстве "entry" объекта "module.exports". Каждый может
				иметь свое имя в соответствии если использовались паттерны имен. Подробнее в главе "Паттерны имен". Если входных файлов несколько, а в "output" не используются паттерны для имен,
				то сборка не соберется, и даст ошибку в консоль, так как "webpack" попытается собрать все воедино.

			path

				Значением данного свойства будет путь выходных файлов, другими словами указывает сборщику ("webpack") куда ложить сборку. Значение можно указывать
				просто в строковом формате, но рекомендуется использовать встроенный модуль в "node.js", который называется "path". Подробнее в главе 'Функция упрощения создания путей "path"'.
				Обычно имя выходной директории принято называть "dist".
			
			clean
			
				Использование фунции очистки конечной папки сборки при каждой сборке. Значением данного свойства является булево значение соответствующее включению и выключению.
				Использование данного своства убирает необходимость в стороннем плагине "clean-webpack-plugin".
			
			assetModuleFilename
			
				Настроить выходное имя файлов/ассетов с возможностью использования паттернов имен. Данное свойство работает со встроенным лоадером "type" ("module.exports" -> "module" -> "rules" -> "type"),
				так же со встроенным лоадером для ассетов у лоадера "css-loader", но не работает с лоадером "file-loader".
				В имя ассета так же можно добавить желаемую директорию:

					assetModuleFilename: 'images/[name].[ext]'		// картинка будет в папке "images".

		Пример:

				const path = require('path');

				module.exports = {
					entry: {
						main: './src/index.js',
						analitics: './src/analitics.js',
					},
					output: {
						filename: '[name].bundle.js',
						path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
						assetModuleFilename: '[name][ext]',
						clean: true,
					},
				}

		• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".		
		
	module
	
		Лоадеры (модули-загрузчики). Сборщик "webpack" умеет работать только со скриптами, и для того чтобы он умел работать с другими типами файлов (например стили, картиник и т.д.),
		нужно подключить соответствующий модуль-загрузчик. Лоадеры превращают файлы других типов, которые импортируются в коде, в отдельные модули.

		Для начала необходимо установить сами лоадеры. Устанавливаются они через "npm" как зависимость для разработки ("--save-dev" или "-D").

		Для добавления лоадеров нужно добавить объект (свойство) "module", в объект конфигурации "module.exports". У данного объекта (свойства) будут следующие свойства:

			rules
			
				Массив с объектами правил поведения для соответствующих типов файлов. Объект правил поведения будет иметь следующие свойства:

					test
					
						Регулярное выражение, которое будет использоваться для подбора типов файлов. Регулярное выражение будет подбирать файл основываясь на указанных расширениях.
						В случае подбора, будет использоваться лоадер, указанный в свойствах "use", "type" или "loader".
						
					exclude
					
						Указать на директории или файлы, которые будут исключены для лоадера. Например:
					
							exclude: /node_modules/

					use
					
						Использование лоадера или лоадеров которые необходимо будет задействовать при нахождении файлов регулярным выражением указанным в свойстве "test".
						Значением свойства может быть имя лоадера, массив с именами лоадеров, или же объект с более подробной настройкой лоадера. В случае использования массива с именами лоадеров, то в нем
						перечисляются имена лоадеров в строковом формате. Примечание! Перечисленные лоадеры в массиве будут применяться справа налево (то есть с конца к началу).
						Данное свойство используется в пару со свойством "test".
						
						Прежде чем использовать лоадер, его нужно установить:
						
							npm i -D <имя лоадера>
							
							Например:
							
								npm i -D file-loader
						
						Пример использования "use" с массивом лоадеров:
						
							use: ['style-loader', 'css-loader']
						
						В случае с использованием объекта, в нем могут быть следующие свойства:
						
							loader
							
								Имя лоадера или массив имен лоадеров.
							
							options
							
								Объект со свойствами для конкретного лоадера.
							
							Пример:
							
								module.exports = {
									module: {
										rules: [
											{
												test: /\.(svg|png|jpg|gif)$/,
												use: {
													loader: "file-loader",
													options: {
														name: "[name].[hash].[ext]",
														outputPath: "imgs"
													}
												}
											},
								}

						Список лоадеров:
						
							hmtl-loader
							
								Лоадер для шаблонов "HTML". Данный лоадер содержит встроенный лоадер для ассетов, которые в нем непосредственно используются (например ассеты через атрибут "src"),
								и поэтому нет необходимости в подключении встроенных лоадеров в "Webpack" для ассетов (встроенный лоадер "type" для ассетов), или же нет необходимости в установке
								сторонних лоадеров для ассетов (например "file-loader"), кроме случаев если втроенный лоадер в "hmtl-loader" не поддерживает конкретный тип ассетов.
								Этот встроенный лоадер (лоадера "hmtl-loader") для ассетов не распространяется на другие файлы (например "js", "css" и т.д.). По умолчанию этот встроенный лоадер
								(лоадера "hmtl-loader") дает ассетам на выходе имена по паттернам "[hash][ext][query]". Чтобы модифицировать имена файлов/ассетов на выходе сборки,
								в свойстве "output" у объекта "module.exports" можно добавить свойство "assetModuleFilename", и настроить выходное имя с возможностью использования паттернов имен.
								Так же можно настроить сам "html-loader" для этого (подробнее "https://webpack.js.org/loaders/html-loader/").
								
								Когда лоадер получает "HTML" файл на обработку, он находит пути ассетов, и далее пользуется встроенным лоадером для ассетов, и выгружает эти ассеты.
								
								Установка:
								
									npm i -D html-loader
								
								Этот лоадер так же может минифицировать выходной "HTML" документ в зависимости от режима сборки, но можно и вручную настроить минификацию "HTML" документа,
								добавив свойство "minimize" со значением "true" или "false" в объект настройки "options" самого лоадера "html-loader".
								
								Подключение:
								
									module.exports = {
										module: {
											rules: [
												{
													test: /\.html$/,
													use: {
														loader: 'html-loader',
														options: {
															minimize: true			// Минифицировать код.
														}													
													},
												},
											]
										},
									}

							css-loader
							
								Позволяет сборщику загружать зависимые стили в "javascript". Данный лоадер превращает "css" код в модуль и добавляет его в "javascript".
								Используется вместе с лоадером "style-loader", и дабавляется после "style-loader" в массиве с лоадерами.
								У данного лоадера есть встроенный лоадер для ассетов использующихся в стилях. Имена выходных файлов ассетов, которые использовались в стилях
								могут быть настроены с помощью свойства "assetModuleFilename" у объекта "output" объекта "module.exports".
								
								• При одновременном использовании с лоадером "file-loader", файлы ассетов (которые использовались в стилях) будут дублироваться в итоговой папке сборки.
								
								• Одновременное использование встроенного лоадера "type" не влияет на использование встренного лоадера для ассетов у лоадера "css-loader", разве что если настроить
								объект "generator" (у объекта плавил "rules" ("module.exports" -> "module" -> "rules")), и изменить там имя выходных ассетов.
								
								Подробнее в главе "Работа со стилями".

							style-loader
							
								Позволяет сборщику добавлять загруженные стили из "javascript в тег "head" в "html". Данный лоадер подключает "css" модуль, созданный с помощью лоадера "css-loader" к странице "HTML".
								Используется вместе с лоадером "style-loader", и дабавляется до "style-loader" в массиве с лоадерами.
								
								Подробнее в главе "Работа со стилями".

							file-loader
							
								Лоадер для работы с файлами ассетами (картинки, шрифты и т.д.). Данный лоадер работает так же и в css (если в стилях используется фоновая картинка), он таким же образом его подгрузит.
								В новых версиях "Webpack" уже есть встроенный лоадер для файлов/ассетов, который убирает необходимость в использовании данного лоадера (свойство "type" объекта правил "rules"
								("module.exports" -> "module" -> "rules" -> "type")).
								При использовании данного лоадера, не удастся модифицировать имена файлов/ассетов на выходе сборки с помошью свойства "assetModuleFilename" в объекте "output" у объекта "module.exports".
								
								• При одновременном использовании с лоадером "css-loader", файлы ассетов (которые использовались в стилях) будут дублироваться в итоговой папке сборки.
								
								Свойства в "options":
							
									name
									
										Имя выходного файла. Модифицировать имена файлов/ассетов на выходе сборки согласно указанным паттернам имен.
										При использовании хэша, в данном лоадере используется паттерн "[hash]" вместо "[contenthash]".
										В имя ассета так же можно добавить желаемую директорию:
						
											name: 'images/[name].[ext]'		// картинка будет в папке "images".

									outputPath
									
										Имя папки (или папок), которая будет создана и в которую поместится выходной файл. Можно совметить с добавлением желаемой директории в имя ассета (свойство "name" выше).
								
								Пример использования лоадера "file-loader":
								
									module.exports = {
										entry: {main: path.resolve(__dirname, 'src/app.js')},
										output: {
											path: path.resolve(__dirname, 'dist'),
											filename: '[name].[contenthash].js',
											assetModuleFilename: '[name].[ext]',							// Модифицировать имена файлов/ассетов на выходе сборки согласно указанным паттернам имен. Работает только со встроенным лоадером ассетов "type".
											clean: true,
										},
										
										module: {
											rules: [
												{
													test: /\.(svg|ico|png|webp|jpg|gif|jpeg)$/,
													use: {
														loader: "file-loader",							// Для ассетов типа указанных с свойстве "test" использовать лоадер "file-loader".
														options: {
															name: "logo[name].[hash].[ext]",				// Модифицировать имена файлов/ассетов на выходе сборки согласно указанным паттернам имен.
															outputPath: "assets/img"							// Имя папки, которая будет создана и в которую поместится выходной файл.
														}
													}
													
												},
											],
										},
									};
							
							babel-loader
							
								Лоадер для "Babel". Подробнее в главе "Транcпиляция кода и полифилы". Свойства в "options":
							
									presets
									
										Массив с пресетамии. Пресеты это наборы готовых плагинов для "Babel" (плагины у "Babel" позволяют настроить поддержку старых браузеров). Например:
									
											options: {
												presets: ['@babel/preset-env'],
											},
										
										Список пресетов:
										
											@babel/preset-env
											
									plugins
									
										Массив с отдельными плагинами. Список плагинов:
										
											@babel/plugin-proposal-class-properties
											
												Добавить возможность транспиляции свойств, которые находятся на стадии предложения, а именно функционал свойств у классов.
											
							xml-loader
							
								Лоадер для подгрузки "xml" файлов.

					type
					
						Встроенный загрузчик файлов/ассетов в новой версии "Webpack". Использование данного свойства (загрузчика) убирает необходимость в использовании сторонних загрузчиков как "file-loader", "raw-loader" и "url-loader".
						Значения свойства "type":
						
							'asset/resource'
							
								Выгружает отдельный файл ассетов и экспортирует его "URL". Ранее использовался сторонный лоадер "file-loader".
								
							'asset/inline'
							
								Экспортирует данные "URI" ассета, например при работе с "svg" будет вставлять ее код в "HTML", я не выводить как отдельный файл. Ранее использовался сторонный лоадер "url-loader".
							
							'asset/source'
							
								Экспортирует исходный код ассета. Ранее использовался сторонный лоадер "raw-loader".
							
							'asset'
							
								Автоматически выбирает между экспортированием данных "URI" и выгружением отдельного ассет файла. Ранее использовался сторонный лоадер "url-loader" со свойством ограничения размера ассета "asset size limit".
								
						Данное свойство используется в пару со свойством "test".
						! Примечание. По умолчанию лоадер "type" дает ассетам на выходе имена по паттернам "[hash][ext][query]". Чтобы модифицировать имена файлов/ассетов на выходе сборки, в свойстве "output" у объекта "module.exports"
						можно добавить свойство "assetModuleFilename", и настроить выходное имя с возможностью использования паттернов имен.
						Так же вместо использования свойства "assetModuleFilename" в свойстве "output" у объекта "module.exports", можно воспользоваться свойством "generator" (подробнее в свойстве "generator" у объекта правил "rules"
						("module.exports" -> "module" -> "rules" -> "generator")).
						
						В имя ассета так же можно добавить желаемую директорию:
						
							assetModuleFilename: 'images/[name].[ext]'		// картинка будет в папке "images".
						
						Пример использования:
						
							const path = require('path');


							module.exports = {
								entry: {main: path.resolve(__dirname, 'src/app.js')},
								output: {
									path: path.resolve(__dirname, 'dist'),
									filename: '[name].[contenthash].js',
									assetModuleFilename: 'images/[name].[ext]',						// Модифицировать имена файлов/ассетов на выходе сборки согласно указанным паттернам имен.
									clean: true,
								},
								
								module: {
									rules: [
										{
											test: /\.(svg|ico|png|webp|jpg|gif|jpeg)$/,
											type: 'asset/resource',							// Для ассетов типа указанных с свойстве "test" использовать встроенный лоадер "asset/resource".
										},
									],
								},
							};
						
						Подробнее "https://webpack.js.org/guides/asset-modules/".
					
					generator
					
						Свойство (объект) настройки имен и данных ассетов на выходе сборки. Данное свойство используется только при использовании встроенных лоадеров "asset" и "asset/resource".
						
						Основные свойства объекта "generator":
						
							filename
							
								Настроить выходное имя файлов/ассетов с возможностью использования паттернов имен. То же самое что и свойство "assetModuleFilename" в объекте "output" у объекта "module.exports".
								
								• При одновременном использовании со свойством "assetModuleFilename" (в объекте "output" у объекта "module.exports"), приоритет будет у свойства "filename" объекта "generator".
								
								В имя ассета так же можно добавить желаемую директорию:
						
									filename: 'images/[name].[ext]'		// картинка будет в папке "images".
						
						Пример использования:
						
							const path = require('path');
						
							module.exports = {
								entry: './src/index.js',
								output: {
									filename: 'main.js',
									path: path.resolve(__dirname, 'dist'),
								},
								module: {
									rules: [
										{
											test: /\.(svg|ico|png|webp|jpg|gif|jpeg)$/,
											type: 'asset/resource',
											generator: {
												filename: 'static/[name].[hash].[ext]'
											}
										}
									]
								}
							}

					loader
					
						Указать имя лоадера. Не рекомендуется использовать данное свойство, так как свойство "use" более гибкое. Данное свойство используется в пару со свойством "test".

			Пример использования свойства "rules":

				module.exports = {
					module: {
						rules: [
							{
								test: /\.css$/,
								use: ['style-loader', 'css-loader'],		// Массив лоадеров. Здесть сначала задействуется лоадер "css-loader", а затем "style-loader" (с конца к началу).
							},
							{
								test: /\.(jpg|png|svg|gif )$/,
								use: ['file-loader'],						// Один лоадер, поэтому указана как строка а не массив.
							},
							
							// или другой вариант для 'file-loader''file-loader':
							
							{
								test: /\.(svg|png|jpg|gif)$/,
								use: {
									loader: "file-loader",
									options: {
										name: "[name].[hash].[ext]",
										outputPath: "imgs"
									}
								}
							},
							
							{
								test: /\.js$/,
								exclude: /node_modules/,
								use: {
									loader: 'babel-loader',
									options: {
										presets: ['@babel/preset-env'],
									},
								},
							},
							
							
						],
					}
				}
	
	plugins
	
		Массив с плагинамии. Плагины позволяют добавить дополнительные функционал к базовой конфигурации "webpack".

		Для начала необходимо установить нужный плагин через менеджер пакетов "npm":

			npm install -D <имя плагина>

		Пример установки:

			npm install -D html-webpack-plugin

		После установки необходимо импортировать этот плагин как класс. Пример:

			const HTMLWebpackPlugin = require('html-webpack-plugin');

		У некоторых плагинов есть отличия в методе импортирования плагина, например плагин "clean-webpack-plugin" (подробнее в подглаве "Список плагинов" - "clean-webpack-plugin").

		Затем нужно добавить этот новый плагин в объект конфигурации "exports". Для этого добавляется свойство "plugins", значением которого будет массив, где будут перечислены
		плагины. Сами плагины добаляются путем создания нового потомка (инстанса) от класса плагина. При добавления плагина можно передать в конструктор объект с настройками плагина.

		Список плагинов:

			html-webpack-plugin
			
				Плагин для сборки "html" файлов. При использовании данного плагина, можно не указывать скрипты и стили вручную в "html" файле, так как плагин сам их автоматически добавит.
				В конструктор класса опционально можно передать объект со свойствами, которые будут применены к ново-создаваемому "html" файлу.
				Свойства объекта, передаваемый конструктору класса:

					title
					
						Заголовок страницы. В значении указывается имя заголовка, в строковом формате. Если используется шаблон "html" файла, который уже имеет заголовок, то данное свойство
						бесполезно.
					
					filename
					
						Имя выходного "HTML" файла.

					template
					
						Шаблон "html" файла, основываясь на котором будет собираться новый "html" файл. В значении указывается адрес на шаблон в строковом формате.

					minify
					
						Объект со свойствами минифицирования. Значения свойств указываются в булевом формате. Основные свойства:

							collapseWhitespace
							
								Убрать  пробелы.

							removeAttributeQuotes
							
								Убрать кавычки у атрибутов.
								
							removeComments
							
								Убрать коментарии.
						
						В новых версиях "Webpack" минификация "HTML" происходит автоматически в зависимости от режима сборки.

				Пример добавления плагина "html-webpack-plugin":

					const path = require('path');
					const HTMLWebpackPlugin = require('html-webpack-plugin');

					module.exports = {
						entry: './src/index.js',
						output: {
							filename: 'bundle.js',
							path: path.resolve(__dirname, 'dist'),
						},
						plugins: [
							new HTMLWebpackPlugin({
								title: "New page",		// объект с настройками плагина.
							}),
						],
					}
				
				• В "HTML" можно получить доступ к свойствам конфигурации плагина (например к заголовку документа "title"). Для этого используется шаблонная строка "<%= %>". В него вставляется нужное свойство.
				В отличии от "webpack.config.js", в "HTML" имя плагина должно начинаться со строчной буквы "hTMLWebpackPlugin.options.title". Пример:
				
					<!-- Документ "HTML" -->
				
					<title> <%= hTMLWebpackPlugin.options.title %> </title>

			clean-webpack-plugin
			
				Плагин для очищения папки сборки перед сборкой. В новых версиях "Webpack" в объект "output" (у "module.exports") можно добавить свойство "clean", который уберет
				необходимость в использовании этого плангина.
				У данного плагина есть отличия в методе подключения, так как у него импортируется объект не по умолчанию. Чтобы получить
				класс плагина, нужно деструктуризировать импортируемый объект.
				
				В конструктор данного плагина может передаваться объект конфигурации, который содержит следующие свойства:
				
					cleanStaleWebpackAssets
					
						Натройка удаления неизмененных ассетов в конечной папке сборки (чтобы каждый раз не удалял). Значением является булево значение.
				
				Пример:

					const {CleanWebpackPlugin} = require('clean-webpack-plugin');

					module.exports = {
						entry: './src/index.js',
						output: {
							filename: 'bundle.js',
							path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
						},
						plugins: [
							new CleanWebpackPlugin({cleanStaleWebpackAssets: false}),
						],
					}

			copy-webpack-plugin
			
				Плагин для копирования файлов и директорий. Обычно копируются ассеты и статичные файлы такие как "favicon.ico" и т.д.
				В конструктор класса может передаваться объект с более детальной настройкой. 
				
				Если передается объект, то у него будут следующие свойства:
				
					patterns
					
						Значением свойства будет массив с объектами для каждого элемента копирования, которые содержат свойства "from" (откуда брать файлы) и "to" (куда класть файлы).
						
						Пример:
						
							const CopyWebpackPlugin = require('copy-webpack-plugin');

							module.exports = {
								plugins: [
									new CopyWebpackPlugin({
										patterns: [
											{
												from: path.resolve(__dirname, 'src/assets'),
												to: path.resolve(__dirname, 'dist/assets')
											}
										]
									})
								],
							}
				
				• Если плагин настроен, а папка с контентом пуста (нечего копировать), то сборка не соберется, выдаст ошибку.
			
			mini-css-extract-plugin
			
				Плагин для выведения стилей в отдельный ".css" файл вместо вставки в "HTML".  У данного плагина имеется свой лоадер для файлов стилей.
				
				В конструкторе плагина можно передать объект с конфигурациями, который может иметь следующие свойства:
				
					filename
					
						Имя выходного файла стилей. Имя может содержать паттерн имени "[contenthash]".
				
				У лоадера данного плагина имеются опции:
				
					hmr
					
						"hot module replacement" - "горячая подмена" - изменение стилей без перезагрузки страниицы. Данная функция добавляется если это возможно.
						Рекомендуется при использовании режима сборки - "development". Значением является булево значение.

				Подробнее в главе "Работа со стилями".

			webpack-merge
			
				Плагин для объединения разных файлов конфигурации "webpack". Подробнее в главе "Использование нескольких файлов конфигураций".
			
			webpack-bundle-analyzer
			
				Плагин для анализа сборки в браузере. Установка:
				
					npm i -D webpack-bundle-analyzer
				
				Подключение:
				
					const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
					
					module.exports = {
						plugins: [
							new BundleAnalyzerPlugin(),
						],
					}
				
				Использование через консоль:
				
					webpack --json > stats.json	&& webpack-bundle-analyzer stats.json	//	Создать файл "stats.json" и поместить в него информацию об анализе сборки. Затем запустить плагин для анализа информации из файла "stats.json".

	devtool
	
		Использование инструментов разработки такие как исходные карты проекта (sourcemap). При использовании этой возможности становится удобно делать дебаг кода, так как точки останова будут указывать
		на контретную часть кода и на конкретный исходный файл в исходниках скриптов а так же стилей. Значения свойства указываются в строковом формате. Часто используемые значения свойства "devtool":
		
			'none'
			
				Не использовать исходные карты. Так же в результирующих файлах сборки будет отсутствовать "eval", благодоря чему относительно сохранится структура кода.
			
			'source-map'
			
				Создание отдельного файла карты исходника. При использовании этой возможности, в сборке к каждому исходному файлу кода будет создан файл карты с расширением ".map".
				Рекомендуется для режима сборки - "development".
			
			'eval-source-map'
			
				Использование исходных карт через "eval".
		
		Подробнее "https://webpack.js.org/configuration/devtool/".

	devServer
	
		Настройка сервера разработки. При использовании данного функционала, сборка не будет записываться на диск (не будет помещена в итоговую директорию сборки), а будет храниться в оперативной памяти.
		Данный функционал полезен при режиме сборки "development", так как он быстрее и на лету собирает проект.
		Для начала нужно установать данный функционал:
		
			npm i -D webpack-dev-server
			
		Подробнее "https://webpack.js.org/configuration/dev-server/".
		
		Данное свойство имеет следующие свойства:
		
			static
			
				Свойство для настройки обслуживания (слежения) статичных файлов (ассеты, картинки и т.д.) для сервера (по умолчанию директория "./public").
				При каждом изменении статичных файлов, страница сервера перезагрузится. Значением является булево значение или объект со свойствами:
				
					directory
					
						Директория для статичных файлов, например ассеты, картинки и т.д. (то, откуда они будут браться для стриминга сервера). Данная настройка позволяет указывать путь к
						статичным файлам. С помощью данного свойства можно перезагружать страницу на сервере, при каждом изменении. Так же в с помошью данного свойства можно указать
						директорию для стриминга статичных файлов, которые к примеру могут понадобится в шаблоне "HTML".
		
					publicPath
					
						Указывает серверу, по какому адресу будут доступны статичные файлы из свойства "directory" для сервера. Подробнее "https://webpack.js.org/configuration/dev-server/#publicpath".

					watch
			
						Позволяет настроить перезагрузку страницы при изменении в статичных файлах. По умолчанию включен. Значением является булево значение.
						
				Объектов со свойствамии может быть сколько угодно, в зависимости сколько статичных файлов (или директорий) нужно будет настроить отдельно. В таком случае значением свойства "static"
				будет массив с этими объектами.
				
				Данное свойство можно использовать для слежения за изменением "HTML" файлов.
			
			watchFiles
			
				Свойство, которое позволит следить за изменениями указанных файлов или директорий. Значением может являться массив с адресами файлов, или адресами директорий. Так же значением
				может являться и объект, для более детальной настройки (подробнее "https://webpack.js.org/configuration/dev-server/#devserverwatchfiles").
				Данное свойство можно использовать для слежения за изменением "HTML" файлов.
				
				Пример с использоанием массива в качестве значения:
				
					watchFiles: [path.resolve(__dirname, 'src/index.html')]
			
			port
			
				Порт, на котором будет запущен сервер. Значением обычно является "8080".
				
			open
			
				Открыть адрес сервера в браузере при запуске сервера. Значением является булево значение.
				
			hot
			
				"Горячая подгрузка" - обновление страницы при каждом изменении в исходниках. Обновление будет происходить только при изменении в стилях и скриптах а не в "HTML".
				Чтобы обновлять страницу и при изменении "HTML", можно воспользоваться свойством "watchFiles", или свойством "static".
				Значением является булево значение.
		
		Пример конфигурации:
		
			devServer: {
				static: [
					{
						directory: path.resolve(__dirname, 'src'),
					},
					{
						directory: path.resolve(__dirname, 'dist'),
					}
				],
				watchFiles: [path.resolve(__dirname, 'src/index.html')],
				port: '8080',
				hot: true,
				open: true,
			}
		
		• Запуск сервера. Запустить сервер можно через консоль, введя команду "webpack serve". Удобнее будет добавить произвольное поле в скрипты в "package.json":
		
			{
				"name": "webpack-project",
				"version": "1.0.0",
				"description": "",
				"scripts": {
					"serve": "webpack serve"
				},
			}	

	context

		Указывает контекст сборки (указывает сборщику "webpack" где лежат все исходники проекта). Если данное свойство было использовано, то все пути файлов в остальных свойствах
		(например "entry" и т.д.), нужно будет корректировать основываясь на контексте. Значением указывается абсолютный путь до проекта (рекомендуется использовать встроенный модуль в "node.js",
		который называется "path").

		Пример без использования контекста сборки:

			module.exports = {
				entry: {
					main: './src/index.js',
					analitics: './src/analitics.js',
				}
			}

		Пример с использованием контекста сборки:

			const path = require('path');

			module.exports = {
				context: path.resolve(__dirname, 'src'),
				entry: './index.js',						// откорректирован путь из-за использования контекста.
				output: {
					filename: 'bundle.js',
					path: path.resolve(__dirname, 'dist'),
				},
			}

	resolve

		Установка расширений, путей и т.д по умолчанию. Значением данного свойства будет объект со свойствами:

			extensions
			
				Массив с расширениями файлов, которые сборщику нужно понимать по умолчанию. Если использовать данное свойство, то нужно будет отредактировать пути
				(ссылки, адреса) везде во всем проекте, так чтобы они не содержали указанных расширений, потому что сборщик и будет брать по умолчанию.
				Данное свойство необходимо при использовании "Typescript", для работы импортов без добавления расширения в конце имени импортируемого файла:
				
					module.exports = {
						resolve: {
							extensions: ['.ts', '.js']
						},
					}

			alias
			
				Объект для создания шаблонов путей. Свойствами этого объекта будут пользовательские (произвольные) именя для путей (в начале добавляется символ "@"), а
				значениями будут уже сами пути. Используются эти шаблоны уже простой вставкой этого пути в (например) импорт.

		Пример:
		
			"webpack.config.js":

				const path = require('path');

				module.exports = {
					resolve: {
						extensions: ['jpg', 'gif', 'js'],
						alias: {
							'@models': path.resolve(__dirname, 'src/assets/models'),
							'@': path.resolve(__dirname, 'src/assets/models/temp'),
						}
					}
				}
			
			"index.js":
			
				import Post from '@models/Post'

	optimization

		Оптимизация сборки проекта. Данное свойство является объектом, который содержит свойства:

			splitChunks
			
				Если два скриптовых файла используют одну и ту же библиотеку, то в финальной сборке эта библиотека будет в обоих скриптовых файлах.
				Данное свойство необходимо для решения данной проблемы. Способ разбиения "кусков" финальной сборки на разные файлы соблюдая зависимости и оптимизируя
				(не добавляя один и тот же код во все связанные скриптовые файлы). Данное свойство является объектом со свойствами:

					chunks	-	позволяет выбрать какой именно чанк выбрать. Значения:

						"all"	-	все чанки.
			
			minimizer
			
				Массив с плагинами для миинификации кода. Данная опция работает в зависимости от режима сборки.
				! Примерчание, если иcпользовать данное свойство, то уже пропадет действие встроенных плагинов минимайзеров (например для "javascript"
				по умолчанию ("terser-webpack-plugin")). Для того, чтобы вернуть встроенные минимайзеры, достаточно добавть "`...`" в массив минимайзеров ("minimizer").
				
				Список плагинов для минификации:
				
					css-minimizer-webpack-plugin
					
						Плагин для минификации "css". Установка:
						
							npm i -D css-minimizer-webpack-plugin
						
						Подключение:
						
							const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
							
							module.exports = {
								optimization: {
									minimizer: [
										`...`,
										new CssMinimizerPlugin(),
									],
								},
							};
							
					terser-webpack-plugin
					
						Встроенный плагин для "javascript". Данный плагин включен по умолчанию, и при отключении нет необходимости вручную добавлять этот плагин,
						так как его функционал можно вернуть просто добавив "`...`" в список миинимайзеров.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Оптимиизация режимов сборки.

Для более удобной работы с конфигурацией "Webpack" рекомендуется пользоваться несколькими файлами конфигурациии "Webpack".
Подробнее в главе "Использование нескольких файлов конфигураций".

Установить режим сборки можно через непосредственное указание режима в консольных командах "Webpack" (подробнее в главе "Консольные команды "webpack"), или через настройку
свойства "mode" объекта "module.exports" (подробнее в свойстве "mode" объекта "module.exports") (последний более гибкий для настойки).

• Режим сборки "development". Рекомендации:

	1. При подключении готовых стилей, рекомендуется использовать только лоадеры "style-loader" и "css-loader", так как они быстрее обрабатываются и не создают отдельный файл стилей.
	Подробнее в главе "Работа со стилями".
	
	2. Не рекомендуется использование минификаци кода, так как после этого труднее делать отладку кода, и так как сборка занимает больше времени.
	Подробнее в главе "Минификация кода".
	
	3. Не рекомендуется делать транспиляцию кода и использовать полифилы, так как сборка занимает больше времени.
	Подробнее в главе "Транcпиляция кода и полифилы".
	
	4. Рекомендуется использование соурсмапов, так как это облегчит отладку кода. Подробнее в свойстве "devtool" объекта "module.exports".
	
	5. Рекомендуется использование дев-сервера, так как сборка будет проводиться быстро, и сама сборка будет храниться в оперативной памяти, а не на диске. Так же сборка будет
	собираться автоматически, и изменения сборки будут видны сразу. Подробнее в свойcтве "devServer" объекта "module.exports".
	
	6. Не рекомендуется использование свойства "splitChunks", объекта "optimization" (объекта "module.exports"), так как сборка будет занимать больше времени.
	Подробнее в свойcтве "optimization" объекта "module.exports".

• Режим сборки "production". Рекомендации:

	1. При подключении готовых стилей, рекомендуется использовать только лоадер плагина "mini-css-extract-plugin" и лоадер "css-loader", так как они создают отдельный файл стилей,
	и держат код разбитым. Подробнее в главе "Работа со стилями".
	
	2. Рекомендуется использование минификаци кода так как это уменьшает и оптимизирует сборку.
	Подробнее в главе "Минификация кода".
	
	3. Рекомендуется делать транспиляцию кода и использовать полифилы, так как готорый проект будет иметь возможность быть использованным на устаревших системах (браузерах).
	Подробнее в главе "Транcпиляция кода и полифилы".
	
	4. Не рекомендуется использование соурсмапов, так как отладка кода будет проводиться в режиме сборки - "development". Подробнее в свойстве "devtool" объекта "module.exports".
	
	5. Не рекомендуется использование дев-сервера, так как в этом режиме важно проверять структуру файлов на выходе при каждой сборке.
	Подробнее в свойcтве "devServer" объекта "module.exports".
	
	6. Рекомендуется использование свойства "splitChunks", объекта "optimization" (объекта "module.exports"), чтобы уменьшить размер сборки, на случай использования одной
	библиотеки, в разных файлах скриптов, для его вынесения. Подробнее в свойcтве "optimization" объекта "module.exports".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Использование нескольких файлов конфигураций.

Использование нескольких файлов конфигураций удобно в случае разделения способов сборки ("development", "production").

Для разделения способов сборки создается (к примеру) файл "webpack.development.js" для конфигурации настроек, которые нужны только при режиме сборки - "development",
так же создается (к примеру) файл "webpack.production.js" для конфигурации настроек, которые нужны только при режиме сборки - "production".

После создания файлов конфигурации для каждого режима сборки, эти файлы конфигурации могут применяться через консоль или через скрипты в "package.json. Для этого сборка вызывается
с флагом "--config", после чего указывается имя нужного файла конфигурации. Пример:

	// файл "package.json"
	
	{
		"name": "webpack-project",
		"version": "1.0.0",
		"description": "",
		"scripts": {
			"dev": "webpack --config webpack.development.js",
			"build": "webpack --config webpack.production.js"
		},
	}

Данный способ можно улучшить. Так как оба файла конфигурации могут местами содержать одинаковый код, повторяющийся код можно будет переместить в общий файл конфигурации.
После создания файлов конфигурации для каждого режима сборки, еще создается файл "webpack.common.js" для конфигурации общих настроек для обоих режимов сборки.
Далее общий файл конфигурации "webpack.common.js" должен быть объеденен с каждым файлом конфигурации в зависимости от требуемого режима сборки.
Для этого нужно установить плагин "webpack-merge":

	npm i -D webpack-merge

Далее нужно импортировать общий файл конфигурации и плагин "webpack-merge" в каждый файл конфигурации способа разаботки (плагин импортируется не по умолчанию):

	const common = require('./webpack.common.js');
	const { merge } = require('webpack-merge');

Затем нужно модифицировать объект "module.exports" в каждом файле конфигурации способа разаботки. Теперь вместо объекта он будет равен результату вызова функции "merge",
который будет принимать объекты конфигураций, которые будут в итоге объединены.

В результате файл конфигурации "webpack.development.js" будет выглядеть так:

	const common = require('./webpack.common.js');
	const { merge } = require('webpack-merge');
	
	module.exports = merge(common, {
		// объект конфигурации для режима "development".
	});

Файл конфигурации "webpack.production.js" будет выглядеть так:

	const common = require('./webpack.common.js');
	const { merge } = require('webpack-merge');
	
	module.exports = merge(common, {
		// объект конфигурации для режима "production".
	});

В файле "webpack.common.js" будут настройки, которые будут распространяться на оба файла конфигурации режимов сборки.

Применяться данный способ будет так же (через консоль или через скрипты в "package.json"), указав нужный файл конфигурации.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Паттерны имен. 

В именах выходных файлов можно использовать паттерны, которые будут вставать на указанное моесто в имени выходного файла. Сами паттерны указываются в квадратных скобках "[]".

Список основных паттернов:

	[name]
	
		Если в "entry" исспользуется несколько входных файлов, то вместо этого паттерна на результирующее имя файла станет имя входного файла.
	
	[contenthash]
	
		Добавление хэша по контенту выходного файла. Данное свойство используется для отмены кеширования файлов проекта браузером.
	
	[hash]
	
		Добавление хэша по имени. Используется при использоании лоадера "file-loader".

	[ext]
	
		Добавление расширения файла.

В имя ассета так же можно добавить желаемую директорию:

	'images/[name].[ext]'
	
	Примеры использования паттернов имен:
		
		module.exports = {
			context: path.resolve(__dirname, 'src'),
			mode: 'development',
			entry: {
				main: './index.ts',
				analytics: './analytics.ts'
			},
			  output: {
				path: path.resolve(__dirname, "dist"),
				filename: "[name].[contenthash].bundle.js",		// Для "main" выходное имя будет "main.<хэш>.bundle.js", а для "analytics" будет "analytics.<хэш>.bundle.js".
			},
		}

Подробнее "https://webpack.js.org/configuration/output/#template-strings".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа со стилями.

Для работы со стилями, нужно импортировать его во входном скриптовом файле (в файле, который указан в свойстве "entry").
При импортировании стилей, не пишется ключевое слово "from". Пример импортирования:

	// JS или TS файл

	import './styles/styles.css'	// или любой другой "css" препроцессор.

Далее для работы стилей нужно установить соответствующий лоадер (подробнее в главе "Модули-загрузчики").

Для добавления стилей есть два способа:

	1. Добавление стилей в тег "<style>" через использование плагинов "style-loader" и "css-loader".

	2. Выведение скриптов в отдельный файл, используя лоадер плагина "mini-css-extract-plugin" и лоадер "css-loader".
	
• Первый способ лучше при режиме сборки - "development", так как он быстрее. А второй способ для режима сборки - "production", так как он хранит стили в отдельном ".css" файле.

При подключении лоадеров для стилей, они в массиве (где они перечислены) будут применяться справа налево (то есть с конца к началу).
Например в'["style-loader", "css-loader"]' сначала будет выполнен "css-loader", затем "style-loader". "css-loader" превращает "css" код в модуль и добавляет его в "javascript".
"style-loader" подключает "css" модуль, созданный с помощью лоадера "css-loader" к странице "HTML" через тег "<style>".

• Добавление стилей в тег "<style>" через использование плагинов "style-loader" и "css-loader". Для этого нужно их установить:

	npm i -D style-loader css-loader

Далее их нужно подключить соблюдая порядок. Пример использования лоадеров "style-loader" и "css-loader": 

	const path = require('path');

	module.exports = {
		entry: {
			main: path.resolve(__dirname, 'src/app.js'),
		},
		output: {
			path: path.resolve(__dirname, 'dist'),
			filename: '[name].[contenthash].js',
		},
		
		module: {
			rules: [
				{
					test: /\.css$/,
					use: ['style-loader', 'css-loader']
				},
			],
		},
	};

• Выведение скриптов в отдельный файл, используя лоадер плагина "mini-css-extract-plugin" и лоадер "css-loader".

	npm i -D mini-css-extract-plugin css-loader

Далее нужно создать новый инстанс плагина "mini-css-extract-plugin", и подключить его как плагин.
Далее их нужно подключить как лоадеры соблюдая порядок.
При подключении плагина "mini-css-extract-plugin" в его конструктор можно передать объект с конфигурациями. Подробнее в плагине "mini-css-extract-plugin".
Пример использования лоадера "css-loader" и лоадер плагина "mini-css-extract-plugin": 

	const path = require('path');
	const MiniCssExtractPlugin = require("mini-css-extract-plugin");

	module.exports = {
		entry: {
			main: path.resolve(__dirname, 'src/app.js'),
		},
		output: {
			path: path.resolve(__dirname, 'dist'),
			filename: '[name].[contenthash].js',
		},
		
		module: {
			rules: [
				{
					test: /\.css$/,
					use: [
						MiniCssExtractPlugin.loader, 	// Выгрузить стили, превращенные в модули из 'js' в отдельный файл.
						"css-loader", 					// Превратить "css" в модули в "js".
					]
				},
			],
		},
		
		plugins: [
			new MiniCssExtractPlugin({
				filename: "[name].[contenthash].css"
			}),
		],
	};

• Использование препроцессоров. Их установка, подключение и использование ничем не отличается от других лоадеров стилей. Главное соблюсти порядок подключения в массиве
лоадеров стилей. Пример с препроцессором "sass":

	Установка:
	
		npm i -D sass-loader css-loader style-loader
	
	Конфигурация:
		
		const path = require('path');
	
		module.exports = {
			entry: {
				main: path.resolve(__dirname, 'src/app.js'),
			},
			output: {
				path: path.resolve(__dirname, 'dist'),
				filename: '[name].[contenthash].js',
			},
			
			module: {
				rules: [
					{
						test: /\.s[ac]ss$/,
						use: [
							"style-loader",		// Добавить стили, превращенные в модули из 'js' в "HTML" через тег "<style>".
							"css-loader",		// Превратить "css" в модули в "js".
							"sass-loader",		// Превратить "sass" ("scss") в "css".
						]
					},
				],
			},
		};

При использовании ассетов в стилях (картинки, шрифты и т.д.), они будут обработаны в соответствии с добавленными лоадерами, и будут находиться в указанных выходных директориях
с указанными именами. Подробнее в главе "Работа с файлами и ассетами".

• Подключение библиотек стилей.

Подключение "normalize.css". Для этого нужно для начала его установить:

	npm i normalize

Затем подключить его в нужном файле стилей:

	@import '~normalize.css'

Тильда ("~") в импорте указывает что библиотека импортируется из модулей "Node" ("node_modules").

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Минификация кода.

• Минификация "HTML".

	Минификация "HTML" происходит автоматически в зависимости от режима сборки ("development", "production"). Но можно вручную дополнительно настроить минификацию кода.
	Все способы минификации "HTML":
	
		1. Автоматически, в зависимости от режима сборки ("development", "production").
	
		2. Через настройку лоадера "hmtl-loader". Подробнее в лоадере "hmtl-loader".
		
		3. Более детальная настройка миинификации через плагин "html-webpack-plugin". Подробнее в плагине "html-webpack-plugin".

• Минификация "javascript".

	Минификация "javascript" происходит автоматически в зависимости от режима сборки ("development", "production"). Для дополнительный настройки можно добавить нужный плагин
	минификации, импортировать его и добавить в массив с минификаторами объекта "minimizer", объекта "optimization", объекта "module.rules".
	
• Минификация ".css".

	Минификация стилей в файле ".css" не происходит автоматически в зависимости от режима сборки.
	Для его минификации можно воспользоваться плагином "css-minimizer-webpack-plugin" (подробнее в свойстве "minimizer", объекта "optimization", объекта "module.rules").

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа с файлами и ассетами.

• Импортирование ассетов из шаблонов "HTML".

	Если в шаблоне содержатся ассеты (например через атрибут "src"), то для их правильной загрузки понадобится отдельный лоадер. Подробнее в лоадере "html-loader".

• Испортирование ассетов в "javascript" ("typescript").

	Для работы с файлами в скриптах, их нужно импортировать. После чего нужно установить соответствующий лоадер. Пример импортирования:

		import img from './assets/image.png'

	или:

		const img = require('./image.png')

	• При импортировании картирок (файлов), импортируется их адрес.

	• Для ассетов (для скриптов и стилей) есть лоадер "file-loader", но его не рекомендуется использовать, так как в новых версиях "Webpack" есть встроенный лоадер "type"
	(подробнее в свойстве "type" объекта правил "rules" ("module.exports" -> "module" -> "rules" -> "type")).

• Для копирования статичных ассетов можно использовать плагин "copy-webpack-plugin". Подробнее в плагине "copy-webpack-plugin".

• Использовании ассетов в стилях.

	При использовании ассетов в стилях, для них понадобится лоадер. Использоание лоадера "css-loader" автоматически решит эту проблему (подробнее в лоадере "css-loader").
	Далее можно настросить имя выходных ассетов в свойстве "assetModuleFilename" в объекте "output" объекта "module.exports".
	
	Другим же вариантом является использование встроенного лоадера "type" ("module.exports" -> "module" -> "rules" -> "type"). Имена выходных ассетов в таком случае можно настроить
	двумя способами:
	
		1. Через настройку свойства "assetModuleFilename" в объекте "output" объекта "module.exports".
		
		2. Через свойство "generator" у объекта правил "rules" ("module.exports" -> "module" -> "rules" -> "generator").

	• При одновременном использовании лоадера "file-loader" с лоадером "css-loader", файлы ассетов (которые использовались в стилях) будут дублироваться в итоговой папке сборки.

	• Одновременное использование встроенного лоадера "type" не влияет на использование встренного лоадера для ассетов у лоадера "css-loader", разве что если настроить
	объект "generator" (у объекта плавил "rules" ("module.exports" -> "module" -> "rules")), и изменить там имя выходных ассетов.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Транcпиляция кода и полифилы.

Для транспиляции кода "javascript" (или "typescript") новых стандартов на старые стандарты, для их корректной обработки старыми браузерами существует транскомпилятор "Babel".

Для начала его нужно установить, и установить его зависимости:

	npm i -D @babel/core babel-loader @babel/preset-env
	
		@babel/core
		
			Это сам "Babel" (его ядро).
			
		babel-loader
		
			Лоадер "Babel" для "Webpack", чтобы "Webpack" мог его обработать.
			
		@babel/preset-env
		
			Пресет для работы "Babel". Пресеты это наборы готовых плагинов для "Babel" (плагины у "Babel" позволяют настроить поддержку старых браузеров).

Затем нужно подключить лоадер "babel-loader" в список лоадеров "Webpack":

	module.exports = {
			module: {
				rules: [
					{
						test: /\.js$/,
						exclude: /node_modules/,
						use: {
							loader: 'babel-loader',
						},
					},
				],
			},
		};

Есть два способа настройка лоадера:

	1. Настройка лоадера в файле конфигурации "Webpack".

	2. Настройка лоадера в отдельном файле ".babelrc" в корне проекта.

• Настройка лоадера в файле конфигурации "Webpack":

	use: {
		loader: 'babel-loader',
		options: {
			presets: ['@babel/preset-env'],
		}
	},

• Настройка лоадера в отдельном файле ".babelrc" в корне проекта. Если у лоадера нет настроек в файле конфигурации "Webpack" (нет поля "options"), то "Webpack" будет искать файл
с конфигурациями ".babelrc" для "Babel". Для этого способа подключить лоадер в файле конфигурации "Webpack" все равно нужно:

	use: {
		loader: 'babel-loader',
	},

Настройка файла конфигурации ".babelrc". В корне этого файла лежит объект, который будет содержать свойства настройки. Имена свойств (и значений) пишутся в двойных кавычках.
Список свойств:

	presets
	
		Массив с отдельными пресетамии для "Babel". Пресеты:
		
			@babel/preset-env

Пример настройки файла ".babelrc":

	{
	
		"presets": ["@babel/preset-env"]
	
	}

• Полифилы.

Хотя пресет "@babel/preset-env" и транспилирует код на старые версии, по умолчанию "Babel" умеет транспилировать не все. Он не умеет например транспилировать "async" "await", 
встроенные методы (например метод "includes" у массивов) и т.д. Для полной транспиляции кода понадобятся полифилы.

• Использование полифилоов значительно увеличивают размер выходного кода, так как полифил это библиотека, и он смешивается с выходным файлом.

Установка полифила:

	npm i @babel/polyfill
	
		Устанавливается как зависимость проекта, а не разработки, так как этот полифил является "javascript" библиотекой.

Использование. Подключение полифила происходит иначе, так как он считается как библиотека. Для этого полифил добавляется вместе с входным скриптовым файлом в одной связке
(в массиве):

	module.exports = {
		entry: {
			main: ['@babel/polyphill', './src/index.js'],		// В данной точке входа используются оба файла '@babel/polyphill' и './src/index.js'.
			analitics: './src/analitics.js',
		}
	}

• Плагины.

Можно дополнительно добавить плагины для "Babel", которые добавляют дополнительный функционал. Список плагинов:

	@babel/plugin-proposal-class-properties
	
		Добавить возможность транспиляции свойств, которые находятся на стадии предложения, а именно функционал свойств у классов.
	
Далее нужно установить нужный плагин. Например:

	npm i -D @babel/plugin-proposal-class-properties
	
Затем нужно добавить поле "plugins" в объект настройки "options" лоадера "babel-loader", для подключения этого плагина. Значением этого поля будет массив с плагинами:

	use: {
			loader: 'babel-loader',
			options: {
				presets: ['@babel/preset-env'],
				plugins: ['@babel/plugin-proposal-class-properties'],
			}
		}

Можно дополнительно указать, под какие браузеры транспилировать код. Для этого в файл "package.json" добавляется поле "browserslist" со
значением "> 0.25%, not dead". "> 0.25%" означает браузеры имеющие больше 0.25% пользователей на рынке, "not dead" означает обраузеры, которые не "мертвы". Пример:

	// файл "package.json"
	
	"browserslist": "> 0.25%, not dead"

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Готовые файлы конфигурации "Webpack".

Пример использования трех файлов конфигурации "Webpack" (один для режима сборки - "development", другой для режима сборки - "production", и третий общий):

	Содержимое файла ".gitignore":
	
		dist
		node_modules

	Зависимости разработки в файле "package.json":
	
		"devDependencies": {
			"copy-webpack-plugin": "^10.2.0",
			"css-loader": "^6.5.1",
			"css-minimizer-webpack-plugin": "^3.3.0",
			"file-loader": "^6.2.0",
			"html-loader": "^3.0.1",
			"html-webpack-plugin": "^5.5.0",
			"mini-css-extract-plugin": "^2.4.5",
			"style-loader": "^3.3.1",
			"webpack": "^5.65.0",
			"webpack-cli": "^4.9.1",
			"webpack-dev-server": "^4.6.0",
			"webpack-merge": "^5.8.0"
		}
	
	Поле "scripts" файла "package.json":
	
		"scripts": {
			"serve": "webpack serve --config webpack.config.development.js",
			"dev": "webpack --config webpack.config.development.js",
			"build": "webpack --config webpack.config.production.js",
			"watch": "webpack --config webpack.config.development.js --watch"
		},

	Файл "webpack.config.common.js":
	
		const path = require('path');
		const HTMLWebpackPlugin = require('html-webpack-plugin');
		const CopyWebpackPlugin = require('copy-webpack-plugin');

		module.exports = {
			context: path.resolve(__dirname, 'src'),
			entry: './index.js',
			output: {
				filename: '[name].bundle.[contenthash].js',
				clean: true,
				path: path.resolve(__dirname, 'dist'),
			},
			module: {
				rules: [
					{
						test: /\.(svg|png|jpg|gif)$/,
						exclude: /node_modules/,
						type: 'asset/resource',
						generator: {
							filename: 'img/[contenthash][ext]',
						}
					}
				]
			},
			plugins: [
				new HTMLWebpackPlugin({
					template: './index.html',
				}),
				new CopyWebpackPlugin({
					patterns: [
						{
							from: path.resolve(__dirname, 'public'),
							to: path.resolve(__dirname, 'dist')
						},
					]
				}),
			],
		}

	Файл "webpack.config.development.js":
	
		const path = require('path');
		const common = require('./webpack.config.common');
		const { merge } = require('webpack-merge');

		module.exports = merge(common, {
			mode: 'development',
			module: {
				rules: [
					{
						test: /\.css$/,
						exclude: /node_modules/,
						use: ['style-loader', 'css-loader'],
					},
				]
			},
			devtool: 'source-map',
			devServer: {
				static: {
					directory: path.resolve(__dirname, 'src'),
				},
				port: '8080',
				hot: true,
				open: true,
			}
		});
	
	Файл "webpack.config.production.js":
	
		const common = require('./webpack.config.common');
		const MiniCssExtractPlugin = require('mini-css-extract-plugin');
		const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
		const { merge } = require('webpack-merge');

		module.exports = merge(common, {
			mode: 'production',
			optimization: {
				minimizer: [
					`...`,
					new CssMinimizerPlugin(),
				],
			},
			module: {
				rules: [
					{
						test: /\.css$/,
						exclude: /node_modules/,
						use: [MiniCssExtractPlugin.loader, 'css-loader'],
					},
				]
			},
			plugins: [
				new MiniCssExtractPlugin({
					filename: '[name].bundle.[contenthash].css',
				}),
			],
		});

























































