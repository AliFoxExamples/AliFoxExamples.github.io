npm install -D webpack webpack-cli

	"webpack"		-	корневой функционал "webpack".
	
	"webpack-cli"	-	функционал команд, которые будут доступны в консоли.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ При использовании сборщика "webpack", выходной файл скрипта автоматически будет собран так, что в нем будут соблюдены все зависимости. Для этого в разных скриптовых файлах нужно
воспользоваться импортированием/экспортированием. Больше не нужно будет следить за порядком очереди тегов "script" в "HTML", так как сборщик соберет единый выходной скриптовой
файл соблюдая все зависимости всех связанных между собой скриптовых файлов. При использовании в скриптах ("js", "ts") файлов-ассетов из директорий разработки, их необходимо
импортировать, для того, чтобы сборщик правильно собрал проект с соблюдением всех зависимостей (путей к файлам).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Консольные команды "webpack". Использование команд "webpack" в консоли начинается с префикса "webpack". Пример:

	webpack

Консольные команды могут писаться с флагами:

	webpack --mode development

Список консольных команд:

	webpack	-	построить билд на основе текущих конфигураций.

Список флагов:

	--mode	-	указать способ сборки. Способы сборки:

		production	-	делать билд в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется.

		development	-	делать билд в режиме разработчика. Собранный код в данном режиме не минифицирован.

	Пример использования:

		webpack --mode development

	--watch	-	следить за изменениями файлов. Приммер использования:

		webpack --mode development --watch

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Настройка файла конфигурации "webpack", который называется "webpack.config.js".

• Настройка файла конфигурации "webpack.config.js". По умолчанию "webpack" сразу ищет наличие данного файла, и настраивает конфигурции согласно его содержимому.
Сам "webpack.config.js" является инструментом сборки, и не будет относиться к самому проекту.
Можно менять название "webpack.config.js" на произвольное //ДОПОЛНИТЬ

Настройка файла конфигурации "webpack.config.js" это значит прописывание свойств объекту конфигурации "exports" ("module.exports"):

	// файл "webpack.config.js"webpack.config.js".

	module.exports = {
		// свойства.
	}

Свойства объекта "exports":

	context

		Указывает контекст сборки (указывает сборщику "webpack" где лежат все исходники проекта). Если данное свойство было использовано, то все пути файлов в остальных свойствах
		(например "entry" и т.д.), нужно будет корректировать основываясь на контексте. Значение рекомендуется использовать встроенный модуль в "node.js", который называется "path"
		(пример приведен ниже). Подробнее о модуле "path" в руководстве "node-js".
		Пример без использования контекста сборки:

			module.exports = {
				entry: {
					main: './src/index.js',
					analitics: './src/analitics.js',
				}
			}

		Пример с использованием контекста сборки:

			const path = require('path');

			module.exports = {
				context: path.resolve(__dirname, 'src'),	//	подробнее в руководстве "node-js".
				entry: './index.js',						// откорректирован путь из-за использования контекста.
				output: {
					filename: 'bundle.js',
					path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
				},
			}

	mode

		Указывает сборщику "webpack", в каком режиме делать билд. Значение пишется в строковом виде. Значения:

			production	-	делать билд в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется.

			development	-	делать билд в режиме разработчика. Собранный код в данном режиме не минифицирован.

		Пример:

			module.exports = {
				mode: 'development',
			}

	entry

		Значением данного свойства будет путь входного файла или файлов. Формат пути может быть в строковом формате (если файл имеется только один), и так же объект, с путями.
		Если будет использоваться объект с путями, то имена свойств будут произвольными (для главного пути рекомендуется использовать имя "main"), а значениями этих свойств будут
		пути этих файлов в строковом формате. Другими словами свойство "entry" указывает сборщику ("webpack") откуда начать. Пример:

			module.exports = {
				entry: './src/index.js',
			}

		Пример с использованием нескольких входных путей:

			module.exports = {
				entry: {
					main: './src/index.js',
					analitics: './src/analitics.js',
				}
			}

	output

		Значением данного свойства будет объект со свойствами результата сборки. Свойства объекта "output":

			filename

				Значением данного свойства будет имя собраного "js" файла в строковом формате, другими словами указывает сборщику ("webpack") как назвать выходной файл скриптов.
				Обычно этот файл принято называть "bundle.js". Файлов будет столько, сколько указано входных файлов в свойстве "entry" объекта "exports".
				• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

			path

				Значением данного свойства будет путь выходных файлов в строковом формате, другими словами указывает сборщику ("webpack") куда ложить сборку. Значение можно указывать
				просто в строковом формате, но рекомендуется использовать встроенный модуль в "node.js", который называется "path" (пример приведен ниже). Подробнее о модуле "path" в
				руководстве "node-js". Обычно имя выходной директории принято называть "dist".

		Пример:

				const path = require('path');

				module.exports = {
					entry: {
						main: './src/index.js',
						analitics: './src/analitics.js',
					},
					output: {
						filename: '[name].bundle.js',
						path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
					},
				}

		• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

	resolve

		Установка расширений, путей и т.д по умолчанию. Значением данного свойства будет объект со свойствами:

			extentions	-	массив с расширениями файлов, которые сборщику нужно понимать по умолчанию. Если использовать данное свойство, то нужно будет отредактировать пути
			(ссылки, адрема) везде во всем проекте, так чтобы они не содержали указанных расширений, потому что сборщик и будет брать по умолчанию.

			alias	-	объект для создания шаблонов путей. Свойствами этого объекта будут пользовательские (произвольные) пути (рекомендуется в начале добавить символ "@"), а
			значениями будут уже сами пути.

		Пример:

			const path = require('path');

			module.exports = {
				resolve: {
					extentions: ['jpg', 'gif', 'js'],
					alias: {
						'@models': path.resolve(__dirname, 'src/assets/models'),
						'@': path.resolve(__dirname, 'src/assets/models/temp'),
					}
				}
			}

	optimization

		Оптимизация сборки проекта. Если два скриптовых файла используют одну и ту же библиотеку, то в финальной сборке эта библиотека будет в обоих скриптовых файлах. Данное
		свойство необходимо для решения данной проблемы. Данное свойство является объектом, который содержит свойства:

			splitChunks	-	способ разбиения "кусков" финальной сборки на разные файлы соблюдая зависимости и оптимизируя (не добавляя один и тот же код во все связанные
			скриптовые файлы). Данное свойство является объектом со свойствами:

				chunks	-	позволяет выбрать какой именно чанк выбрать. Значения:

					"all"	-	все чанки.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Паттерны имен. 

https://youtu.be/eSaF8NXeNsA?t=2014
https://youtu.be/eSaF8NXeNsA?t=2338
https://webpack.js.org/configuration/output/

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Плагины. Плагины позволяют добавить дополнительные функционал к базовой конфигурации "webpack".

Для начала необходимо установить нужный плагин через менеджер пакетов "npm":

	npm install -D <имя плагина>

Пример установки:

	npm install -D html-webpack-plugin

После установки необходимо импортировать этот плагин как класс. Пример:

	const HTMLWebpackPlugin = require('html-webpack-plugin');

У некоторых плагинов есть отличия в методе импортирования плагина, например плагин "clean-webpack-plugin" (подробнее в подглаве "Список плагинов" - "clean-webpack-plugin").

Затем нужно добавить этот новый плагин в объект конфигурации "exports". Для этого добавляется свойство "plugins", значением которого будет массив, где будут перечислены
плагины. Сами плагины добаляются путем создания нового потомка (инстанса) от класса плагина (например "html-webpack-plugin"):

	const path = require('path');
	const HTMLWebpackPlugin = require('html-webpack-plugin');

	module.exports = {
		entry: './src/index.js',
		output: {
			filename: 'bundle.js',
			path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
		},
		plugins: [
			new HTMLWebpackPlugin({
				title: "New page",
			}),
		],
	}

• Список плагинов:

	html-webpack-plugin	-	плагин для сборки "html" файлов. При использовании данного плагина, можно не указывать скрипты вручную в "html" файле, так как плагин сам их автоматически добавит.
	В конструктор класса опционально можно передать объект со свойствами, которые будут применены к ново-создаваемому "html" файлу (пример приведен выше).
	Свойства объекта, передаваемый конструктору класса:

		title	-		заголовок страницы. В значении указывается имя заголовка, в строковом формате. Если используется шаблон "html" файла, который уже имеет заголовок, то данное свойство
		бесполезно.

		template	-	шаблон "html" файла, основываясь на котором будет собираться новый "html" файл. В значении указывается адрес шаблона, в строковом формате.

		minify	-	объект со свойствами минифицирования. Свойства:

				collapseWhitespace	-	///

	clean-webpack-plugin	-	плагин для очищения папки сборки перед сборкой. У данного плагина есть отличия в методе подключения, так как у него импортируется объект. Чтобы получить
	класс плагина, нужно деструктуризировать импортируемый объект:

		const {CleanWebpackPlugin} = require('clean-webpack-plugin');

		module.exports = {
			entry: './src/index.js',
			output: {
				filename: 'bundle.js',
				path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
			},
			plugins: [
				new CleanWebpackPlugin(),
			],
		}

	copy-webpack-plugin		-	плагин для копирования файлов и директорий. В конструктор класса передается объект с требуемыми свойствами, которые содержат массив с объетами,
	которые содержат свойства настройки. Пример:

		const CopyWebpackPlugin = require('copy-webpack-plugin');

		module.exports = {
			plugins: [
				new CopyWebpackPlugin({
					patterns: [
						{
							from: path.resolve(__dirname, 'src/assets'),
							to: path.resolve(__dirname, 'dist/assets')
						}
					]
				})
			],
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Модули-загрузчики. Сборщик "webpack" умеет работать только со скриптами, и для того чтобы он умел работать с другими типами файлов (например стили, картиник и т.д.),
нужно подключить соответствующий модуль-загрузчик. Под модулями-загрузчиками в этой главе не имеются ввиду модули "js".

Для начала необходимо установить сами лоадеры (загрузчики). Устанавливается он так же как и плагины (смотрите выше). Список лоадеров:

	css-loader	-	позволяет сборщику понимать не стандартные импорты указанные во входном скриптовом файле (пример импортирование стилей во входном "js" файле" (подробнее в главе
	"Работа со стилями")).

	style-loader	-	добавляет стили из "css" файла в тег "head" в "html".

	file-loader		-	 лоадер для работы с файлами.

Для добавления лоадеров нужно добавить свойство "module" в объект конфигурации "exports". У данного свойства будут следующие значения:

	rules	-	массив с объектами правил поведения для соответствующих типов файлов. Объект правил поведения будет иметь следующие свойства:

		test	-	регулярное выражение, которое будет использоваться для подбора типов файлов. Регулярное выражение будет подбирать файл основывясь на указанном/указанных расширениях.
		В случае подбора, будет использоваться лоадер, указанный в свойстве "use".

		use		-	массив с лоадерами, которые необходимо будет задействовать при нахождении файлов регулярным выражением указанным в свойстве "test". В данный массив перечисляются
		имена лоадеров в строковом формате. Примечание! Перечисленные лоадеры в массиве будут применяться справа налево (то есть с конца к началу).

	Пример использования свойства "rules":

		module.exports = {
			module: {
				rules: [
					{
						test: /\.css$/,
						use: ['style-loader', 'css-loader'],
					},
					{
						test: /\.(jpg|png|svg|gif )$/,
						use: ['file-loader'],
					},
				],
			}
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа со стилями. Для работы со стилями, нужно импортировать его во входном скриптовом файле (в файле, который указан в свойстве "entry"). Для этого нужно установить
соответствующий лоадер (подробнее в главе "Модули-загрузчики"). При импортировании стилей, не пишется ключевое слово "from". Пример импортирования:

	import './styles/styles.css'

• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа с файлами. Для работы с файлами, нужно импортировать его во входном скриптовом файле (в файле, который указан в свойстве "entry"). Для этого нужно установить
соответствующий лоадер (подробнее в главе "Модули-загрузчики"). Пример импортирования:

	import './assets/image.png'

• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".






























































