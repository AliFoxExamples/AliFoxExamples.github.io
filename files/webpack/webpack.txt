◘ Установка "Webpack".

	npm install -D webpack webpack-cli

		"webpack"		-	корневой функционал "webpack".
		
		"webpack-cli"	-	функционал команд, которые будут доступны в консоли.
		
		"-D" 			-	флаг, который указывает на то что это зависимость только для разработки.
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ При использовании сборщика "webpack", выходной файл скрипта автоматически будет собран так, что в нем будут соблюдены все зависимости. Для этого в разных скриптовых файлах нужно
воспользоваться импортированием/экспортированием. Больше не нужно будет следить за порядком очереди тегов "script" в "HTML", так как сборщик соберет единый выходной скриптовой
файл соблюдая все зависимости всех связанных между собой скриптовых файлов. При использовании в скриптах ("js", "ts") файлов-ассетов из директорий разработки, их необходимо
импортировать, для того, чтобы сборщик правильно собрал проект с соблюдением всех зависимостей (путей к файлам).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Консольные команды "webpack". Использование команд "webpack" в консоли начинается с префикса "webpack". Пример:

	webpack

Консольные команды могут писаться с флагами:

	webpack --mode development

Список консольных команд:

	webpack
	
		Построить билд на основе текущих конфигураций.

Список флагов:

	--mode
	
		Указать способ сборки. Способы сборки:

			production	-	делать билд в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется.

			development	-	делать билд в режиме разработчика. Собранный код в данном режиме не минифицирован.

	Пример использования:

		webpack --mode development

		--watch
		
			Следить за изменениями файлов. Приммер использования:

				webpack --mode development --watch

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Функция упрощения создания путей "path". При настройке конфигурации "Webpack", при добавлении путей файлов, ассетов и т.д. можно воспользоваться функцией "path" у "Node",
которая упростит создание путей.

Для начала нужно испортировать функцию "path" в начале конфигурационного файла "webpack.config.js":

	const path = require("path");

Создание пути осущетсвляется вызовом этой функции добавление в качестве аргументов куски путей, которые нужно соеденить. Во время использования данной функции может использоваться
системмная переменна "__dirname" у "Node", которая указывает на текущую директорию с проектом.

Пример использования функции упрощения создания путей "path", с директорией проекта "C:\Temp":

	path.resolve(__dirname, 'dist')		//	результатом вызова данной функции будет "C:\Temp\dist".

Пример использования функции упрощения создания путей "path" в конфигурации "webpack.config.js":

	const path = require('path');
	module.exports = {
		entry: {
			main: path.resolve(__dirname, 'src/app.js'),
		},
		output: {
			path: path.resolve(__dirname, 'dist'),
			filename: '[name].[contenthash].js',
		},
	},

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Настройка файла конфигурации "webpack", который называется "webpack.config.js".

• Настройка файла конфигурации "webpack.config.js". По умолчанию "webpack" сразу ищет наличие данного файла, и настраивает конфигурции согласно его содержимому.
Сам "webpack.config.js" является инструментом сборки, и не будет относиться к самому проекту.
Можно менять название "webpack.config.js" на произвольное, после чего вручную указывать на конфигурацию в "package.json" (подробнее в главе "Использование нескольких файлов конфигураций").

Настройка файла конфигурации "webpack.config.js" это значит прописывание свойств объекту конфигурации "exports" ("module.exports"):

	// файл "webpack.config.js".

	module.exports = {
		// свойства.
	}

Свойства объекта "exports":

	mode

		Указывает сборщику "webpack", в каком режиме делать сборку. Значение пишется в строковом виде. Значения:

			production
			
				Делать сборку в режиме "production" (по умолчанию). Собранный код в данном режиме минифицируется.

			development
			
				Делать сборку в режиме разработчика. Собранный код в данном режиме не минифицирован.

		Пример:

			module.exports = {
				mode: 'development',
			}
			
		Можно динамично настроить режим сборки через системное свойство "process.env.NODE_ENV" "Node":
		
			mode: process.env.NODE_ENV === "production" ? "production" : "development",

	entry

		Значением данного свойства будет путь входного файла или файлов. Формат пути может быть в строковом формате (если файл имеется только один), и так же объект, с путями.
		Если будет использоваться объект с путями, то имена свойств будут произвольными (для главного пути рекомендуется использовать имя "main"), а значениями этих свойств будут
		пути этих файлов в строковом формате. Другими словами свойство "entry" указывает сборщику ("webpack") откуда начать. Пример:

			module.exports = {
				entry: './src/index.js',
			}

		Пример с использованием нескольких входных путей:

			module.exports = {
				entry: {
					main: './src/index.js',
					analitics: './src/analitics.js',
				}
			}

	output

		Значением данного свойства будет объект со свойствами результата сборки. Свойства объекта "output":

			filename

				Значением данного свойства будет имя собраного "js" файла в строковом формате, другими словами указывает сборщику ("webpack") как назвать выходной файл скриптов.
				Обычно этот файл принято называть "bundle.js". Файлов будет столько, сколько указано входных файлов в свойстве "entry" объекта "exports".
				• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

			path

				Значением данного свойства будет путь выходных файлов в строковом формате, другими словами указывает сборщику ("webpack") куда ложить сборку. Значение можно указывать
				просто в строковом формате, но рекомендуется использовать встроенный модуль в "node.js", который называется "path" (пример приведен ниже). Подробнее о модуле "path" в
				руководстве "node-js". Обычно имя выходной директории принято называть "dist".
			
			clean
			
				Использование фунции очистки конечной папки сборки при каждой сборке. Значениемм данного свойства является булево значение соответствующее включению и выключению.

###
### Проверить актуальность других плагинов, которые очищают папку сборки ("clean-webpack-plugin") !!!
###

		Пример:

				const path = require('path');

				module.exports = {
					entry: {
						main: './src/index.js',
						analitics: './src/analitics.js',
					},
					output: {
						filename: '[name].bundle.js',
						path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
						clean: true,
					},
				}

		• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

	module
	
		Лоадеры (модули-загрузчики). Сборщик "webpack" умеет работать только со скриптами, и для того чтобы он умел работать с другими типами файлов (например стили, картиник и т.д.),
		нужно подключить соответствующий модуль-загрузчик. Данный модуль превратит файлы других типов, которые импортируются в коде, в отдельные модули.

		Для начала необходимо установить сами лоадеры. Устанавливаются они через "npm" как зависимость для разработки ("--save-dev" или "-D").

		Для добавления лоадеров нужно добавить свойство "module" в объект конфигурации "exports". У данного свойства будут следующие значения:

			rules
			
				Массив с объектами правил поведения для соответствующих типов файлов. Объект правил поведения будет иметь следующие свойства:

					test
					
						Регулярное выражение, которое будет использоваться для подбора типов файлов. Регулярное выражение будет подбирать файл основываясь на указанных расширениях.
						В случае подбора, будет использоваться лоадер, указанный в свойстве "use".
						
						exclude
						
							Указать на директории или файлы, которые будут исключены для лоадера. Например:
						
								exclude: /node_modules/

					use
					
						Использование лоадера или лоадеров которые необходимо будет задействовать при нахождении файлов регулярным выражением указанным в свойстве "test".
						Значением свойства может быть имя лоадера, массив с именами лоадеров, или же объект с более подробной настройкой лоадера. В случае использования массива с именами лоадеров, то в нем
						перечисляются имена лоадеров в строковом формате. Примечание! Перечисленные лоадеры в массиве будут применяться справа налево (то есть с конца к началу).
						
						Пример использования "use" с массивом лоадеров:
						
							use: ['style-loader', 'css-loader']
						
						В случае с использованием объекта, в нем могут быть следующие свойства:
						
							loader
							
								Имя лоадера или массив имен лоадеров.
							
							options
							
								Объект со свойствами для конкретного лоадера.
							
							Пример:
							
								module.exports = {
									module: {
										rules: [
											{
												test: /\.(svg|png|jpg|gif)$/,
												use: {
													loader: "file-loader",
													options: {
														name: "[name].[hash].[ext]",
														outputPath: "imgs"
													}
												}
											},
								}

						Список лоадеров:

							css-loader
							
								Позволяет сборщику загружать зависимые стили в "javascript". Используется вместе с лоадером "style-loader", и дабавляется после "style-loader" в массиве с лоадерами.
								Подробнее в главе "Работа со стилями".

							style-loader
							
								Позволяет сборщику добавлять загруженные стили из "javascript в тег "head" в "html". Используется вместе с лоадером "style-loader", и дабавляется до "style-loader" в массиве с лоадерами.
								Подробнее в главе "Работа со стилями".

							file-loader
							
								Лоадер для работы с файлами. Свойства в "options":
							
									name
									
										Имя выходного файла.

									outputPath
									
										Имя папки, которая будет создана и в которую поместится выходной файл.

###
### Проверить актуальность этого плагина, так как теперь можно добавлять файлы по типу (свойство "type" снизу) с помощью предустановленного лоадера (возможность новой версии "webpack").
###
							
							babel-loader
							
								Лоадер для "Babel". Свойства в "options":
							
									presets
									
										Массив с пресетамии. Например:
									
											options: {
												presets: ['@babel/preset-env'],
											},

					type
					
						//
					
###
### Дополнить.
###
									
					loader
					
						Указать имя лоадера. Не рекомендуется использовать данное свойство, так как свойство "use" более гибкое.

			Пример использования свойства "rules":

				module.exports = {
					module: {
						rules: [
							{
								test: /\.css$/,
								use: ['style-loader', 'css-loader'],		// Массив лоадеров. Здесть сначала задействуется лоадер "css-loader", а затем "style-loader" (с конца к началу).
							},
							{
								test: /\.(jpg|png|svg|gif )$/,
								use: ['file-loader'],						// Один лоадер, поэтому указана как строка а не массив.
							},
							
							// или другой вариант для 'file-loader''file-loader':
							
							{
								test: /\.(svg|png|jpg|gif)$/,
								use: {
									loader: "file-loader",
									options: {
										name: "[name].[hash].[ext]",
										outputPath: "imgs"
									}
								}
							},
							
							{
								test: /\.js$/,
								exclude: /node_modules/,
								use: {
									loader: 'babel-loader',
									options: {
										presets: ['@babel/preset-env'],
									},
								},
							},
							
							
						],
					}
				}
	
	plugins
	
		Массив с плагинамии. Плагины позволяют добавить дополнительные функционал к базовой конфигурации "webpack".

		Для начала необходимо установить нужный плагин через менеджер пакетов "npm":

			npm install -D <имя плагина>

		Пример установки:

			npm install -D html-webpack-plugin

		После установки необходимо импортировать этот плагин как класс. Пример:

			const HTMLWebpackPlugin = require('html-webpack-plugin');

		У некоторых плагинов есть отличия в методе импортирования плагина, например плагин "clean-webpack-plugin" (подробнее в подглаве "Список плагинов" - "clean-webpack-plugin").

		Затем нужно добавить этот новый плагин в объект конфигурации "exports". Для этого добавляется свойство "plugins", значением которого будет массив, где будут перечислены
		плагины. Сами плагины добаляются путем создания нового потомка (инстанса) от класса плагина. При добавления плагина можно передать в конструктор объект с настройками плагина.
		Пример добавления плагина "html-webpack-plugin":

			const path = require('path');
			const HTMLWebpackPlugin = require('html-webpack-plugin');

			module.exports = {
				entry: './src/index.js',
				output: {
					filename: 'bundle.js',
					path: path.resolve(__dirname, 'dist'),
				},
				plugins: [
					new HTMLWebpackPlugin({
						title: "New page",		// объект с настройками плагина.
					}),
				],
			}

		Список плагинов:

			html-webpack-plugin
			
				Плагин для сборки "html" файлов. При использовании данного плагина, можно не указывать скрипты вручную в "html" файле, так как плагин сам их автоматически добавит.
				В конструктор класса опционально можно передать объект со свойствами, которые будут применены к ново-создаваемому "html" файлу (пример приведен выше).
				Свойства объекта, передаваемый конструктору класса:

					title
					
						Заголовок страницы. В значении указывается имя заголовка, в строковом формате. Если используется шаблон "html" файла, который уже имеет заголовок, то данное свойство
						бесполезно.

					template
					
						Шаблон "html" файла, основываясь на котором будет собираться новый "html" файл. В значении указывается адрес шаблона, в строковом формате.

					minify
					
						Объект со свойствами минифицирования. Свойства:

							collapseWhitespace	-	///
###
### Проверить актуальность других плагинов, которые минифицируют !!!
###

			clean-webpack-plugin
			
				Плагин для очищения папки сборки перед сборкой. У данного плагина есть отличия в методе подключения, так как у него импортируется объект не по умолчанию. Чтобы получить
				класс плагина, нужно деструктуризировать импортируемый объект:

				const {CleanWebpackPlugin} = require('clean-webpack-plugin');

				module.exports = {
					entry: './src/index.js',
					output: {
						filename: 'bundle.js',
						path: path.resolve(__dirname, 'dist'),	//	подробнее в руководстве "node-js".
					},
					plugins: [
						new CleanWebpackPlugin(),
					],
				}

###
### Проверить актуальность данного плагина в связи со свойством "clean" в "output" !!!
###

			copy-webpack-plugin
			
				Плагин для копирования файлов и директорий. В конструктор класса передается объект с требуемыми свойствами, которые содержат массив с объетами,
				которые содержат свойства настройки. Пример:

					const CopyWebpackPlugin = require('copy-webpack-plugin');

					module.exports = {
						plugins: [
							new CopyWebpackPlugin({
								patterns: [
									{
										from: path.resolve(__dirname, 'src/assets'),
										to: path.resolve(__dirname, 'dist/assets')
									}
								]
							})
						],
					}

	context

		Указывает контекст сборки (указывает сборщику "webpack" где лежат все исходники проекта). Если данное свойство было использовано, то все пути файлов в остальных свойствах
		(например "entry" и т.д.), нужно будет корректировать основываясь на контексте. Значение рекомендуется использовать встроенный модуль в "node.js", который называется "path"
		(пример приведен ниже). Подробнее о модуле "path" в руководстве "node-js".
		Пример без использования контекста сборки:

			module.exports = {
				entry: {
					main: './src/index.js',
					analitics: './src/analitics.js',
				}
			}

		Пример с использованием контекста сборки:

			const path = require('path');

			module.exports = {
				context: path.resolve(__dirname, 'src'),
				entry: './index.js',						// откорректирован путь из-за использования контекста.
				output: {
					filename: 'bundle.js',
					path: path.resolve(__dirname, 'dist'),
				},
			}

	resolve

		Установка расширений, путей и т.д по умолчанию. Значением данного свойства будет объект со свойствами:

			extentions
			
				Массив с расширениями файлов, которые сборщику нужно понимать по умолчанию. Если использовать данное свойство, то нужно будет отредактировать пути
				(ссылки, адрема) везде во всем проекте, так чтобы они не содержали указанных расширений, потому что сборщик и будет брать по умолчанию.

			alias
			
				Объект для создания шаблонов путей. Свойствами этого объекта будут пользовательские (произвольные) пути (рекомендуется в начале добавить символ "@"), а
				значениями будут уже сами пути.

		Пример:

			const path = require('path');

			module.exports = {
				resolve: {
					extentions: ['jpg', 'gif', 'js'],
					alias: {
						'@models': path.resolve(__dirname, 'src/assets/models'),
						'@': path.resolve(__dirname, 'src/assets/models/temp'),
					}
				}
			}

	optimization

		Оптимизация сборки проекта. Если два скриптовых файла используют одну и ту же библиотеку, то в финальной сборке эта библиотека будет в обоих скриптовых файлах. Данное
		свойство необходимо для решения данной проблемы. Данное свойство является объектом, который содержит свойства:

			splitChunks	-	способ разбиения "кусков" финальной сборки на разные файлы соблюдая зависимости и оптимизируя (не добавляя один и тот же код во все связанные
			скриптовые файлы). Данное свойство является объектом со свойствами:

				chunks	-	позволяет выбрать какой именно чанк выбрать. Значения:

					"all"	-	все чанки.

					
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Использование нескольких файлов конфигураций.

..

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Паттерны имен. 

В именах выходных файлов можно использовать паттерны, которые будут вставать на указанное моесто в имени выходного файла. Сами паттерны указыва.тся в квадратных скобках "[]".
Список паттернов:

	[name]
	
		Если в "entry" исспользуется несколько входных файлов, то вместо этого паттерна на результирующее имя файла станет имя входного файла.
	
	[contenthash]
	
		Добавление хэша по контенту выходного файла.
	
	Примеры использования паттернов имен:
		
		module.exports = {
			context: path.resolve(__dirname, 'src'),
			mode: 'development',
			entry: {
				main: './index.ts',
				analytics: './analytics.ts'
			},
			  output: {
				path: path.resolve(__dirname, "dist"),
				filename: "[name].[contenthash].bundle.js",						// Для "main" выходное имя будет "main.<хэш>.bundle.js", а для "analytics" будет "analytics.<хэш>.bundle.js".
			},
		}

Подробнее "https://webpack.js.org/configuration/output/#template-strings".

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа со стилями.

Для работы со стилями, нужно импортировать его во входном скриптовом файле (в файле, который указан в свойстве "entry"). Для этого нужно установить
соответствующий лоадер (подробнее в главе "Модули-загрузчики"). При импортировании стилей, не пишется ключевое слово "from". Пример импортирования:

	// JS или TS файл

	import './styles/styles.css'	// или любой другой "css" препроцессор.

Для добавления стилей есть два способа:

	1. Добавление стилей в тег "<style>" через использование плагинов "style-loader" и "css-loader".

	2. Выведение скриптов в отдельный файл, используя лоадеры "mini-css-extract-plugin" и "css-loader".
	
Первый способ лучше при режиме разработки "development", так как он быстрее. А второй способ для режима "production", так как он хранит стили в отдельном ".css" файле.

• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

###
### Проверить действительность примечания выше.
###

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

◘ Работа с файлами.

Для работы с файлами, нужно импортировать его во входном скриптовом файле (в файле, который указан в свойстве "entry"). Для этого нужно установить
соответствующий лоадер (подробнее в главе "Модули-загрузчики"). Пример импортирования:

	import './assets/image.png'

• Примечание. В именах/адресах могут использоваться паттерны. Подробнее в главе "Паттерны имен".

###
### Проверить действительность примечания выше.
###






























































